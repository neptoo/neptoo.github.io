[{"content":"需求是商城内的购物车图标遮挡了商品，需要在当前可视区域自由拖动购物车组件，不影响用户点击商品。\n效果预览  录制的gif有一定的掉帧，实际上真机拖动的时候是流畅的。\n 解决思路 查阅文档，微信小程序提供了movable-area和movable-view标签。目前项目里的当前页面是比较简单的，所以可以用movable-area包裹整个可视页面，movable-view包裹你要移动的元素。关键在于项目中使用了自定义导航栏mp-navigation-bar，如何获取页面剩余的内容可用高度。\n代码实现 index.wxml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;mp-navigation-bar background=\u0026#34;#3883ff\u0026#34; title=\u0026#34;商城\u0026#34; back=\u0026#34;{{false}}\u0026#34;\u0026gt;\u0026lt;/mp-navigation-bar\u0026gt; \u0026lt;movable-area\u0026gt; \u0026lt;!-- 内容区域 --\u0026gt; \u0026lt;view style=\u0026#34;height: {{contentHeight}}px\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-box\u0026#34; wx:for=\u0026#34;{{goodsList}}\u0026#34; wx:key=\u0026#34;id\u0026#34; bindtap=\u0026#34;toDetailsTap\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;img-box\u0026#34;\u0026gt; \u0026lt;image src=\u0026#34;{{item.pic}}\u0026#34; class=\u0026#34;image\u0026#34; mode=\u0026#34;aspectFill\u0026#34; lazy-load=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;goods-title van-multi-ellipsis--l2\u0026#34;\u0026gt;{{item.name}}\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;price-parent\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-price\u0026#34;\u0026gt;¥ {{item.price}}\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 内容区域 end --\u0026gt; \u0026lt;!-- 需要拖动的组件 --\u0026gt; \u0026lt;movable-view x=\u0026#34;{{x}}\u0026#34; y=\u0026#34;{{y}}\u0026#34; direction=\u0026#34;all\u0026#34;\u0026gt; \u0026lt;!-- vant-weapp框架中的一个购物车组件，可以替换为其它元素/组件 start --\u0026gt; \u0026lt;van-goods-action-icon icon-class=\u0026#34;goods-icon\u0026#34; icon=\u0026#34;cart-o\u0026#34; text=\u0026#34;购物车\u0026#34; bind:click=\u0026#34;goShopCar\u0026#34; info=\u0026#34;{{ shopNum ? shopNum : \u0026#39;\u0026#39; }}\u0026#34; /\u0026gt; \u0026lt;!-- vant-weapp框架中的一个购物车组件，可以替换为其它元素/组件 end --\u0026gt; \u0026lt;/movable-view\u0026gt; \u0026lt;!-- 需要拖动的组件 end --\u0026gt; \u0026lt;/movable-area\u0026gt;   index.wxss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  movable-view { display: flex; align-items: center; justify-content: center; height: 100rpx; width: 100rpx; background-color: #fff; border-radius: 20rpx; box-shadow: 0rpx 20rpx 50rpx -12rpx rgba(0,0,0,0.25) ; } movable-area { height: 100%; width: 100%; }   index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  Page({ data: { // 设置拖动组件的初始位置  x:340, y: 0, goodsList: [ {id: 15, pic: \u0026#34;https://images.pexels.com/photos/2113994/pexels-photo-2113994.jpeg\u0026#34;, name: \u0026#34;手表\u0026#34;, price: 699}, {id: 17, pic: \u0026#34;https://images.pexels.com/photos/221185/pexels-photo-221185.jpeg\u0026#34;, name: \u0026#34;平板\u0026#34;, price: 1900}, {id: 20, pic: \u0026#34;https://images.pexels.com/photos/1203803/pexels-photo-1203803.jpeg\u0026#34;, name: \u0026#34;相机\u0026#34;, price: 8150}, {id: 21, pic: \u0026#34;https://images.pexels.com/photos/270640/pexels-photo-270640.jpeg\u0026#34;, name: \u0026#34;键盘\u0026#34;, price: 2168} ], }, onLoad(){ this.getCartHeight() }, getCartHeight(){ // 页面初始化时 设置购物车初始位置为 停留在页面高度的2/3的位置 也可以设置成其他值  const height = Math.floor((wx.getSystemInfoSync().windowHeight)*2/3); this.setData({ y: height }) // 获取 自定义导航栏 时 页面高度  let customWindowHeight = wx.getSystemInfoSync().windowHeight // console.log(\u0026#39;customWindowHeight\u0026#39;, customWindowHeight)  let navH = wx.getStorageSync(\u0026#39;navigationBarHeight\u0026#39;) + wx.getStorageSync(\u0026#39;statusBarHeight\u0026#39;) // console.log(\u0026#39;navH\u0026#39;, navH)  let contentHeight = customWindowHeight - navH*2 this.setData({ contentHeight }) }, })   app.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  App({ globalData: {}, onLaunch() { // 自定义导航  this.getNavHeight() }, getNavHeight(){ const { statusBarHeight, platform } = wx.getSystemInfoSync() const { top, height } = wx.getMenuButtonBoundingClientRect() // 状态栏高度 (包含wifi信号、电量、时间的那一行顶部状态栏)  wx.setStorageSync(\u0026#39;statusBarHeight\u0026#39;, statusBarHeight) // 整个导航栏高度 = 胶囊按钮高度 + 状态栏到胶囊按钮间距 * 2 // Android导航栏高度 = 32px + 8px * 2 = 48px // iOS导航栏高度 = 32px + 6px * 2 = 44px  // 判断胶囊按钮信息是否成功获取  if (top \u0026amp;\u0026amp; top !== 0 \u0026amp;\u0026amp; height \u0026amp;\u0026amp; height !== 0) { const navigationBarHeight = (top - statusBarHeight) * 2 + height // 导航栏高度  wx.setStorageSync(\u0026#39;navigationBarHeight\u0026#39;, navigationBarHeight) } else { wx.setStorageSync( \u0026#39;navigationBarHeight\u0026#39;, platform === \u0026#39;android\u0026#39; ? 48 : 40 ) } }, })   参考资料 moveable-area 微信小程序文档\n小程序自定义导航栏适配（完美版）\n","date":"2023-04-28T14:05:29Z","image":"https://images.unsplash.com/photo-1508921340878-ba53e1f016ec?ixlib=rb-4.0.3\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=1170\u0026q=80","permalink":"https://neptoo.github.io/2023/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%BB%91%E5%9D%97%E7%BB%84%E4%BB%B6/","title":"微信小程序实现全屏可拖动滑块组件"},{"content":"生命不息，折腾不止。继几次给同事安利成功后，我决定写一篇博客总结一下我经常使用的笔记软件。\nNotion 19年的时候开始了解到并使用notion，真正几乎每天使用是在去年。之前使用了一段时间的是语雀，我很喜欢日历视图。\n大概等语雀送的一年会员到期，因为语雀改版，页面不再简洁，我就不再使用它。语雀是阿里的技术文档社区，有一批优质程序员博主，这也是它的优势之一。对于我自己来说，作为一个笔记应用，是否订阅博主其实不是很重要，并且它后来推出的很多功能是为了商业化，作为用户使用体验是不大好的。\n在每天的工作中，使用日历视图管理待办事项是很方便的，有时候需要实现的需求，最后周报总结的时候有助于回顾。\nNotion可以用来记账。每次阻止我记账的原因，坚持不下来的原因就是时间久了我会忘记。介于工作的时候使用notion日历管理我的日程，几乎每天都会打开notion，所以很大程度缓解了记账的难度。去年坚持了一整年，年度总结可以导出notion数据到Excel，清晰明了的分析自己的经济状况。\n从最开始使用到高频使用，我之前也试用过，觉得notion使用教程太复杂，不适合我。但是对于功能复杂的软件，选择一个功能点去用就好，如果是适合你的，好用的，后续自然而然就用习惯了。并不需要觉得太有负担。\n我也尝试过notion的看板功能，可以用来记录读过的书或者简历投递记录。\n在看板里每一个项目可以展开一个新的页面，可以在页面里记录详情，你可以灵活创建新的属性。\nObisidian notion唯一的问题是使用的在线服务，如果有一天notion被墙或者官方不再支持查看之前的数据，这些都是很不便的，所以我选择了本地存储数据的文档管理软件\u0026ndash;Obisidian。\nObisidian有一个很好用的热门插件，叫 Daily notes。你可以选择一个文件夹，用来存储你每天的日记文档。可以设置模板，比如每天要做的事项，我自己倾向于使用空白模板。Obisidian可以看作一个markdown文件管理软件。平时工作中更细节的需求、问题记录、思路和代码等我会整理在这里。配合notion 日历视图里写的是任务摘要。\n我也会使用Obisidian管理leetcode刷题记录。本质上还是使用的markdown文档，md文档的树形结构是很方便很有条理性的，在obisidian中可以选择折叠/展开某个目录。复习题目的时候可以不看答案，只看题目或者重点。\nObisidian最大的特色应该就是双向链接，你可以使用图中的格式创建另一个文档的链接，鼠标hover移动上去并且按住ctrl键，可以预览链接文档的内容。\n","date":"2023-03-29T10:55:43Z","image":"https://images.pexels.com/photos/4160094/pexels-photo-4160094.jpeg","permalink":"https://neptoo.github.io/2023/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/","title":"生产力工具推荐"},{"content":"效果预览 点击地图上的散点，默认展示公司设备状态；点击公司标题，切换信息；再次点击公司名，返回展示之前的信息。\n散点数据处理(可跳过) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  handleData(){ // 测试数据  this.normalGroup = [ { value: [112.2, 34.4], companyName: \u0026#34;河南有限公司\u0026#34;, device: \u0026#39;test123456\u0026#39;, status: \u0026#39;正常\u0026#39;, type: 1 }, { value: [111.2, 24.4], companyName: \u0026#34;湖北有限公司\u0026#34;, device: \u0026#39;test111111\u0026#39;, status: \u0026#39;正常\u0026#39;, type: 2 }, { value: [113.2, 35.4], companyName: \u0026#34;北京有限公司\u0026#34;, device: \u0026#39;test222222\u0026#39;, status: \u0026#39;正常\u0026#39;, type: 1 } ]; this.warnGroup = [ { value: [76.2, 39.4], companyName: \u0026#34;新疆有限公司\u0026#34;, device: \u0026#39;test123456\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 }, { value: [111.2, 24.4], companyName: \u0026#34;湖北有限公司\u0026#34;, device: \u0026#39;test333333\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 }, { value: [110.2, 35.4], companyName: \u0026#34;广东有限公司\u0026#34;, device: \u0026#39;test222222\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 }, { value: [112.2, 35.4], companyName: \u0026#34;广东有限公司\u0026#34;, device: \u0026#39;test232222\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 } ]; this.reHandleData(); this.initMap(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  // 处理一家公司名下的设备 组成树形数据 subdata reHandleData(){ // 深拷贝创建数据处理前的局部变量  let localGreenData = this.normalGroup.concat(); // 正常组  let localBlueData = this.warnGroup.concat(); // 警告组  // 数据处理后的局部变量  let newLocalGreenData = []; let newLocalBlueData = []; // 数据处理的判断条件，用于保存所有点的不重复的坐标  let greenPositionList = []; let bluePositionList = []; localGreenData.forEach((element) =\u0026gt; { if (greenPositionList.toString().indexOf(element.value.toString()) === -1) { greenPositionList.push(element.value); } }); localBlueData.forEach((element) =\u0026gt; { if (bluePositionList.toString().indexOf(element.value.toString()) === -1) { bluePositionList.push(element.value); } }); // 业务逻辑：如果一家公司名下，设备A是异常警告状态，设备B是正常状态，  // 地图上这个公司的点应该是警告的颜色，警告的优先级更高  // 根据两种positionList对2个数组进行过滤，并组装，从警告级别开始  // 组装数组内，同坐标点的节点  localBlueData = this.getTreeByArray(localBlueData); localBlueData.forEach((element) =\u0026gt; { // element.subData = []  if (greenPositionList.toString().indexOf(element.value.toString()) \u0026gt; -1) { localGreenData.forEach((element1) =\u0026gt; { if (element.value.toString() === element1.value.toString()) { element.subData.push(element1); } }); localGreenData = localGreenData.filter((item) =\u0026gt; { return item.value.toString() !== element.value.toString(); }); } newLocalBlueData.push(element); }); localGreenData = this.getTreeByArray(localGreenData); this.warnGroup = newLocalBlueData; this.normalGroup = newLocalGreenData; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //将数组中坐标值(value)相同的数据项折叠，生成树结构 getTreeByArray(array) { let repeatList = []; //合并数组自身的同坐标项  let leftArray = []; let rightArray = []; array.forEach((element) =\u0026gt; { if (repeatList.toString().indexOf(element.value.toString()) === -1) { repeatList.push(element.value); leftArray.push(element); } else { rightArray.push(element); } }); leftArray.forEach((element) =\u0026gt; { element.subData = []; rightArray.forEach((element1) =\u0026gt; { if (element.value.toString() === element1.value.toString()) { element.subData.push(element1); } }); }); array = leftArray.concat(); return array; },   ECharts 地图展示散点 1  \u0026lt;div class=\u0026#34;map\u0026#34; id=\u0026#34;mymap\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163  initMap(){ const _this = this; let mychart = echarts.init(document.getElementById(\u0026#34;mymap\u0026#34;)) mychart.off(\u0026#39;click\u0026#39;) let convertData = function (data) { // 处理数据函数  let res = []; for (let i = 0; i \u0026lt; data.length; i++) { let obj = { device: data[i].device, companyName: data[i].companyName, subData: data[i].subData, value: data[i].value, type: data[i].type, } res.push(obj) } return res } let convertSeries = [{ type: \u0026#34;effectScatter\u0026#34;, coordinateSystem: \u0026#34;bmap\u0026#34;, data: convertData(_this.normalGroup), symbolSize: 24, label: { show: true, color: \u0026#34;#fff\u0026#34;, fontSize: 16, // distance: 0,  formatter: function (item) { // 散点中心显示数字-公司名下的设备总数  let label = item.data.subData.length + 1; return label; }, }, showEffectOn: \u0026#34;emphasis\u0026#34;, hoverAnimation: true, animation: false, itemStyle: { normal: { color: \u0026#34;#0CB481\u0026#34;, }, }, zlevel: 2, },{ type: \u0026#34;effectScatter\u0026#34;, coordinateSystem: \u0026#34;bmap\u0026#34;, data: convertData(_this.warnGroup), symbolSize: 24, label: { show: true, color: \u0026#34;#fff\u0026#34;, fontSize: 16, distance: 0, formatter: function (item) { let label = item.data.subData.length + 1; return label; }, }, showEffectOn: \u0026#34;render\u0026#34;, rippleEffect: { period: 8, scale: 1.5, brushType: \u0026#34;stroke\u0026#34;, }, hoverAnimation: true, animation: false, itemStyle: { normal: { color: \u0026#34;#0D86F5\u0026#34;, }, emphasis: { color: \u0026#34;#0D86F5\u0026#34;, }, }, zlevel: 3, }] let oldTooltip = { trigger: \u0026#39;item\u0026#39;, triggerOn: \u0026#39;click\u0026#39;, enterable: true, borderWidth: 0, showDelay: 0, hideDelay: 0, transitionDuration: 0, // 白底黑字  extraCssText: \u0026#34;z-index:100;background:rgba(0,0,0,0.8);color:#fff;padding:0;\u0026#34;, formatter: function(item){ // 重要警告！！！这里使用了formatter返回原生html字符串，使用了大量的字符串拼接操作  // 测试发现这里不支持对象的{}表示方式，所以只能使用[[],[]]二维数组的方式  // 使用了大量单引号双引号和转义符，如果出错一般就是字符串拼接时候引号对应错误  let data = []; let allPage = item.data.subData.length + 1; // 将当前页码和总页数存储为二维数组的第一项  // 注意data里每个字段的顺序和展示的tooltip顺序保持一致  let pushArr = [ item.data.device, item.data.companyName, item.data.type, ] data.push(pushArr); item.data.subData.forEach((element) =\u0026gt; { data.push([ element.device, element.companyName, element.type ]) // 每次打开新的tooltip，初始化页码和当前deviceName  _this.tooltipCurDeviceName = data[0][0]; _this.tooltipCurPage = 1; data = JSON.stringify(data); let newData = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; data.length; i++) { if (data[i] === \u0026#39;\u0026#34;\u0026#39;) { newData += \u0026#34;\u0026#39;\u0026#34;; } else { newData += data[i]; } } data = newData; // 使用字符串拼接，根据条件修改原生css  let conditionalCSS = \u0026#34;\u0026#34;; switch (item.data.status) { case \u0026#34;警告\u0026#34;: conditionalCSS += \u0026#34;style=\u0026#39;color:#0D86F5\u0026#39;\u0026#34;; break; case \u0026#34;正常\u0026#34;: conditionalCSS += \u0026#34;style=\u0026#39;color:#0CB481\u0026#39;\u0026#34;; break; } let resultHtml = ` \u0026lt;div id=\u0026#34;tooltipDiv\u0026#34; style=\u0026#34;padding: 20px;\u0026#34;\u0026gt; \u0026lt;div onclick=\u0026#34;titleClick(${data})\u0026#34;\u0026gt; \u0026lt;span\u0026gt;${item.data.companyName}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ` +\u0026#39;\u0026lt;div id=\u0026#34;statusDiv\u0026#34;\u0026gt;状态：\u0026lt;b\u0026#39; + conditionalCSS + item.data.status + \u0026#34;\u0026lt;/b\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;; return resultHtml } } } let option = { bmap: { center: [104.5, 30.8], roam: true, }, tooltip: oldTooltip, animation: false, series: convertSeries }; // 每次点击散点的时候 初始化tooltip  mychart.on(\u0026#39;click\u0026#39;, function (element) { let tempOption = mychart.getOption() tempOption.tooltip = oldTooltip mychart.setOption(tempOption) }) mychart.setOption(option) }   点击标题切换 tooltip 信息内容 在模板字符串中，使用 onclick 绑定事件 titleClick；在 created 阶段中，将方法赋给 window 全局事件。\n1 2 3 4  created() { window.titleClick = this.handleTitleCheck; // window.titleBack = this.handleTitleBack; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // 点击公司名 tooltip信息展示 handleTitleCheck(){ let mychart = echarts.init(document.getElementById(\u0026#34;mymap\u0026#34;)); let newTooltip = { trigger: \u0026#39;item\u0026#39;, triggerOn: \u0026#39;click\u0026#39;, enterable: true, borderWidth: 0, showDelay: 0, hideDelay: 0, transitionDuration: 0, extraCssText: \u0026#34;z-index:100;background:rgba(0,0,0,0.8);color:#fff;padding:0;\u0026#34;, formatter: function (item) { let data = []; let pushArr = [ item.data.companyName, item.data.type, ] data.push(pushArr); data = JSON.stringify(data); let newData = \u0026#34;\u0026#34;; //将data中的双引号替换成单引号，不然字符串拼接就会错误  for (let i = 0; i \u0026lt; data.length; i++) { if (data[i] === \u0026#39;\u0026#34;\u0026#39;) { newData += \u0026#34;\u0026#39;\u0026#34;; } else { newData += data[i]; } } data = newData; let resultHtml = `\u0026lt;div id=\u0026#34;tooltipDiv\u0026#34; style=\u0026#34;padding: 20px;\u0026#34;\u0026gt; \u0026lt;div onclick=\u0026#34;titleBack(${data})\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-back\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span style=\u0026#34;margin-left:6px;\u0026#34;\u0026gt;设备名${item.data.device}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; `; return resultHtml }, } let myoption = mychart.getOption() myoption.tooltip = newTooltip mychart.setOption(myoption) },   ","date":"2022-11-09T15:41:16Z","image":"https://images.pexels.com/photos/41949/earth-earth-at-night-night-lights-41949.jpeg","permalink":"https://neptoo.github.io/2022/vue-%E4%B8%AD-echarts-tooltip-%E6%95%A3%E7%82%B9%E4%BF%A1%E6%81%AF%E5%88%87%E6%8D%A2%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","title":"Vue 中 ECharts tooltip 散点信息切换和事件绑定"},{"content":"预览效果 ECharts组件封装 传入指定的 id 、option、宽高，然后渲染图表。\n封装 component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  // ehistogram.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div ref=\u0026#34;chart\u0026#34; :id=\u0026#34;idName\u0026#34; :style=\u0026#34;{ height: height, width: width }\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;ehistogram\u0026#39;, props: { width: { type: String, default: \u0026#39;100%\u0026#39; }, height: { type: String, default: \u0026#39;350px\u0026#39; }, autoResize: { type: Boolean, default: true }, chartOption: { type: Object, required: true }, idName: { type: String, required: true }, type: { type: String, default: \u0026#39;canvas\u0026#39; } }, data() { return { chart: null } }, watch: { chartOption: { deep: true, handler(newVal) { this.setOptions(newVal) } } }, mounted() { this.initChart() if (this.autoResize) { window.addEventListener(\u0026#39;resize\u0026#39;, this.resizeHandler) } }, beforeDestroy() { if (!this.chart) { return } if (this.autoResize) { window.removeEventListener(\u0026#39;resize\u0026#39;, this.resizeHandler) } this.chart.dispose() this.chart = null }, methods: { resizeHandler() { this.chart.resize() }, initChart() { this.chart = this.$echarts.init(this.$refs.chart, \u0026#39;\u0026#39;, { renderer: this.type }) this.chart.setOption(this.chartOption) this.chart.on(\u0026#39;click\u0026#39;, this.handleClick) }, handleClick(params) { this.$emit(\u0026#39;click\u0026#39;, params) }, setOptions(option) { this.clearChart() this.resizeHandler() if (this.chart) { this.chart.setOption(option) } }, refresh() { this.setOptions(this.chartOption) }, clearChart() { this.chart \u0026amp;\u0026amp; this.chart.clear() } } } \u0026lt;/script\u0026gt;   联动和数据共享  官网提供了实例，但是它是上下布局， dataset 数据格式不一样，处理方法相对复杂，所以我没有采用。\n 初始化数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ehistogram idName=\u0026#34;pieLineContainer\u0026#34; :chart-option=\u0026#34;pieLineOption\u0026#34; :auto-resize=\u0026#34;true\u0026#34; height=\u0026#34;400px\u0026#34; width=\u0026#34;100%\u0026#34;\u0026gt;\u0026lt;/ehistogram\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ehistogram from \u0026#34;./components/ehistogram.vue\u0026#34; export default { components: { ehistogram }, data() { this.pieLineOption = { \u0026#34;legend\u0026#34;: { \u0026#34;data\u0026#34;: [], \u0026#34;textStyle\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#fff\u0026#34; }, \u0026#34;show\u0026#34;: true, \u0026#34;x\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;left\u0026#34;: \u0026#34;center\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;3%\u0026#34; }, \u0026#34;tooltip\u0026#34;: { \u0026#34;show\u0026#34;: true, \u0026#34;trigger\u0026#34;: \u0026#34;axis\u0026#34; }, \u0026#34;grid\u0026#34;: { \u0026#34;left\u0026#34;: \u0026#34;40%\u0026#34;, \u0026#34;right\u0026#34;: \u0026#34;5%\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;25%\u0026#34;, \u0026#34;bottom\u0026#34;: \u0026#34;10%\u0026#34;, \u0026#34;containLabel\u0026#34;: true }, \u0026#34;xAxis\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;category\u0026#34;, \u0026#34;axisLabel\u0026#34;: { \u0026#34;show\u0026#34;: true, \u0026#34;textStyle\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#fff\u0026#34; } }, \u0026#34;axisTick\u0026#34;: { \u0026#34;show\u0026#34;: false }, \u0026#34;data\u0026#34;: [] }, \u0026#34;yAxis\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;value\u0026#34;, \u0026#34;axisLabel\u0026#34;: { \u0026#34;show\u0026#34;: true, \u0026#34;textStyle\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#fff\u0026#34; } }, \u0026#34;axisLine\u0026#34;: { \u0026#34;show\u0026#34;: false }, \u0026#34;axisTick\u0026#34;: { \u0026#34;show\u0026#34;: false } }, \u0026#34;series\u0026#34;: [] }; return { pieColors: [\u0026#39;#69D2E7\u0026#39;, \u0026#39;#AAB3AB\u0026#39;, \u0026#39;#61a0a8\u0026#39;, \u0026#39;#d48265\u0026#39;, \u0026#39;#A8E6CE\u0026#39;, \u0026#39;#FF9933\u0026#39;, \u0026#39;#C2C287\u0026#39;], } },   数据处理和图表渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  mounted() { this.handleData() }, methods() { handleData(){ //从api获取你需要的真实数据 此处就直接赋值了 \tlet xAixsData = [ \u0026#34;2022-09-01 00\u0026#34;, \u0026#34;2022-09-01 01\u0026#34;, \u0026#34;2022-09-01 02\u0026#34;, \u0026#34;2022-09-01 03\u0026#34;, \u0026#34;2022-09-01 04\u0026#34;, \u0026#34;2022-09-01 05\u0026#34;, \u0026#34;2022-09-01 06\u0026#34;, \u0026#34;2022-09-01 07\u0026#34;, \u0026#34;2022-09-01 08\u0026#34;, \u0026#34;2022-09-01 09\u0026#34;, \u0026#34;2022-09-01 10\u0026#34;, \u0026#34;2022-09-01 11\u0026#34;, \u0026#34;2022-09-01 12\u0026#34;, \u0026#34;2022-09-01 13\u0026#34;, \u0026#34;2022-09-01 14\u0026#34;, \u0026#34;2022-09-01 15\u0026#34;, \u0026#34;2022-09-01 16\u0026#34; ]; let legendName = [ \u0026#34;羽毛\u0026#34;, \u0026#34;地膜\u0026#34;, \u0026#34;棉花\u0026#34;, ]; let line1 = [7,10,14,5,5,9,6,4,7,10, 3,5,2,6,11,5,5]; let line2 = [ 51,43,43,37,30,37,36,36,30,27,25,25,48,43,31,37,23]; let line3 = [0,0,2,0,0,0,0,0,0,0,0,0,8,0,0,0,0]; let lineObj = [line1, line2, line3] let allSum = [{ \u0026#34;name\u0026#34;: \u0026#34;羽毛\u0026#34;, \u0026#34;value\u0026#34;: 114 }, { \u0026#34;name\u0026#34;: \u0026#34;地膜\u0026#34;, \u0026#34;value\u0026#34;: 602 }, { \u0026#34;name\u0026#34;: \u0026#34;棉花\u0026#34;, \u0026#34;value\u0026#34;: 10 }] let seriesTemp = [] for (let i = 0; i \u0026lt; legendName.length; i++) { let objLine = { name: legendName[i], type: \u0026#34;line\u0026#34;, color: this.pieColors[i], smooth: true, data: lineObj[i] } seriesTemp.push(objLine) } let pieObj = { name: \u0026#34;总数\u0026#34;, type: \u0026#39;pie\u0026#39;, color: this.pieColors, center: [\u0026#39;15%\u0026#39;, \u0026#39;54%\u0026#39;], radius: \u0026#39;50%\u0026#39;, data: allSum, label: { formatter: (params) =\u0026gt; { return params.name + \u0026#39;:\u0026#39; + params.value } }, } seriesTemp.push(pieObj) this.initChart(xAixsData, legendName, seriesTemp) }, initChart(xAixsData, legendName, seriesTemp){ this.pieLineOption.xAxis.data = xAixsData this.pieLineOption.legend.data = legendName this.pieLineOption.series = seriesTemp this.pieLineChart = this.$echarts.init(document.getElementById(\u0026#39;pieLineContainer\u0026#39;)); this.pieLineChart.setOption(this.pieLineOption); } } } \u0026lt;/script\u0026gt;   ","date":"2022-09-02T10:13:24Z","image":"https://images.pexels.com/photos/7947663/pexels-photo-7947663.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1","permalink":"https://neptoo.github.io/2022/vue-echarts-%E5%AE%9E%E7%8E%B0%E9%A5%BC%E5%9B%BE%E5%92%8C%E6%8A%98%E7%BA%BF%E5%9B%BE%E8%81%94%E5%8A%A8/","title":"Vue+ ECharts 实现饼图和折线图联动"},{"content":"Prerequisite: You have installed Vue.js(^2.5.2) and ElementUI(^2.15.8) in your project.\nCreating our own custom components Get started with Basic HTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-upload :action=\u0026#34;ossUploadUrl\u0026#34; :data=\u0026#34;dataObj\u0026#34; list-type=\u0026#34;picture-card\u0026#34; :file-list=\u0026#34;fileList\u0026#34; :before-upload=\u0026#34;beforeUpload\u0026#34; :on-remove=\u0026#34;handleRemove\u0026#34; :on-success=\u0026#34;handleUploadSuccess\u0026#34; :on-preview=\u0026#34;handlePreview\u0026#34; :limit=\u0026#34;maxCount\u0026#34; accept=\u0026#34;.jpg, .jpeg, .png, .gif, .mp4\u0026#34; :on-exceed=\u0026#34;handleExceed\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-plus\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogVisible\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;100%\u0026#34; :src=\u0026#34;dialogImageUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   Defining data and props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;script\u0026gt; import { policy } from \u0026#39;@/api/oss\u0026#39; export default { name: \u0026#39;multiPicUpload\u0026#39;, props: { // images array from parent template  value: Array, maxCount: { type: Number, default: 5 } }, data() { return { dataObj: { policy: \u0026#39;\u0026#39;, signature: \u0026#39;\u0026#39;, key: \u0026#39;\u0026#39;, ossaccessKeyId: \u0026#39;\u0026#39;, dir: \u0026#39;\u0026#39;, host: \u0026#39;\u0026#39; }, dialogVisible: false, dialogImageUrl: null, ossUploadUrl: \u0026#39;https://xxxxx.aliyun.com\u0026#39;, //replace it with your back-end service  }; },   Compute the array of uploaded images 1 2 3 4 5 6 7 8 9 10 11 12  computed: { fileList() { let fileList = []; if (this.value === undefined) return; for (let i = 0; i \u0026lt; this.value.length; i++) { fileList.push({ url: this.value[i] }); } return fileList; } },   Required Methods in doc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  methods: { emitInput(fileList) { let arr = []; for (let i = 0; i \u0026lt; fileList.length; i++) { arr.push(fileList[i].url); } this.$emit(\u0026#39;input\u0026#39;, arr) }, handleRemove(file, fileList) { this.emitInput(fileList); }, handlePreview(file) { this.dialogImageUrl = file.url; this.dialogVisible = true; }, beforeUpload(file) { // Tell if the image is larger than 5M  const isLt5M = file.size / 1024 / 1024 \u0026lt; 5; // const fileType = file.name.substring(file.name.lastIndexOf(\u0026#39;.\u0026#39;)+1)  // Identify the type of the image  // const isJpg = file.type == \u0026#39;image/jpeg\u0026#39; || file.type == \u0026#39;image/jpg\u0026#39; || file.type == \u0026#39;image/png\u0026#39; || file.type == \u0026#39;image/gif\u0026#39;  // if(!isJpg){  // this.$message.error(\u0026#39;You can only upload these image file types: jpg, jpeg, png, gif！\u0026#39;)  // return false  // }  if (!isLt5M) { this.$message.error(\u0026#39;The size of the uploaded image cannot exceed 5MB!\u0026#39;); return false } let _self = this; return new Promise((resolve, reject) =\u0026gt; { // policy() is a GET request, not POST  policy().then(response =\u0026gt; { _self.dataObj.policy = response.data.policy; _self.dataObj.signature = response.data.signature; _self.dataObj.ossaccessKeyId = response.data.accessKeyId; _self.dataObj.key = response.data.dir + \u0026#39;/${filename}\u0026#39;; _self.dataObj.dir = response.data.dir; _self.dataObj.host = response.data.host; resolve(true) }).catch(err =\u0026gt; { console.log(err) reject(false) }) }) }, handleUploadSuccess(response, file, fileArr) { console.log(\u0026#39;Upload successful!\u0026#39;) let url = this.dataObj.host + \u0026#39;/\u0026#39; + this.dataObj.dir + \u0026#39;/\u0026#39; + fileArr.name; // Get the image url  this.fileList.push({ name: fileArr.name, url: url }); this.emitInput(this.fileList); }, handleExceed(file, fileList) { this.$message({ message: \u0026#39;Maximum of\u0026#39; + this.maxCount + \u0026#39;images can be uploaded\u0026#39;, type: \u0026#39;warning\u0026#39;, duration: 1000 }); }, } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;   how to use this component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-form-item label=\u0026#34;device photos\u0026#34;\u0026gt; \u0026lt;multipic-upload v-model=\u0026#34;selectDevicePicFiles\u0026#34;\u0026gt;\u0026lt;/multipic-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MultipicUpload from \u0026#34;@/components/Upload/multipicUpload\u0026#34;; export default { components: { MultipicUpload }, computed: { selectDevicePicFiles: { get: function () { return this.detailDevice.picUrl; }, set: function (newValue) { console.log(\u0026#34;get a newValue\u0026#34;, newValue); if (newValue == null || newValue.length === 0) { this.detailDevice.picUrl = []; } else { if (newValue.length \u0026gt; 0) { this.detailDevice.picUrl = newValue; } } }, }, }, }; \u0026lt;/script\u0026gt;   Others 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // some utils/methods in case you want to see it  // api/oss.js import request from \u0026#39;@/utils/request\u0026#39; export function policy() { return request({ url:\u0026#39;/zm-admin/aliyun/oss/policy\u0026#39;, method:\u0026#39;get\u0026#39;, }) } // utils/request.js import axios from \u0026#39;axios\u0026#39; import { Message, MessageBox } from \u0026#39;element-ui\u0026#39; import store from \u0026#39;../store\u0026#39; import { getToken } from \u0026#39;@/utils/auth\u0026#39; const service = axios.create({ baseURL: process.env.BASE_API, timeout: 15000 }) service.interceptors.request.use(config =\u0026gt; { if (store.getters.token) { config.headers[\u0026#39;Authorization\u0026#39;] = getToken() // token  } return config }, error =\u0026gt; { console.log(error) // for debug  Promise.reject(error) }) export default service // auth.js import Cookies from \u0026#39;js-cookie\u0026#39; const TokenKey = \u0026#39;xxxxxToken\u0026#39; export function getToken() { return Cookies.get(TokenKey) }   Reference ElementUI Docs\n","date":"2022-08-17T18:01:47Z","image":"https://images.pexels.com/photos/4201333/pexels-photo-4201333.jpeg","permalink":"https://neptoo.github.io/2022/encapsulation-of-el-upload-display-an-image-after-uploading/","title":"Encapsulation of el upload - display an image after uploading"},{"content":" 三个月前的项目，一直想写一篇文章整理下，拖延了这么久，都忘得差不多了。其实最好是在知识还热乎的时候记下来，这篇文章最好的发表时间是三个月前╮(╯▽╰)╭\n 先放效果图：\n引入 Library 首先，引入需要的js库，可以从 three.js 官方github仓库中找到并下载，你可能会用到的：\n three.js OrbitControls.js GLTFLoader.js RGBELoader.js   前两个是必须用到的，最后一个是根据你使用的文件格式，选择不同的 loader 处理器。我还尝试过 STLLoader 和 FBXLoader 。\n 1 2 3 4 5 6  \u0026lt;!-- 包下载路径 --\u0026gt; \u0026lt;!-- https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/STLLoader.js --\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/three.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/GLTFLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/RGBELoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    引入 RGBELoader 是因为在后面用到了 HDR 贴图，简而言之，就是调整环境光，给模型上色。\n 在 html 文件中创建一个 div ，让我们的模型能够显示出来。\n1  \u0026lt;div id=\u0026#34;mymodel\u0026#34; style=\u0026#34;width:500px; height: 600px;margin:100px auto;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   加载模型 初始处理 首先，创建一个模型渲染方法，需要传入要绑定的页面元素的 ID，在方法里对模型进行处理。\n1 2 3 4 5 6 7 8  function glbViewer(id){ var elem = document.getElementById(elementID); var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); }   添加相机 camera，它决定了元素在页面中看起来的效果，就像一个投影相机，它接收4个参数，表示垂直视野角度，渲染窗口的长宽比，最近端的截面，最远端的截面。\n添加渲染器 renderer，设置 aplha 为 true，这样背景颜色透明，模型就可以浸染到页面背景中。设置渲染器画布的宽高和元素宽高一致，然后将它 append 到页面中。\n1 2 3 4 5 6 7 8 9  var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1; renderer.outputEncoding = THREE.sRGBEncoding; elem.appendChild(renderer.domElement);   outputEncoding 控制输出渲染编码，toneMapping 即使贴图不是 HDR，也可以塑造更真实的效果，toneMappingExposure 调整曝光度。\n添加页面自适应，窗口调整时重置画布的大小\n1 2 3 4 5  window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth/elem.clientHeight; camera.updateProjectionMatrix(); }, false);   然后，我们来定义 controls \u0026ndash;控制模型的变换缩放和旋转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; // 启用 damping 给控制器带来重量感 controls.dampingFactor = 0.1; //动态系数因子 越小越灵敏 controls.rotateSpeed = 0.05; controls.enableZoom = true; // 是否可以缩放 controls.autoRotate = true; // 是否自动旋转 controls.autoRotateSpeed = 5; // 自动旋转速度  controls.minDistance = 2; controls.maxDistance = 10; controls.target.set(0, 0.5, - 0.2); // 决定了初始化时 模型在页面视野中的角度  controls.update();   设置场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var scene = new THREE.Scene(); new THREE.RGBELoader() .load(\u0026#39;shanghai_riverside_4k.hdr\u0026#39;, function (texture) { // hdr 文件和 index.html 在同级  texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = new THREE.Color(0xffffff); scene.environment = texture; const loader = new THREE.GLTFLoader() .setPath(\u0026#39;assets/models/\u0026#39;); //根据你放的模型或者图片的位置决定是否要使用setPath  loader.load(\u0026#39;white.glb\u0026#39;, function (gltf) { camera.position.set(4, 0.3, -1.2); gltf.scene.position.y = -1.8; scene.add(gltf.scene); // 创建闭包 不断调用 animate 动画函数  // animate 函数通过调用 controls 的 update 函数来更新整个场景，然后让 three.js 去渲染  var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); });   你可以在 HDR 资源网站下载你需要的 hdr 文件\u0026ndash;可以理解为全景图。\n完工 调用上面的方法，将模型和我们前面定义的页面元素绑定起来。\n1 2 3 4 5  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { glbViewer(\u0026#34;mymodel\u0026#34;) } \u0026lt;/script\u0026gt;   总结 three.js 官网不仅仅有文档，也提供了各种文件格式各种效果渲染的实例，可以结合例子和 Github 中实例源码进行学习，手把手带你上手 three.js 。\n有一次建模的同事提供的是零件版 3D 模型，UI 同事是在专业的 3D 渲染和处理的软件( keyshot )中打开，所以导致我在浏览器中渲染出来的效果和他们看到的效果不一样，有时候问题可能是模型并不完整而不是代码问题。\ngltf 在线查看：https://gltf-viewer.donmccurdy.com/\n后续还有一些细节或者问题待优化，需要自己学习和研究一下 Blender ，自己建模和贴图。\n完整代码：(附赠一个 stl 渲染 demo)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;model\u0026#34; style=\u0026#34;width:500px; height: 600px;margin:100px auto;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 包下载路径 --\u0026gt; \u0026lt;!-- https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/STLLoader.js --\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/three.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/GLTFLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/RGBELoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/STLLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function glbViewer(elementID) { var elem = document.getElementById(elementID) var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1; renderer.outputEncoding = THREE.sRGBEncoding; elem.appendChild(renderer.domElement); window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth / elem.clientHeight; camera.updateProjectionMatrix(); }, false); var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.minDistance = 2; controls.maxDistance = 10; controls.target.set(0, 0.5, - 0.2); controls.autoRotate = false; //自动旋转  controls.autoRotateSpeed = 5; //旋转速度  controls.update(); var scene = new THREE.Scene(); new THREE.RGBELoader() // .setPath(\u0026#39;assets/3d/\u0026#39;)  .load(\u0026#39;shanghai_riverside_4k.hdr\u0026#39;, function (texture) { texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = new THREE.Color(0xffffff); scene.environment = texture; const loader = new THREE.GLTFLoader() .setPath(\u0026#39;assets/models/\u0026#39;); loader.load(\u0026#39;white.glb\u0026#39;, function (gltf) { camera.position.set(4, 0.3, -1.2); gltf.scene.position.y = -1.8; scene.add(gltf.scene); var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); }); } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { glbViewer(\u0026#34;model\u0026#34;) } \u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt; function STLViewer(model, elementID) { var elem = document.getElementById(elementID) var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); elem.appendChild(renderer.domElement); window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth / elem.clientHeight; camera.updateProjectionMatrix(); }, false); var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.rotateSpeed = 0.05; controls.dampingFactor = 0.1; controls.enableZoom = true; controls.autoRotate = true; //自动旋转 controls.autoRotateSpeed = .75; var scene = new THREE.Scene(); scene.add(new THREE.HemisphereLight(0xe74c3c, 1)); (new THREE.STLLoader()).load(model, function (geometry) { const material = new THREE.MeshPhysicalMaterial({ metalness: 0.25, roughness: 0.1, opacity: 1.0, transparent: true, transmission: 0.99, clearcoat: 1.0, clearcoatRoughness: 0.25 }) var mesh = new THREE.Mesh(geometry, material); scene.add(mesh); var middle = new THREE.Vector3(); geometry.computeBoundingBox(); geometry.boundingBox.getCenter(middle); mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation( -middle.x, -middle.y, -middle.z)); var largestDimension = Math.max(geometry.boundingBox.max.x, geometry.boundingBox.max.y, geometry.boundingBox.max.z) camera.position.y = -largestDimension * 1.6; var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { STLViewer(\u0026#34;exa.stl\u0026#34;, \u0026#34;model\u0026#34;) } \u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;/body\u0026gt;   参考资料 Three.js 官方文档\n如何在页面极速渲染3D模型-腾讯 ISUX 团队\nThree.js 真实渲染\n","date":"2022-07-05T17:19:43Z","image":"https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1","permalink":"https://neptoo.github.io/2022/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84three.js%E6%B8%B2%E6%9F%933d%E6%A8%A1%E5%9E%8B/","title":"从零开始的Three.js渲染3D模型"},{"content":"当需要从数据库查询的表有上万条记录的时候，将会导致查询和插入耗时太长，特别是随着数据量的增加特别明显，这时需要对于数据库查询，有很多种方法和优化的点。\n 依然是面试官系列，如何在 MySQL 中处理十万条以上数据？本来打算作为数据库笔记的附加题，查资料后发现可以延伸到很多方面。\n 分页 如果使用的ORM框架是mybatis的话，有开源的分页插件可以使用，如：Mybatis-PageHelper。如果不使用分页插件，那么就需要手动分页了，由于不同的数据库实现分页的SQL语句并不一致，如Mysql使用的是limit关键字，而Oracle使用的是rownum。首先讲讲分页操作必须满足的几个要求：一个是有序性，一个是不重复。\n普通分页 数据分页在网页中十分多见，分页一般都是limit start,offset,然后根据页码page计算start。即，limit后面的第一个参数表示下标，也就是从第10000行记录开始取，第二个参数表示总共取10行记录。\n1  select*fromuserlimit1,20  这种分页在几十万的时候分页效率就会比较低了，MySQL需要从头开始一直往后计算，这样大大影响效率。\n1 2 3  SELECT*fromuserlimit100001,20;-- time 0.151s explainSELECT*fromuserlimit100001,20;  我们可以用explain分析下语句，没有用到任何索引，MySQL执行的行数是16W+。\n优化分页 使用主键索引来优化数据分页\n1  select*fromuserwhereid\u0026gt;(selectidfromuserwhereid\u0026gt;=100000limit1)limit20;-- time 0.003s   比如我们要取的是从第10000行开始的10行记录，那么我们可以先把大于或等于10000行的数据查出来并排序，然后再取出前10行记录，这样也可以完成分页。使用这种方式，当在相邻的两页查询之间插入数据时，分页查询结果不会出现重复。\n1  explainselect*fromuserwhereid\u0026gt;(selectidfromuserwhereid\u0026gt;=100000limit1)limit20;  在数据量比较大的时候，我们尽量去利用索引来优化语句。上面的优化方法如果id不是主键索引，查询效率比第一种还要低点。我们可以先使用explain来分析语句，查看语句的执行顺序和执行性能。\n假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询：\n1  select*fromorderswheretype=2andidbetween1000000and1000100limit100;  一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。如果像是订单库等数据量非常庞大，一般会进行分库分表。先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。\n分页方案比较 MySQL分页的2种常见的方案：\n第一种是基于limit的分页方案，如：\n1  SELECT*FROM`user`ORDERBYidASCLIMIT100,10;  第二种是基于where的分页方案，如：\n1  SELECT*FROM`user`WHEREid\u0026gt;100ORDERBYidASCLIMIT10;  如果表记录数比较多，不建议使用基于limit的分页方案，而要使用基于where的分页方案。\n使用后一种方案，当在相邻的两页查询之间插入数据时，分页查询结果不会出现重复。因为虽然插入记录后，分页的结构变了，但是由于我们现在的分页查询是从固定的id开始查的，所以插入新的数据对后面的分页结果没有影响。当然，这种分页查询也是有限制的，只适用于用来排序的列具有唯一性的情况。\n 同时，我们还要确保MySQL没有开启查询缓存，否则对于同一个SQL的多次查询有可能会命中缓存，这样一来实验就没有意义了。要确认MySQL有没有开启查询缓存，只需要查询下query_cache_type参数就行了。\n 分页offset过大带来的问题 1  SELECTbFROMtWHEREc\u0026lt;1000LIMIT2000000,500  可以看到这个一个分页查询，从位置2000000处开始，取500条数据。mysql分页查询会并不是直接跳过前2000000再取出500条数据，而是把前2000000条和后面的500条都取出来，再把前2000000条抛弃，这样的话，上面的慢查询相当于从表中取2000500条数据，这么大的数据量必然会慢。\n解决方案：\n1  SELECTbFROM(SELECTaFROMtWHEREc\u0026lt;1000LIMIT2000000,500)taINNERJOINttbONta.a=tb.a  这种方式先用一个子查询表的主键（还是和原来一样带有过大分页），结果做为一个临时表，再和原来的t表JOIN，查出需要的字段。\n分表分库 分表就是将一张大表数据通过某种路由算法将数据尽可能的均匀分配到 N 张小表中。\n首先讨论下什么样的情况下适合分表？根据大佬的经验，当某张表的数据量已经达到千万甚至上亿，同时日增数据量在 2% 以上。当然这些数字并不是绝对的，最重要的还是对这张表的写入和查询都已经影响到正常业务执行，比如查询速度明显下降，数据库整体 IO 居高不下等。\n范围 首先第一种是按照范围划分，比如我们可以将某张表的创建时间按照日期划分存为月表；也可以将某张表的主键按照范围划分，比如 【1~10000】在一张表，【10001~20000】在一张表，以此类推。\n这样的分表适合需要对数据做归档处理，比如系统默认只提供近三个月历史数据的查询功能，这样也方便操作；只需要把三月之前的数据单独移走备份保存即可）。\nHash 按照日期这样的范围分表固然简单，但适用范围还是比较窄；毕竟我们大部分的数据查询都不想带上时间。比如某个用户想查询他产生的所有订单信息，这是很常见的需求。于是我们分表的维度就得改改，分表算法可以采用主流的 hash+mod 的组合。\n分表规则确定后，更麻烦的是，如何做到对业务影响最小的数据迁移。同时分表之后还需要兼容其他业务；比如原有的报表业务、分页查询等。分表完成后可以解决单表的压力，但数据库本身的压力却没有下降。将这类数据量巨大但对业务不太影响的表单独迁到一个库后，数据库的整体 IO 下降明显，业务也恢复正常。\n参考文章 「前端进阶」高性能渲染十万条数据(时间分片) （强烈推荐）\n前端如何处理十万级别的大量数据（web worker）\n一次难得的分库分表实践\n如何优雅地实现分页查询\nMySQL分页offset过大性能问题与优化\nMySQL快速插入大量数据\n","date":"2020-04-24T13:34:43Z","image":"https://neptoo.github.io/2020/%E4%BB%8E-mysql-%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%B0%88%E8%B5%B7/326502_hu3d03a01dcc18bc5be0e67db3d8d209a6_169681_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2020/%E4%BB%8E-mysql-%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%B0%88%E8%B5%B7/","title":"从 MySQL 处理大量数据谈起"},{"content":"上一篇文章中，我们只存储了查询数据的过程，也可以用存储过程来插入、删除、更新数据。\n参数验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  CREATEPROCEDUREmake_payment(invoice_idINT,payment_amountDECIMAL(9,2),-- decimal带小数点的数，参数1表示总的数字位数，参数2表示保留小数位 payment_dateDATE)BEGINIFpayment_amount\u0026lt;=0THENSIGNALSQLSTATE\u0026#39;22003\u0026#39;SETMESSAGE_TEXT=\u0026#39;Invalid payment amount.\u0026#39;;ENDIF;UPDATEinvoicesiSETi.payment_total=payment_amount,i.payment_date=payment_dateWHEREi.invoice_id=invoice_id;END  1  CALLPROCEDUREmake_payment(2,-100,\u0026#39;2019-01-01\u0026#39;)   22003是一个标准代码，代表一个数值类型数据超出了范围。👉ibm-sqlstate\n 当我们调用过程，传入非法的值，会在输出面板看到异常信息。最好在用户输入的时候提示错误，数据库数据验证是最后一道防线，为防止有人绕过了应用程序直接调用存储过程。\n输出参数 上面的实践是通过参数向过程提供参数，那么我们如何让在过程外部获得数据（指定参数）？\n1 2 3 4 5 6 7 8 9 10 11 12  CREATEPROCEDUREget_invoices_for_client(client_idINT,-- 默认是输入参数 OUTinvoice_countINT,OUTinvoices_totalDECIMAL(9,2)-- 总位数最多为9，保留两位小数 )BEGINSELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoicesiWHEREi.client_id=client_idANDpayment_total=0;END   使用输出参数读取数据有点复杂，不推荐使用。\n 变量 如上图，存储过程有输出变量的时候，通常是这样定义变量：\n1  SET@invoices_total=0  这些变量在整个客户端的生命周期中都会存在于内存中，当客户端中止与数据库的连接，变量会释放，称为用户变量（user or session variables）。\n还有一种变量称为本地变量(local variables)，通常在存储过程或者函数中定义，只要存储过程运行结束，变量就会被释放了。\n1 2 3 4 5 6 7 8 9 10 11 12 13  CREATEPROCEDUREget_risk_factorBEGINDECLARErisk_factorDECIMAL(9,2)DEFAULT0;DECLAREinvoices_countINT;DECLAREinvoices_totalDECIMAL(9,2);SELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoices;SETrisk_factor=invoices_total/invoices_count*5;SELECTrisk_factor;END   这些变量一旦声明就可以使用，一旦执行结束就会被清除。\n 函数 函数不同于存储过程的是，函数不能返回带行列的结果集，而是返回单一值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  CREATEFUNCTIONget_risk_for_client(client_idINT)RETURNINTEGERREADSQLDATA-- 从数据库读取数据; MODIFES SQL DATA修改数据 BEGINDECLARErisk_factorDECIMAL(9,2)DEFAULT0;DECLAREinvoices_countINT;DECLAREinvoices_totalDECIMAL(9,2);SELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoicesiWHEREi.client_id=client_id;SETrisk_factor=invoices_total/invoices_count*5;RETURNIFNULL(risk_factor,0);END  调用\n1  SELECTclient_id,name,get_risk_for_client(client_id)ASrisk_factorFROMclient;  删除\n1  DROPFUNCTIONIFEXISTSget_risk_for_client;  ","date":"2020-04-15T11:25:18Z","permalink":"https://neptoo.github.io/2020/mysql-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8B/","title":"MySQL 实践之存储过程（下）"},{"content":"如果你创建了一个有数据库的程序，为了方便代码管理，你最好将SQL代码放到数据库中，即存储过程或函数中。\n存储过程，就是在数据库中保存代码块的对象。然后在程序中，通过调用这些过程来获得或存入数据。\n创建 在 MySQL 中创建存储过程：\n1 2 3 4 5 6 7  DELIMITER$$CREATEPROCEDUREget_clients()BEGINSELECT*FROMclients;-- 函数体 END$$DELIMITER;  在 SQL 代码中调用存储过程：\n1  CALLget_clients()  获取发票应收款：\n1 2 3 4 5 6 7 8 9  -- 返回应收款\u0026gt;0的发票数据 DELIMITER$$CREATEPROCEDUREget_invoices_with_balance()BEGINSELECT*FROMinvoicesWHEREinvoice-payment\u0026gt;0;END$$DELIMITER;   在存储过程中，每个语句都需要用分号结尾，我们修改默认的分隔符（delimiter）之后，就可以在过程中用分号结尾。\n对于修改默认的分隔符，每个团队有不同的习惯，有的喜欢DELIMETER $$，有的喜欢DELIMETER //，以公司规范为准。\n 删除存储过程：\n1  DROPPROCEDUREIFEXISTSget_clients  传参 在存储过程中添加参数：\n1 2 3 4 5 6 7 8  -- 通过city获取用户 DELIMITER$$CREATEPROCEDUREget_clients_by_city(countryCHAR(2),cityCHAR(2))BEGINSELECT*FROMclientscWHEREc.city=cityandc.country=country;-- 给表名一个别名，区分表格中与传入的 END$$DELIMITER;  1  CALLPROCEDUREget_clients_by_city(\u0026#39;US\u0026#39;,\u0026#39;LA\u0026#39;)   char 字符串；varchar 可变长度的字符串，如姓名，电话等。\n 练习：通过客户 id 获取发票\n1 2 3 4 5 6 7 8  CREATEPROCEDUREget_invoices_by_client(client_idINT)BEGINSELECT*FROMinvoicesiWHEREi.client_id=client_id;END  默认值 1 2 3 4 5 6 7 8 9  CREATEPROCEDUREget_clients_by_city(countryCHAR(2))BEGINIFcountryISNULLTHENSETcountry=\u0026#39;CH\u0026#39;;ENDIF;SELECT*FROMclientscWHEREc.country=country;END  调用：\n1 2  CALLPROCEDUREget_clients_by_city(NULL)-- 如果括号里为空，会报错   如果不想传入指定值，而是进行其他操作。\n1 2 3 4 5 6 7 8 9  CREATEPROCEDUREget_clients_by_city(countryCHAR(2))BEGINIFcountryISNULLTHENSELECT*FROMclients;ELSESELECT*FROMclientscWHEREc.country=country;ENDIF;END  练习：Write a procedure called get_payments with two parameters.\n 如果只传入0个参数，返回全部消费记录；如果传入第一个参数，返回指定客户的消费记录；传入两个参数，返回指定客户在指定平台的消费记录。\n 1 2 3 4 5 6 7 8 9 10 11  CREATEPROCEDUREget_payments(client_idINT,payment_method_idTINYINT-- 0-255 )BEGINSELECT*FROMpaymentspWHEREp.client_id=IFNULL(client_id,p.client_id)ANDp.payment_method=IFNULL(payment_method,p.payment_method);END  1 2 3 4  CALLPROCEDUREget_payments(NULL,NULL)-- CALL PROCEDURE get_payments(5, NULL) -- CALL PROCEDURE get_payments(NULL, 2) -- CALL PROCEDURE get_payments(5, 2)   ","date":"2020-03-29T19:25:44Z","permalink":"https://neptoo.github.io/2020/mysql-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8A/","title":"MySQL 实践之存储过程（上）"},{"content":"毕业设计最终项目成果展示：点击查看\n基础配置 安装ECharts依赖 1  npm install echarts -S   全局引入  main.js  1 2 3  // 引入echarts import echarts from \u0026#39;echarts\u0026#39; Vue.prototype.$echarts = echarts   页面框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;8\u0026#34; :lg=\u0026#34;8\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;degreeChart\u0026gt;\u0026lt;/degreeChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;16\u0026#34; :lg=\u0026#34;16\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;moneyLine\u0026gt;\u0026lt;/moneyLine\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;12\u0026#34; :lg=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;cityChart\u0026gt;\u0026lt;/cityChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;12\u0026#34; :lg=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;funnelChart\u0026gt;\u0026lt;/funnelChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import degreeChart from \u0026#39;../charts/degreeChart.vue\u0026#39;; import moneyLine from \u0026#39;../charts/moneyLine.vue\u0026#39;; import cityChart from \u0026#39;../charts/cityChart.vue\u0026#39;; import funnelChart from \u0026#39;../charts/funnelChart.vue\u0026#39;; export default { components:{ degreeChart,moneyLine,cityChart,funnelChart }, methods: { } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt;   在index.js中引入文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import AmCharts from \u0026#39;@/components/page/BasicCharts\u0026#39;; Vue.use(Router) export default new Router({ mode: \u0026#39;history\u0026#39;, base: __dirname, routes: [ { path: \u0026#39;/\u0026#39;, component: Home, children: [{ path: \u0026#39;\u0026#39;, component: DashBoard }, { path: \u0026#39;/DashBoard\u0026#39;, component: DashBoard }, { path: \u0026#39;/BasicCharts\u0026#39;, component: AmCharts }, { path: \u0026#39;/TodoList\u0026#39;, component: TodoList }] } ] })   ECharts地图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;echarts\u0026#34;\u0026gt; \u0026lt;div :style=\u0026#34;{height:\u0026#39;400px\u0026#39;,width:\u0026#39;100%\u0026#39;}\u0026#34; ref=\u0026#34;myEchart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var echarts = require(\u0026#39;echarts/lib/echarts\u0026#39;) require(\u0026#39;echarts/map/js/china\u0026#39;) export default { name: \u0026#34;echarts\u0026#34;, props: [\u0026#34;userJson\u0026#34;], data() { return { chart: null }; }, mounted() { this.chinaConfigure(); }, beforeDestroy() { if (!this.chart) { return; } this.chart.dispose(); this.chart = null; }, methods: { chinaConfigure() { let myChart = echarts.init(this.$refs.myEchart); //这里是为了获得容器所在位置  window.onresize = myChart.resize; myChart.setOption({ // 进行相关配置  // backgroundColor: \u0026#34;#02AFDB\u0026#34;,  title: { text: \u0026#34;城市岗位分布\u0026#34;, x: \u0026#39;center\u0026#39;, textStyle: { color: \u0026#34;#777\u0026#34;, fontWeight:\u0026#39;500\u0026#39;, fontSize:16 } }, tooltip: {}, // 鼠标移到图里面的浮动提示框  dataRange: { show: false, min: 0, max: 1000, text: [\u0026#39;High\u0026#39;, \u0026#39;Low\u0026#39;], realtime: true, calculable: true, color: [\u0026#39;#FA8BFF\u0026#39;, \u0026#39;#2BFF88\u0026#39;, \u0026#39;#2BD2FF\u0026#39;] }, geo: { // 这个是重点配置区  map: \u0026#39;china\u0026#39;, // 表示中国地图  roam: false, // 是否允许缩放  label: { normal: { show: true, // 是否显示对应地名  textStyle: { color: \u0026#39;rgba(0,0,0,0.4)\u0026#39; } } }, itemStyle: { normal: { borderColor: \u0026#39;rgba(0, 0, 0, 0.2)\u0026#39;, areaColor: \u0026#39;#BBE4E9\u0026#39; }, emphasis: { areaColor: null, shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 20, borderWidth: 0, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } }, series: [{ type: \u0026#39;scatter\u0026#39;, coordinateSystem: \u0026#39;geo\u0026#39; // 对应上方配置  }, { name: \u0026#39;发布职位\u0026#39;, // 浮动框的标题  type: \u0026#39;map\u0026#39;, geoIndex: 0, data: [{ \u0026#34;name\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;value\u0026#34;: 232 }, { \u0026#34;name\u0026#34;: \u0026#34;广东\u0026#34;, \u0026#34;value\u0026#34;: 318 }, { \u0026#34;name\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;value\u0026#34;: 120 }, { \u0026#34;name\u0026#34;: \u0026#34;浙江\u0026#34;, \u0026#34;value\u0026#34;: 84 }, , { \u0026#34;name\u0026#34;: \u0026#34;四川\u0026#34;, \u0026#34;value\u0026#34;: 46 }, { \u0026#34;name\u0026#34;: \u0026#34;湖北\u0026#34;, \u0026#34;value\u0026#34;: 24 }, { \u0026#34;name\u0026#34;: \u0026#34;重庆\u0026#34;, \u0026#34;value\u0026#34;: 20 }, { \u0026#34;name\u0026#34;: \u0026#34;陕西\u0026#34;, \u0026#34;value\u0026#34;: 18 }, { \u0026#34;name\u0026#34;: \u0026#34;江苏\u0026#34;, \u0026#34;value\u0026#34;: 8 }, { \u0026#34;name\u0026#34;: \u0026#34;福建\u0026#34;, \u0026#34;value\u0026#34;: 20 }, { \u0026#34;name\u0026#34;: \u0026#34;辽宁\u0026#34;, \u0026#34;value\u0026#34;: 6 }, { \u0026#34;name\u0026#34;: \u0026#34;天津\u0026#34;, \u0026#34;value\u0026#34;: 4 }, { \u0026#34;name\u0026#34;: \u0026#34;云南\u0026#34;, \u0026#34;value\u0026#34;: 2 }, { \u0026#34;name\u0026#34;: \u0026#34;广西\u0026#34;, \u0026#34;value\u0026#34;: 2 }] } ] }) } } } \u0026lt;/script\u0026gt;   遇到的问题 横坐标轴文字过长不能完全显示\n 方法1：文字竖直显示  1 2 3 4 5 6 7 8 9 10 11 12 13 14  xAxis: [{ type: \u0026#39;category\u0026#39;, data: [\u0026#39;应届生\u0026#39;, \u0026#39;1年以内\u0026#39;, \u0026#39;1-3年\u0026#39;, \u0026#39;3-5年\u0026#39;, \u0026#39;5-10年\u0026#39;, \u0026#39;10年以上\u0026#39;, \u0026#39;不限\u0026#39;], axisTick: { alignWithLabel: true }, axisLabel: { interval: 0, rotate: -40 formatter: function(value) { //竖直显示  return value.split(\u0026#34;\u0026#34;).join(\u0026#34;\\n\u0026#34;); } } }]    方法2：项目类别间隔显示  1 2 3 4 5 6 7 8 9 10  axisLabel: { interval: 0, formatter: function(params, index) { //隔一行显示  if (index % 2 != 0) { return \u0026#39;\\n\\n\u0026#39; + params; } else { return params; } } }   ","date":"2019-06-30T12:09:22Z","image":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Bvue-elementui-echarts%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/grad_hue107c7b1a91e92072550f51cdf01b031_197868_120x120_fill_box_smart1_3.png","permalink":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Bvue-elementui-echarts%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","title":"毕业设计(下):Vue+ElementUI+ECharts实现前端数据可视化"},{"content":"毕业设计主题是数据可视化，选择的技术栈是Vue2.0，数据库选的是MySQL，首先需要解决的就是前端连接数据库的问题。 本文基于前端网站连接MySQL数据库和Node+Mysql+Vue实现登录注册功能，手把手教你使用前端连接数据库，实现增删改查。\n项目初始化  使用vue-cli搭建一个基于webpack的vue2.0项目，使用脚手架生成项目框架。 安装mysql数据库，附上mysql安装教程，然后安装navicat for mysql，推荐使用mysql的图形化界面管理数据库。  添加服务端目录 在项目根目录下新建server文件夹，目录结构如下\n1 2 3 4 5 6 7  |-- server |-- api // 与数据库的各个表连接接口 |-- userApi.js |-- hireApi.js |-- db.js // mysql数据库连接配置 |-- index.js // Express服务器入口文件 |-- sqlMap.js   db.js为mysql数据库基本配置信息，index.js用来定义与监听后端服务器，sqlMap.js是SQL语句映射文件，以供api逻辑调用。原代码基本上无需更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // sqlMap.js var sqlMap = { // 用户  user: { add: \u0026#39;insert into user(id, username, password) values (0, ?, ?)\u0026#39;, select_name: \u0026#39;SELECT * from user where username = ?\u0026#39;, //查询 username  select_password: \u0026#39;SELECT * from user where password = ?\u0026#39; //查询 password  }, // 招聘  hire: { add: \u0026#39;insert into hire(hire_id, title, money, degree, exp, site, time, addr) values (0, ?, ?, ?, ?, ?, ?, ?)\u0026#39;, getAll: \u0026#39;SELECT * from hire\u0026#39;, search: \u0026#39;select * from hire where title = ?\u0026#39;, update: \u0026#39;update hire set title = ? where hire_id = ?\u0026#39; } } module.exports = sqlMap;   代理与跨域 设置地址映射表，修改项目配置文件index.js中的proxyTable参数\n1 2 3 4 5 6 7 8 9 10 11 12 13  dev:{ // ...  proxyTable: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://127.0.0.1:3000/api/\u0026#39;, changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; } } }, // ... }   数据库表连接入口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  // hireUpi.js var models = require(\u0026#39;../db\u0026#39;); var express = require(\u0026#39;express\u0026#39;); var router = express.Router(); var mysql = require(\u0026#39;mysql\u0026#39;); var $sql = require(\u0026#39;../sqlMap\u0026#39;); // 连接数据库 var conn = mysql.createConnection(models.mysql); conn.connect(); var jsonWrite = function(res, ret) { if (typeof ret === \u0026#39;undefined\u0026#39;) { res.send(\u0026#39;err\u0026#39;) } else { //res.json(ret);  res.send(\u0026#39;ok\u0026#39;) } }; // 增加 router.post(\u0026#39;/addList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.add var params = req.body conn.query(sql, [params.title, params.money, params.degree, params.exp, params.site, params.time, params.addr], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) // 更新 router.post(\u0026#39;/updateList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.update var params = req.body conn.query(sql, [params.title, params.hire_id], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) //查找 router.get(\u0026#39;/searchList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.search var params = req.query console.log(params) conn.query(sql, [params.title], function (err, result) { if (err) { console.log(err) } if (result) { console.log(result) res.send(result) } }) }) // 获取所有list router.get(\u0026#39;/getAllList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.getAll var params = req.query conn.query(sql, function(err, result) { if (err) { console.log(err) } if (result) { console.log(result) res.send(result) } }) }) // 删除 router.post(\u0026#39;/delList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.del var params = req.body conn.query(sql, [params.hire_id], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) module.exports = router;   数据测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // editTable.vue \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;handleAdd\u0026#34;\u0026gt;新增\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;!--列表--\u0026gt; \u0026lt;el-table\u0026gt; \u0026lt;el-table-column type=\u0026#34;selection\u0026#34; width=\u0026#34;55\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;title\u0026#34; label=\u0026#34;岗位名称\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!--编辑界面--\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogFormVisible\u0026#34; @click=\u0026#34;dialogFormVisible=false\u0026#34;\u0026gt; \u0026lt;el-form label-width=\u0026#34;80px\u0026#34; :model=\u0026#34;editForm\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;岗位名称\u0026#34; prop=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;editForm.title\u0026#34; placeholder=\u0026#34;请输入岗位名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34; class=\u0026#34;dialog-footer\u0026#34;\u0026gt; \u0026lt;el-button @click.native=\u0026#34;dialogFormVisible=false\u0026#34;\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-if=\u0026#34;dialogStatus==\u0026#39;create\u0026#39;\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;addList\u0026#34;\u0026gt;添加\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else type=\u0026#34;primary\u0026#34; @click=\u0026#34;updateList\u0026#34;\u0026gt;修改\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/el-dialog\u0026gt; // ... \u0026lt;script\u0026gt; methods: { handleAdd: function() { this.dialogFormVisible = true; // 新增时清空  this.editForm = { title: \u0026#39;\u0026#39; } }, // 添加  addList() { var title = this.editForm.title axios.post(\u0026#39;/api/hire/addList\u0026#39;, { title: title }).then(function(response) { alert(\u0026#39;成功录入\u0026#39; + title + \u0026#39;\u0026#39;) this.dialogFormVisible = false }).catch(function(error) { console.log(error) }) }, // 更改  updateList() { var title = this.editForm.title var hire_id = this.editForm.hire_id axios.post(\u0026#39;/api/hire/updateList\u0026#39;, { title: title, hire_id: hire_id }).then(function(response) { alert(\u0026#39;成功更新\u0026#39; + title + \u0026#39;\u0026#39;) this.dialogFormVisible = false }).catch(function(error) { console.log(error) }) } } \u0026lt;/script\u0026gt;   启动 编写完成后，安装相应的依赖npm install express mysql body-parser 在系统中找到\u0026quot;服务\u0026quot;，将快捷方式发送到桌面。打开services.msc，找到mysql更改为手动启动，调试时候选择启动或停止服务。 开启mysql服务后，在server文件夹下执行node index，看到success listen at port:3000......即服务端启动成功。 在项目根目录下，npm run dev启动web服务器。\n其它 设计数据库表时候，录入字段为中文，出现乱码，解决方法：修改数据库和数据表的编码规则。\n1 2  show creat database test; ALTER DATABASE test DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;   1 2  ALTER TABLE test.hire CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; show create table test.hire;   删除数据清空自增ID\n1  truncate table test.company;   参考 [1]前端网站连接MySQL数据库\n[2]Node+Mysql+Vue实现登录注册功能\n[3]Vue+MySQL+Express小试牛刀\n[4]项目完整代码\n","date":"2019-06-24T16:46:45Z","permalink":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Avue-mysql%E5%89%8D%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"毕业设计(上):Vue+MySQL前端连接数据库实现表格增删改查"},{"content":"前端面试中算法题是比较难的一部分，今天总结下数据结构中的算法实现。\n排序 快速排序 找到一个数作为参考，比这个数字大放左边，比它小放右边，然后分别对左边和右边做相同操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function quickSort(arr) { if (arr.length \u0026lt;= 1) { return arr; // 递归出口  } var left = [], right = [], current = arr.splice(0, 1); for (let i = 0; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt; current) { left.push(arr[i]) } else { right.push(arr[i]) } } return quickSort(left).concat(current,quickSort(right)); // 递归 }   冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13  function bubbleSort(arr){ var len = arr.length; for(let outer = len;outer \u0026gt;= 2;outer--){ for(let inner = 0;inner \u0026lt;= outer-1;inner++){ if(arr[inner] \u0026gt; arr[inner+1]){ let temp = arr[inner]; arr[inner] = arr[inner+1]; arr[inner+1] = temp; } } } return arr; }    外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当\u0026gt;=2时即可停止； 内层是两两比较，从0开始，比较inner与inner+1，因此，临界条件是inner\u0026lt;outer -1  选择排序 1 2 3 4 5 6 7 8 9 10 11  function selectSort(arr){ var len = arr.length; for(let i=0;i \u0026lt; len-1; i++){ for(let j=i; j\u0026lt;len; j++){ if(arr[j] \u0026lt; arr[i]){ [arr[i],arr[j]]=[arr[j],arr[i]]; } } } return arr }   插入排序 1 2 3 4 5 6 7 8 9 10 11 12  function insertSort(arr){ for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i;j\u0026gt;0;j--){ if(arr[j]\u0026lt;arr[j-1]){ [arr[j],arr[j-1]]=[arr[j-1],arr[j]]; }else{ break; } } } return arr; }   栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Stack { constructor() { this.stack = [] } push(item) { this.stack.push(item) } pop() { this.stack.pop() } getLength() { return this.stack.length } isEmpty() { return this.getLength() === 0 } }   应用(匹配括号) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  var isMatch = function(arr){ let map = { \u0026#39;(\u0026#39;:-1, \u0026#39;)\u0026#39;:1, \u0026#39;[\u0026#39;:-2, \u0026#39;]\u0026#39;:2, \u0026#39;{\u0026#39;:-3, \u0026#39;}\u0026#39;:3 } let stack = [] for(let i = 0; i\u0026lt;arr.length; i++){ if(map[arr[i]] \u0026lt; 0){ stack.push(arr[i]) }else{ let last = stack.pop() if(map[last] + map[arr[i]] != 0) return false } } if(stack.length \u0026gt; 0) return false return true };   队列 简单单链队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Queue { constructor(){ this.queue = [] } enQueue(item){ this.queue.push(item) } deQueue(){ return this.queue.shift() } getHeader(){ return this.queue[0] } getLength(){ return this.queue.length } isEmpty(){ return this.getLength() === 0 } }   循环队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  class SqQueue{ constructor(length){ this.queue = new Array(length + 1) this.first = 0 this.last = 0 this.size = 0 } enQueue(item){ // 判断队尾+1是否为队头  // 是就代表需要扩容数组  // %this.queue.length 为了防止数组越界  if(this.first===(this.last + 1) % this.queue.length){ this.resize(this.getLength() * 2 + 1) } this.queue[this.last] = item this.size++ this.last = (this.last+1) % this.queue.length } deQueue(){ if(this.isEmpty()){ throw Error(\u0026#39;Queue is empty\u0026#39;) } let r = this.queue[this.first] this.queue[this.first] = null this.first = (this.first+1) % this.queue.length this.size-- // 判断当前队列大小是否过小  // 在队列空间等于总长度的1/4时缩小总长度为当前一半  if(this.size === this.getLength()/4 \u0026amp;\u0026amp; this.getLength() / 2 !== 0){ this.resize(this.getLength() / 2) } return r } getHeader() { if (this.isEmpty()) { throw Error(\u0026#39;Queue is empty\u0026#39;) } return this.queue[this.first] } getLength(){ return this.queue.length - 1 } isEmpty(){ return this.first ==== this.last } resize(length){ let q = new Array(length) for(let i = 0;i \u0026lt; length; i++){ q[i] = this.queue[(i + this.first) % this.queue.length] } this.queue = q this.first = 0 this.last = this.size } }   链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  class Node { constructor(v, next) { this.value = v this.next = next } } class LinkList { constructor() { // 链表长度  this.size = 0 // 虚拟头部  this.dummyNode = new Node(null, null) } find(header, index, currentIndex) { if (index === currentIndex) return header return this.find(header.next, index, currentIndex + 1) } addNode(v, index) { this.checkIndex(index) // 当往链表末尾插入时，prev.next 为空  // 其他情况时，因为要插入节点，所以插入的节点的 next 应该是prev.next  // 然后设置 prev.next 为插入的节点  let prev = this.find(this.dummyNode, index, 0) prev.next = new Node(v, prev.next) this.size++ return prev.next } insertNode(v, index) { return this.addNode(v, index) } addToFirst(v) { return this.addNode(v, 0) } addToLast(v) { return this.addNode(v, this.size) } removeNode(index, isLast) { this.checkIndex(index) index = isLast ? index - 1 : index let prev = this.find(this.dummyNode, index, 0) let node = prev.next prev.next = node.next node.next = null this.size-- return node } removeFirstNode() { return this.removeNode(0) } removeLastNode() { return this.removeNode(this.size, true) } checkIndex(index) { if (index \u0026lt; 0 || index \u0026gt; this.size) throw Error(\u0026#39;Index error\u0026#39;) } getNode(index) { this.checkIndex(index) if (this.isEmpty()) return return this.find(this.dummyNode, index, 0).next } isEmpty() { return this.size === 0 } getSize() { return this.size } }   二叉查找树BST 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Node{ constructor(value){ this.value = value this.left = null this.right = null } } class BST{ constructor(){ this.root = null this.size = 0 } getSize(){ return this.size } isEmpty(){ return this.size === 0 } addNode(v) { this.root = this._addChild(this.root, v) } // 添加节点时，需要比较添加的节点值和当前节点值的大小  _addChild(node, v) { if (!node) { this.size++ return new Node(v) } if (node.value \u0026gt; v) { node.left = this._addChild(node.left, v) } else if (node.value \u0026lt; v) { node.right = this._addChild(node.right, v) } return node } }   堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class MaxHeap{ constructor(){ this.heap=[] } size(){ return this.heap.length } empty(){ return this.size() == 0 } add(item){ this.heap.push(item) this._shiftUp(this.size()-1) } removeMax(){ this._shiftDown(0) } getParentIndex(k){ return parseInt((k - 1) / 2) } getLeftIndex(k){ return k * 2 + 1 } _shiftUp(k){ // 如果当前节点比父节点大，就交换  while(this.heap[k]\u0026gt;this.heap[this.getParentIndex(k)]){ this._swap(k,this.getParentIndex(k)) // 将索引变成父节点  k = this.getParentIndex(k) } } _swap(left, right) { let rightValue = this.heap[right] this.heap[right] = this.heap[left] this.heap[left] = rightValue } _shiftDown(k){ // 交换首位并删除末尾  this._swap(k, this.size() - 1) this.heap.splice(this.size() - 1, 1) // 判断节点是否有孩子，二叉堆有左必有右  while(this.getLeftIndex(k) \u0026lt; this.size()){ let j=this.getLeftIndex(k) // 判断是否有右孩子 并且右是否比左大  if(j+1 \u0026lt; this.size() \u0026amp;\u0026amp; this.heap[j+1] \u0026gt; this.heap[j]) j++ // 判断父节点是否比子节点都大  if(this.heap[k] \u0026gt;= this.heap[j]) break this._swap(k, j) k = j } } }   二叉树的先序/中序/后序遍历 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function TreeNode(val){ this.val = val; this.left = this.right = null; } var traversal = function(root){ if(root){ // 先序  console.log(root); traversal(root.left); // 中序 左之后输出  // console.log(root);  traversal(root.right); // 后序 左右根  // console.log(root);  } }   非递归实现 先序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function pre(root) { if (root) { let stack = []; stack.push(root); //先push根节点  while (stack.length \u0026gt; 0) { // 弹出栈顶元素  root = stack.pop(); console.log(root); // 栈是先进后出 先序遍历是先左后右  // 所以先push右边 再push左边  if(root.right){ stack.push(root.right); } if(root.left){ stack.push(root.left); } } } }   中序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function mid(root){ if(root){ let stack = []; // 中序遍历是左根右  // 先把左边节点遍历到底 依次push进栈  // 当左边没有节点时打印栈顶元素 然后寻找右节点  // 左边打印不出东西就打印父节点，然后看右节点  while(stack.length\u0026gt;0 || root){ if(root){ stack.push(root); root = root.left; }else{ root = stack.pop(); console.log(root); root = root.right; } } } }   后序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function pos(root){ if(root){ let stack1 = []; let stack2 = []; // 左右根 对于栈来说 先push根节点  // 然后push右节点 最后左节点  stack1.push(root); while(stack1.length \u0026gt; 0){ root = stack1.pop(); stack2.push(root); if(root.left){ stack1.push(root.left); } if(root.right){ stack1.push(root.right); } } while(stack2.length \u0026gt; 0){ console.log(s2.pop()); } } }   动态规划 解决斐波那契数列问题\n 斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层 通过数组来存储每一位所对应的斐波那契数列的值  1 2 3 4 5 6 7 8 9  function fib(n){ let array=new Array(n+1).fill(null) array[0] = 0 array[1] = 1 for(let i=2; i \u0026lt;= n; i++){ array[i] = array[i-1]+array[i-2] } return array[n] }   学习算法时，可视化界面可以帮助我们更好的理解，推荐配合VisualAlgo或Algorithm Visualizer。\n","date":"2019-02-15T18:24:10Z","image":"https://neptoo.github.io/2019/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/data-structure_hu639d2c065a0b82b0b98f6af0a78cd49d_33146_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2019/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","title":"前端数据结构的算法实现"},{"content":"最近在学习微信小程序的开发，涉及到移动端设备适配的知识点，想到之前秋招一位面试官问我的问题\u0026ndash;怎么判断用户是用什么设备访问的，是pc端还是移动端？ 我回答的是根据屏幕分辨率大小尺寸，他又表示电脑端也可以竖屏。。。然后我就不知道了，后来他也给我讲了应该怎么解决，现在时间有点久了答案已经忘了，于是决定搜集资料写篇博客记录这个问题。 网上给出的大多数方案，用js判断的原理是浏览器提交的user agent，不管是PC还是手机浏览器。\n第一种，使用indexOf判断\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;script\u0026gt; var userAgentInfo = navigator.userAgent; var mAgents = new Array(\u0026#34;Android\u0026#34;, \u0026#34;iPhone\u0026#34;, \u0026#34;SymbianOS\u0026#34;, \u0026#34;Windows Phone\u0026#34;, \u0026#34;iPad\u0026#34;, \u0026#34;iPod\u0026#34;); var pAgents = new Array(\u0026#34;Trident\u0026#34;, \u0026#34;Presto\u0026#34;, \u0026#34;Gecko\u0026#34;, \u0026#34;Webkit\u0026#34;); var flag = false; for (var v = 0; v \u0026lt; mAgents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u0026gt; 0) { flag = true; break; } } if (flag) { // 来自于移动端，同理判断PC浏览器 } \u0026lt;/script\u0026gt;   第二种，使用正则表达式判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;script\u0026gt; function browserRedirect() { var ua = navigator.userAgent.toLowerCase() || window.navigator.userAgent.toLowerCase(); var isWX = /MicroMessenger/i.test(ua), isIOS = /(iPhone|iPad|iPod|iOS)/i.test(ua), isAndroid = /(android|nexus)/i.test(ua), isBlackBerry = /BlackBerry/i.test(ua), isWindows = /(Window Phone|windows[\\s+]phone)/i.test(ua), isMidp = /midp/i.test(ua); document.writeln(\u0026#34;您的浏览设备为：\u0026#34;); if (isWX || isIOS || isAndroid || isBlackBerry || isWindows || isMidp) { document.writeln(\u0026#34;phone\u0026#34;); } else { document.writeln(\u0026#34;pc\u0026#34;); } } browserRedirect(); \u0026lt;/script\u0026gt;   除此之外，在移动端开发时有的项目还要考虑到兼容横竖屏。\n","date":"2019-01-16T17:32:44Z","permalink":"https://neptoo.github.io/2019/%E4%BB%8E%E4%B8%80%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7/","title":"从一道前端面试题说起"},{"content":"所谓模块化就是将需要用到的方法封装成为一个模块，哪里需要直接调用即可。\njs库+命名空间 网上常用的较为简单的一种方法是创建js库，要避免重复，封装自己的函数，要使用命名空间，对象就是天然的命名空间。\n(function(global){ var myfun1=function(){ console.log('myfun1'); }; var myfun2=function(){ console.log('myfun2'); }; //设置你的命名空间 var mypackageName=\u0026quot;com.mydomain.utils\u0026quot;; var packageArray=mypackageName.split(\u0026quot;.\u0026quot;); var finalObj=packageArray.reduce(function(prev,current){ return prev[current]||(prev[current]={}); }, global); //将你的函数绑定到命名空间上 finalObj.myfun1= myfun1; finalObj.myfun2= myfun2; }(window)); com.mydomain.utils.myfun1();//输出 myfun1 com.mydomain.utils.myfun2();//输出 myfun2  ES模块封装 现在模块化机制已经成熟，另一种是使用ES2015 module封装模块。 (1)首先学会怎么用 ES2015 来编写／封装模块（node／npm，加上 babel 的入门知识）； (2)学会发布到npm； (3)如何引入模块到应用体系中，如何加载/打包(gulp/webpack/jspm等)。 封装不只是要学习代码怎么写，更要知道如何维护和应用，否则封装就不具备普适性。\nJavaScript不是基于OO的语言，class不是必需的，还有其他模式，比如工厂函数（Factory Functions）要远比 class 简洁、灵活。\n简单工厂模式 它的作用是，利用面向对象的方法，把一些对象封装，使一些占用空间多的，重复的代码封装起来。 实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性以及方法再将对象返回即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function creatper(name,age){ var per=new Object(); //原料  //加工  per.name=name; per.age=age; per.sayHi=function(){ console.log(per.name+\u0026#39;\u0026#39;+per.age); } return per; //出厂  } var me=creatper(\u0026#39;katherine\u0026#39;,22); me.sayHi(); console.log(me.name);   可以看出使用工厂模式，可以重复调用这个per函数来生成不同属性值得对象，这就像工厂一样，批量生产，里面的原料，加工，出厂都很清晰。但是你会发现工厂模式是无法识别对象的类型，因为全都是object，不像Date，Array等，但是构造函数就不是了。这还只是简单的工厂模式，复杂的工厂模式（抽象模式）等以后再回来详细了解。\n","date":"2018-09-30T18:44:32Z","permalink":"https://neptoo.github.io/2018/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85js-%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85/","title":"如何封装JS-模块化与封装"}]