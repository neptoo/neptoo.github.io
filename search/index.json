[{"content":"focumon是什么 我是从三个月前开始使用的，非常适合自由安排自己时间的小伙伴。\n类似Habitica，专注应用。以游戏的方式让你更好地专注于某个任务，利用某一段时间去集中地做一些事，很适合写论文或者做habit tracking（习惯追踪）。\n吸引我玩下去的点就是：没有一般的效率工具那么枯燥，每天可以抽卡获取到新的focumon，很惊喜，期待抽到好看的皮肤或者宠物。\n之前使用过番茄钟、滴答清单和时间记录（toggl）的网页或者软件，都有各自的缺点，最终没有继续用下去。比如初始功能太复杂，一次性建立太多的任务清单，其实更不利于启动，会降低开始干活的欲望。\n每天早上我会在Obsidian列出当天的 to do list，然后打开 focumon，抽卡，选择一个focumon自习室开始专注，将focumon放在后台，开始专心做事，累了就查看下积累的休息时间，休息一下。\n我通常会定好当天的主要任务，有时候也会安排好具体在某个时间段计划做什么事情，但是也不需要完全精确地执行，有时候把任务推迟半小时，或者留到明天也是可以的。调整好状态再去做，可以更好地提高学习或者工作效率。\nfocumon tips 番茄钟的专注理念是专注25分钟休息5分钟，focumon是专注n分钟休息1/3*n的时间。\n休息时间和专注时间一样是可以收集到材料的，所以focumon是鼓励休息的。每次专注30分钟，你就为自己赢得了10分钟的休息时间。也有小伙伴是反着来，专注时间去休息，休息时间再干活，适合自己的就是最好的。\n首页Dashboard\u0026ndash;Focus，可以根据属性筛选房间，一开始我都是随便点进去一个好看的房间里训练，所有房间是根据属性值分类的，如果你的宠物是grass属性，你选择属性值相同的房间是会掉落升级材料的（grass++\u0026gt;grass+\u0026gt;grass）。\n顶部菜单点击Focumon，可以看到你所有的focumon，可以根据稀有度排序。选择任意一只focumon，在宠物图片下方可以选择 set as focus buddy，即选择你下次进入房间时默认的陪伴宠物。点击图片下方望远镜一样的图标（find evolutional material），可以根据这个宠物属性默认分配适合的训练房间。\n你会有自己的训练室，点击菜单\u0026ndash;My training center可以查看，每个训练室的有效时间是8小时，每天重新激活一下，会随机生成一个属性。你可以点击修改训练室的名字和介绍。如果你有超过6个focumon，可以在自己的训练室中按照自己喜欢的顺序放置focumon。在主页最底部你可以看到你选择的focumons和你的角色皮肤。\n你在进入房间的时候可以填写一句话，可以是你要专注的任务主题，比如code/reading/workout等，会在你进入房间后展示给别人。如果不填默认就是paw-sitively focused，是 positively focused的谐音，但是有宠物陪伴版。\n 我遇到过的印象深刻的标语：“这个loot怎么就不掉啊”“为旅行收拾行李”\n 进入专注房间后，你可以看到其他小人和它们的陪伴宠物，头上的标语是他们在做的事情，可以看到专注/休息状态，点击右边的cheer\u0026rsquo;em up!可以鼓励一下他们，或者给自己点个⭐鼓励自己，只有等你专注结束后可以在总结页面看到cheers数量，不会有消息打扰。\n在房间训练的时候，每个一段时间可能会掉落Loot，可以理解为升级材料，非pro用户每天可以收集的loot是有一定的限制的。\n进入房间后，点击take a break进入休息。点击左下方的小旗帜可以离开房间，结束你的本次训练，点击星星对此次训练进行评价总结或者打标签，都只会自己看到。\n点击右上角菜单栏\u0026ndash;Setting\u0026ndash;Info下的Statistics，可以看到自己的统计数据。\nfocumon目前唯一的社交功能就是可以加入群组（Party），可以一起打怪兽。\nEvents就是打怪兽，你可以加入一个Party，官方会定期推出特殊事件，你可以选择让你的队伍加入这个事件，选择你要出战的宠物，事件里有BOSS的数据，包含它的强项和弱点，尽量选择符合它的弱点属性的宠物，不要选boss擅长的属性。每一只focumon都有自己的等级，等级越高打出的伤害越大。打怪的方式就是在事件持续时间，多做专注训练，你用得越多，宠物升级越快，PWR伤害值就越大。这个事件机制有鼓励我更好地专注。\nBonus 如果你使用后感兴趣，可以在 这里 填我的邀请码@vickyoo，被邀请者可以获得6个💎，如果我能够攒够5个人就可以获得道具，升级我的focumon。\nLinks 如果你对focumon感兴趣，可以查看这些象友的博客：\n克服启动困难和拖延症的 N 种尝试\n工具｜一个 Focumon 小地图\n","date":"2024-09-02T17:06:00+08:00","image":"https://images.pexels.com/photos/355863/pexels-photo-355863.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=2","permalink":"https://neptoo.github.io/2024/focumon-%E4%B8%93%E6%B3%A8%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Focumon 专注应用使用指南"},{"content":"前言 最近在尝试使用React重构网站，尽量减少库的使用，只使用React和CSS手写一个简单实用的轮播图组件。\n先看效果预览：\n实现 Setup 1 2 3 4  npx create-react-app slider-app cd slider-app npm install react-icons npm start   CSS样式 设置容器和轮播图的样式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  .sectionCenter { margin: 0 auto; margin-top: 4rem; width: 80vw; /* have to have a height */ height: 450px; max-width: 800px; text-align: center; position: relative; display: flex; /* hiding overflow content */ overflow: hidden; } .article { position: absolute; top: 0; left: 0; width: 100%; height: 100%; /* Each slide, hidden by default */ opacity: 0; transition: var(--transition); } .article.activeSlide { opacity: 1; transform: translateX(0); } /* Styles for the previous slide, positioning it to the left */ .article.lastSlide { transform: translateX(-100%); } .article.nextSlide { /* Move slide out of view to the right */ transform: translateX(100%); }   Slider组件 初始化状态 1 2 3 4 5  import { useState, useEffect } from \u0026#34;react\u0026#34;; const Slider = ({ data }) =\u0026gt; { const [people, setPeople] = useState(data); const [index, setIndex] = useState(0);   处理索引边界值 1 2 3 4 5 6 7 8 9 10  // 确保轮播图继续循环 当超过边界时 useEffect(() =\u0026gt; { const lastIndex = people.length - 1; if (index \u0026lt; 0) { setIndex(lastIndex); } if (index \u0026gt; lastIndex) { setIndex(0); } }, [index, people]);   自动轮播效果 1 2 3 4 5 6  useEffect(() =\u0026gt; { let slider = setInterval(() =\u0026gt; { setIndex(index + 1); }, 3000); return () =\u0026gt; clearInterval(slider); // index改变时要清除定时器 }, [index]);   页面渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  return ( \u0026lt;div className={styles.main}\u0026gt; \u0026lt;section className={styles.section}\u0026gt; \u0026lt;div className={styles.sectionCenter}\u0026gt; {people.map((person, personIndex) =\u0026gt; { const { id, image, name, title, quote } = person; let position = \u0026#34;nextSlide\u0026#34;; // 默认所有轮播图叠加在右边  // 根据当前索引去定位左边和中间active的 轮播图  if (personIndex === index) { position = \u0026#34;activeSlide\u0026#34;; } if ( personIndex === index - 1 || (index === 0 \u0026amp;\u0026amp; personIndex === people.length - 1) ) { // 条件1：把一个slide挪到左边  // 条件2： index为0时 把数组最后一个挪到最左边  position = \u0026#34;lastSlide\u0026#34;; } return ( \u0026lt;article className={`${styles.article}${styles[position]}`} key={id} \u0026gt; \u0026lt;img src={image} alt={name} className={styles.personImg} /\u0026gt; \u0026lt;h4\u0026gt;{name}\u0026lt;/h4\u0026gt; \u0026lt;p className={styles.title}\u0026gt;{title}\u0026lt;/p\u0026gt; \u0026lt;p className={styles.text}\u0026gt;{quote}\u0026lt;/p\u0026gt; \u0026lt;FaQuoteRight className={styles.icon} /\u0026gt; \u0026lt;/article\u0026gt; ); })} \u0026lt;button className={styles.prev} onClick={() =\u0026gt; setIndex(index - 1)}\u0026gt; \u0026lt;FiChevronLeft /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button className={styles.next} onClick={() =\u0026gt; setIndex(index + 1)}\u0026gt; \u0026lt;FiChevronRight /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; );   整体代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  import React, { useState, useEffect } from \u0026#34;react\u0026#34;; import { FiChevronRight, FiChevronLeft } from \u0026#34;react-icons/fi\u0026#34;; import { FaQuoteRight } from \u0026#34;react-icons/fa\u0026#34;; import data from \u0026#34;./data\u0026#34;; import styles from \u0026#34;.index.module.css\u0026#34;; const Slider = () =\u0026gt; { const [people, setPeople] = useState(data); const [index, setIndex] = useState(0); useEffect(() =\u0026gt; { const lastIndex = people.length - 1; if (index \u0026lt; 0) { setIndex(lastIndex); } if (index \u0026gt; lastIndex) { setIndex(0); } }, [index, people]); useEffect(() =\u0026gt; { let slider = setInterval(() =\u0026gt; { setIndex(index + 1); }, 3000); return () =\u0026gt; clearInterval(slider); }, [index]); return ( \u0026lt;div className={styles.main}\u0026gt; \u0026lt;section className={styles.section}\u0026gt; \u0026lt;div className={styles.title}\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;span\u0026gt;/\u0026lt;/span\u0026gt;reviews \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={styles.sectionCenter}\u0026gt; {people.map((person, personIndex) =\u0026gt; { const { id, image, name, title, quote } = person; let position = \u0026#34;nextSlide\u0026#34;; if (personIndex === index) { position = \u0026#34;activeSlide\u0026#34;; } if ( personIndex === index - 1 || (index === 0 \u0026amp;\u0026amp; personIndex === people.length - 1) ) { // 条件1：把一个slide挪到左边  // 条件2： index为0时 把数组最后一个挪到最左边  position = \u0026#34;lastSlide\u0026#34;; } return ( \u0026lt;article className={`${styles.article}${styles[position]}`} key={id} \u0026gt; \u0026lt;img src={image} alt={name} className={styles.personImg} /\u0026gt; \u0026lt;h4\u0026gt;{name}\u0026lt;/h4\u0026gt; \u0026lt;p className={styles.title}\u0026gt;{title}\u0026lt;/p\u0026gt; \u0026lt;p className={styles.text}\u0026gt;{quote}\u0026lt;/p\u0026gt; \u0026lt;FaQuoteRight className={styles.icon} /\u0026gt; \u0026lt;/article\u0026gt; ); })} \u0026lt;button className={styles.prev} onClick={() =\u0026gt; setIndex(index - 1)}\u0026gt; \u0026lt;FiChevronLeft /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button className={styles.next} onClick={() =\u0026gt; setIndex(index + 1)}\u0026gt; \u0026lt;FiChevronRight /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Slider;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  /* section */ .section { width: 90vw; margin: 5rem auto; max-width: var(--max-width); } @media screen and (min-width: 992px) { .section { width: 95vw; } } .main { background: var(--clr-grey-10); } /* =============== Slider =============== */ .title { text-align: center; margin-bottom: 2rem; } .title h2 { display: flex; align-items: center; justify-content: center; font-weight: 500; } .title span { font-size: 0.85em; color: var(--clr-primary-5); margin-right: 1rem; font-weight: 700; } .sectionCenter { margin: 0 auto; margin-top: 4rem; width: 80vw; /* have to have a height */ height: 450px; max-width: 800px; text-align: center; position: relative; display: flex; /* hiding overflow content */ overflow: hidden; } .personImg { border-radius: 50%; margin-bottom: 1rem; width: 150px; height: 150px; object-fit: cover; border: 4px solid var(--clr-grey-8); box-shadow: var(--dark-shadow); } .article h4 { text-transform: uppercase; color: var(--clr-primary-5); margin-bottom: 0.25rem; } .title { text-transform: capitalize; margin-bottom: 0.75rem; color: var(--clr-grey-3); } .text { max-width: 35em; margin: 0 auto; margin-top: 2rem; line-height: 2; color: var(--clr-grey-5); } .icon { font-size: 3rem; margin-top: 1rem; color: var(--clr-primary-5); } .prev, .next { position: absolute; top: 200px; transform: translateY(-50%); background: var(--clr-grey-5); color: var(--clr-white); width: 1.25rem; height: 1.25rem; display: grid; place-items: center; border-color: transparent; font-size: 1rem; border-radius: var(--radius); cursor: pointer; transition: var(--transition); } .prev:hover, .next:hover { background: var(--clr-primary-5); } .prev { left: 0; } .next { right: 0; } @media (min-width: 800px) { .text { max-width: 45em; } .prev, .next { width: 2rem; height: 2rem; font-size: 1.5rem; } } .article { position: absolute; top: 0; left: 0; width: 100%; height: 100%; /* Each slide, hidden by default */ opacity: 0; transition: var(--transition); } .article.activeSlide { opacity: 1; transform: translateX(0); } /* Styles for the previous slide, positioning it to the left */ .article.lastSlide { transform: translateX(-100%); } .article.nextSlide { /* Move slide out of view to the right */ transform: translateX(100%); }   思路总结 实现思路是\n 设置一个sectionCenter，在窗口内展示当前的幻灯片，通过overflow:hidden隐藏超出窗口的部分 设置article样式，将每一张幻灯片都定位在页面中间并隐藏，这时所有的幻灯片是重叠在一起的 在JS中，初始化时将slider item堆积放在右边（类似后台） 根据当前索引和轮播图数组索引的关系，确定activeSlide, lastSlide该绑定到数组中哪个元素上  这个方法能够一次性加载所有图片文本内容，并通过CSS动画实现幻灯片移动，适合于展示用户推荐内容或者个人网站上的项目。优点在于幻灯片可实现无缝轮播，并且在有限的显示空间内展示多张图像。缺点是隐藏内容不利于SEO，无法被搜索引擎有效抓取。\n","date":"2024-07-29T15:02:10+08:00","image":"https://images.pexels.com/photos/221185/pexels-photo-221185.jpeg","permalink":"https://neptoo.github.io/2024/react%E5%92%8Ccss%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%BD%AE%E6%92%AD%E7%BB%84%E4%BB%B6/","title":"React和CSS实现自动轮播组件"},{"content":"前言 这些年一直在陆续使用这种记账软件或者app，因为隐私问题所以我不会采用绑定微信支付/支付宝支付/银行卡的方式去自动记账。手动记账可能因为支付平台过多，容易忘记。去年我坚持使用notion一年多的时间去记录流水账，但是每个月和到了年底总结的时候，我也只能知道自己的消费概况，实在没有什么有用的信息。\n信封预算法 然后今年在社交平台上了解到了信封预算法，所谓信封预算法就是每个月初/发工资那天根据银行卡余额去进行预算规划，按照不同类的开支，将钱存到「信封」里。\n比如将生活费分为以下几类，一类是房租水电会员费等硬性开支，一类是食品水果衣服百货兴趣爱好等灵活性支出，一类是预防家人生病住院等紧急支出，以及一笔定期存款。这样就不容易超支了。比如我每个月会分配一比较小数额的钱给外卖，如果这个月尽量多在家里做饭，剩下的这笔钱就可以留到娱乐类，存下来去购买喜欢的电子产品，来奖励自己。\n如果某一项不小心超支了的话，你就需要从另外一类里挪过去，削减它的额度。如果你不想挪用其它开支，后面你就会有意识地控制自己不去过多消费这类产品。这种记账方式就可以让你每个月做规划的时候，去调节自己的生活习惯，从预算去影响我们的消费行为。\n最有名的最流行的采用信封预算法的软件应该就是YNAB(you-need-a-budget)，但是订阅年费99刀。如果坐标在欧美地区，推荐使用YNAB，具体介绍参照这篇博主的文章 （强烈推荐）！对于吝啬的新手来说，我选择Actual Budget。\nActual Budget 安装 我是直接在本地运行的项目，首先你电脑上需要安装 Node.js 和 Git\n。如果电脑上没有安装 yarn， 输入以下命令进行安装：\n1  npm install --global yarn   然后打开你想要安装的目标文件下，打开 Git （右键\u0026ndash;\u0026gt;Git bash here），输入以下命令：\n1  git clone https://github.com/actualbudget/actual-server.git   当你将actual-server项目从 Github 上克隆下来，也就是上述命令执行完成后，打开你刚才下载下来的目录，或者直接在Git bash里输入cd actual-server，然后输入命令安装项目所需要的依赖包：\n1  yarn install    如果网不好的话可能有些依赖下载不下来，可以搜索下怎么配置yarn淘宝镜像，然后删除项目里的 node_modules 文件夹，重新下载依赖。\n 现在项目已经安装好了，可以使用以下命令将网页运行起来：\n1  yarn start   如果显示Listening on :::5006...就是启动成功了，然后在浏览器里输入网址http://localhost:5006/，就可以访问了。\nActual Budget 使用 访问项目后可以看到如图所示的网页，点击左边侧边栏Add account 添加账户，输入账号名和账户余额。首页就会显示你有多少钱需要进行分配，然后你可以将这笔钱分配到各自的类目中。 主页中第一列是 Category 分类。点击 Usual Expenses 旁边的下箭头，点击 Add category 添加分类。添加成功后选择 Food 右侧的下箭头可以删除该类别。第二列是 Budgeted，也就是你给每个类别分配的份额/钱数，第三列是 Spent，点击进入该类的详情页，然后你可以在详情页添加该类的每一笔开支。如果你分配完要用的钱之后，上方的 To Budget 数不为0，可以选择 hold for next month，将这笔钱留到下个月去分配。如果后面想把这笔钱挪到这个月，就选择Reset next month's buffer。\n等到第二个月计算预算的时候（假设此时还没有发工资），我会先拿上个月的各项余额移到 To Be Budgeted ，然后根据当前的银行卡余额进行预算规划。\n参考链接 记账软件YNAB：为什么它是最强的记账app\nActual Github\nActual Docs\n","date":"2024-03-09T15:16:37+08:00","image":"https://images.pexels.com/photos/7054399/pexels-photo-7054399.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=2","permalink":"https://neptoo.github.io/2024/actual-budget-%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%B0%81%E9%A2%84%E7%AE%97%E6%B3%95%E9%AB%98%E6%95%88%E7%AE%A1%E7%90%86%E8%B4%A2%E5%8A%A1/","title":"Actual Budget: 使用信封预算法高效管理财务"},{"content":"需求简介 用户首次登录\u0026ndash;\u0026gt;没有缓存，给一个游客token，访问首页部分信息 \u0026ndash;\u0026gt;点击进入登录页，输入手机号和验证码，将正式token存储到缓存中；关闭页面，重新进入，读取到缓存中的已登录的数据，正常进行页面请求和渲染。\n目录结构\n1 2 3 4 5 6 7 8 9 10 11 12  ├── 📂pages │ └── 📂tabbar │\t├── home.vue #首页 │ └── 📂login │\t├── login.vue #登录页 ├── 📂store #vuex相关 │ └── 📂modules #vuex模块 │\t├── user.js │\t├── index.js ├── App.vue ├── main.js ├── pages.json   Vuex状态管理 中大型项目中为了方便项目管理，尽量不直接在vuex中使用一个js进行状态管理，在这里我们使用模块化进行拆分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // index.js import Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;vuex\u0026#39; import user from \u0026#39;./modules/user\u0026#39; Vue.use(Vuex) const store = new Vuex.Store({ state: {}, mutations: {}, actions: {}, modules: { user } }) export default store   通过本地存储storage来持久化用户的登录状态和信息，并通过 Vuex 的状态管理功能来管理这些信息，即state定义状态、mutations里定义修改状态的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  //modules/user.js const user = { //\t使用命名空间  //\t它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名 \tnamespaced: true, state: { userInfo: {}, // hasLogin 标识用户是否正式登录 \thasLogin: uni.getStorageSync(\u0026#39;myToken\u0026#39;) \u0026amp;\u0026amp; uni.getStorageSync(\u0026#39;hasLogin\u0026#39;) == true ? true : false, visitorLogin: uni.getStorageSync(\u0026#39;hasLogin\u0026#39;) == true ? false : true, refreshToken:uni.getStorageSync(\u0026#39;refreshToken\u0026#39;) ? uni.getStorageSync(\u0026#39;refreshToken\u0026#39;) : \u0026#39;\u0026#39;, }, mutations: { login(state, provider) { //设置/改变登录状态 \tstate.hasLogin = true; state.visitorLogin = false; uni.setStorageSync(\u0026#39;hasLogin\u0026#39;, true); uni.setStorageSync(\u0026#39;myToken\u0026#39;, provider); }, visLogin(state, provider) { state.hasLogin = false; state.visitorLogin = true; uni.setStorageSync(\u0026#39;hasLogin\u0026#39;, false); uni.setStorageSync(\u0026#39;myToken\u0026#39;, provider); }, logout(state) { //退出登录 \tstate.hasLogin = false uni.clearStorage(); }, // 设置refreshToken  refreshLogin(state, provider) { uni.setStorageSync(\u0026#39;refreshToken\u0026#39;, provider); }, } } export default user   首页 vuex中定义好需要的变量之后，在首页读取缓存信息，判断用户登录状态。\n如果是未登录，后端绝大部分的接口都是需要带token的，所以新用户要访问首页信息，需要先赋给祂一个游客临时token。\n如果是已经登录，正常渲染页面，显示退出登录按钮。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;view v-if=\u0026#34;isvistor\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;jumpLogin\u0026#34;\u0026gt;游客状态，去登录\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view v-else\u0026gt; \u0026lt;text\u0026gt;已经登录\u0026lt;/text\u0026gt; \u0026lt;!-- 清除登录状态 --\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; @click=\u0026#34;clearLogin\u0026#34;\u0026gt;退出登录\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapMutations } from \u0026#39;vuex\u0026#39;; export default { computed: { hasLogin() { return this.$store.state.user.hasLogin }, visitorLogin() { return this.$store.state.user.visitorLogin }, }, data() { return { isvistor: false, } }, onLoad() { if (this.hasLogin \u0026amp;\u0026amp; !this.visitorLogin) { console.log(\u0026#39;用户正式登录，用正式token请求所有需要的信息\u0026#39;) this.isvistor = false; } else { this.isvistor = true; // 获取游客的token  this.loginByVistor(); } // token过期处理  // 假设约定的规则时 token过期时间小于24小时就刷新token  if (this.isWithin24Hours(uni.getStorageSync(\u0026#39;expire\u0026#39;)) == true) { //使用setTimeOut模拟，在真实环境里这里应该是发送请求，从后端获取新的token  setTimeOut(()=\u0026gt;{ // console.log(\u0026#39;刷新token成功\u0026#39;)  let newToken = \u0026#39;asdfgjgduyfhsdfjhgf\u0026#39; let newRefreshToken = \u0026#39;qwrtyweftufrgbnh\u0026#39; uni.setStorageSync(\u0026#39;myToken\u0026#39;, newToken); this.refreshLogin(newRefreshToken) uni.setStorageSync(\u0026#39;expire\u0026#39;, res.data.expire); }, 1000) } // token过期处理 END  }, methods: { ...mapMutations(\u0026#39;user\u0026#39;, [\u0026#39;login\u0026#39;, \u0026#39;visLogin\u0026#39;, \u0026#39;logout\u0026#39;,\u0026#39;refreshLogin\u0026#39;]), loginByVistor() { //获取到游客身份的token  let obj = { username: \u0026#39;temp\u0026#39;, password: \u0026#39;111111\u0026#39;, } let token = uni.getStorageSync(\u0026#39;myToken\u0026#39;) // 获取临时token  uni.request({ url: `${serverUrl}/temp`, data: obj, method: \u0026#34;POST\u0026#34;, header: { \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: `Bearer ${token}` }, success: (res) =\u0026gt; { //登录成功后改变vuex的状态，并退出登录页面  if (res.code === 200) { this.visLogin(res.data.token); console.log(\u0026#39;游客身份，用临时token请求游客可以看到的信息\u0026#39;) } } }) }, jumpLogin() { uni.reLaunch({ url: \u0026#39;/pages/login/login\u0026#39; }) }, // 退出登录/清除缓存  clearLogin() { if (this.hasLogin) { this.logout() uni.reLaunch({ url: \u0026#39;/pages/login/login\u0026#39; }) } }, isWithin24Hours(expireTime) { const currentTime = new Date(); const difference = Math.abs(expireTime - currentTime); const hoursDifference = Math.floor(difference / (1000 * 60 * 60)); return hoursDifference \u0026lt;= 24; }, } } \u0026lt;/script\u0026gt;   登录页 登录页面输入用户名和密码后，发送请求获取到正式的token，存储到缓存中。然后跳转首页，在 home.vue 中根据hasLogin和visitorLogin，判断用户是临时游客还是正式登录，并进行对应页面内容的渲染。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;view class=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input placeholder=\u0026#34;请输入手机号\u0026#34; v-model=\u0026#34;phoneNumber\u0026#34; placeholder-style=\u0026#34;color: #9ca3af;\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;pwd\u0026#34;\u0026gt; \u0026lt;input placeholder=\u0026#34;请输入密码\u0026#34; v-model=\u0026#34;pwd\u0026#34; @confirm=\u0026#34;doLogin\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;btn\u0026#34; @click=\u0026#34;doLogin\u0026#34;\u0026gt;登录\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapState, mapMutations } from \u0026#39;vuex\u0026#39;; export default { computed: { hasLogin() { return this.$store.state.user.hasLogin }, }, data() { return { phoneNumber: \u0026#34;\u0026#34;, pwd: \u0026#39;\u0026#39;, } }, onLoad() { }, methods: { ...mapMutations(\u0026#39;user\u0026#39;, [\u0026#39;login\u0026#39;]), doLogin() { let obj = { phone: this.phoneNumber, pwd: this.pwd } // 获取正式token  uni.request({ url: `${serverUrl}/login`, data: obj, method: \u0026#34;POST\u0026#34;, header: { \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: `Bearer ${token}` }, success: (res) =\u0026gt; { // 设置token--用正式token替换掉临时token  this.login(res.data.token); // 设置 refreshToken 和过期时间 expire  this.refreshLogin(res.data.refreshToken); uni.setStorageSync(\u0026#39;expire\u0026#39;, res.data.expire); uni.switchTab({ url: \u0026#34;/pages/tabbar/home\u0026#34; }) } }) }, } } \u0026lt;/script\u0026gt;   ","date":"2023-06-09T15:36:36+08:00","image":"https://images.pexels.com/photos/58639/pexels-photo-58639.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=2","permalink":"https://neptoo.github.io/2023/%E4%BD%BF%E7%94%A8uniapp%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%B9%B6%E5%85%BC%E5%AE%B9%E6%B8%B8%E5%AE%A2%E6%A8%A1%E5%BC%8F/","title":"使用Uniapp实现用户登录并兼容游客模式"},{"content":" 三个月前的项目，一直想写一篇文章整理下，拖延了这么久，都忘得差不多了。其实最好是在知识还热乎的时候记下来，这篇文章最好的发表时间是三个月前╮(╯▽╰)╭\n 先放效果图：\n引入 Library 首先，引入需要的js库，可以从 three.js 官方github仓库中找到并下载，你可能会用到的：\n three.js OrbitControls.js GLTFLoader.js RGBELoader.js   前两个是必须用到的，最后一个是根据你使用的文件格式，选择不同的 loader 处理器。我还尝试过 STLLoader 和 FBXLoader 。\n 1 2 3 4 5 6  \u0026lt;!-- 包下载路径 --\u0026gt; \u0026lt;!-- https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/STLLoader.js --\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/three.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/GLTFLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/RGBELoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    引入 RGBELoader 是因为在后面用到了 HDR 贴图，简而言之，就是调整环境光，给模型上色。\n 在 html 文件中创建一个 div ，让我们的模型能够显示出来。\n1  \u0026lt;div id=\u0026#34;mymodel\u0026#34; style=\u0026#34;width:500px; height: 600px;margin:100px auto;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   加载模型 初始处理 首先，创建一个模型渲染方法，需要传入要绑定的页面元素的 ID，在方法里对模型进行处理。\n1 2 3 4 5 6 7 8  function glbViewer(id){ var elem = document.getElementById(elementID); var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); }   添加相机 camera，它决定了元素在页面中看起来的效果，就像一个投影相机，它接收4个参数，表示垂直视野角度，渲染窗口的长宽比，最近端的截面，最远端的截面。\n添加渲染器 renderer，设置 aplha 为 true，这样背景颜色透明，模型就可以浸染到页面背景中。设置渲染器画布的宽高和元素宽高一致，然后将它 append 到页面中。\n1 2 3 4 5 6 7 8 9  var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1; renderer.outputEncoding = THREE.sRGBEncoding; elem.appendChild(renderer.domElement);   outputEncoding 控制输出渲染编码，toneMapping 即使贴图不是 HDR，也可以塑造更真实的效果，toneMappingExposure 调整曝光度。\n添加页面自适应，窗口调整时重置画布的大小\n1 2 3 4 5  window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth/elem.clientHeight; camera.updateProjectionMatrix(); }, false);   然后，我们来定义 controls \u0026ndash;控制模型的变换缩放和旋转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; // 启用 damping 给控制器带来重量感 controls.dampingFactor = 0.1; //动态系数因子 越小越灵敏 controls.rotateSpeed = 0.05; controls.enableZoom = true; // 是否可以缩放 controls.autoRotate = true; // 是否自动旋转 controls.autoRotateSpeed = 5; // 自动旋转速度  controls.minDistance = 2; controls.maxDistance = 10; controls.target.set(0, 0.5, - 0.2); // 决定了初始化时 模型在页面视野中的角度  controls.update();   设置场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var scene = new THREE.Scene(); new THREE.RGBELoader() .load(\u0026#39;shanghai_riverside_4k.hdr\u0026#39;, function (texture) { // hdr 文件和 index.html 在同级  texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = new THREE.Color(0xffffff); scene.environment = texture; const loader = new THREE.GLTFLoader() .setPath(\u0026#39;assets/models/\u0026#39;); //根据你放的模型或者图片的位置决定是否要使用setPath  loader.load(\u0026#39;white.glb\u0026#39;, function (gltf) { camera.position.set(4, 0.3, -1.2); gltf.scene.position.y = -1.8; scene.add(gltf.scene); // 创建闭包 不断调用 animate 动画函数  // animate 函数通过调用 controls 的 update 函数来更新整个场景，然后让 three.js 去渲染  var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); });   你可以在 HDR 资源网站下载你需要的 hdr 文件\u0026ndash;可以理解为全景图。\n完工 调用上面的方法，将模型和我们前面定义的页面元素绑定起来。\n1 2 3 4 5  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { glbViewer(\u0026#34;mymodel\u0026#34;) } \u0026lt;/script\u0026gt;   总结 three.js 官网不仅仅有文档，也提供了各种文件格式各种效果渲染的实例，可以结合例子和 Github 中实例源码进行学习，手把手带你上手 three.js 。\n有一次建模的同事提供的是零件版 3D 模型，UI 同事是在专业的 3D 渲染和处理的软件( keyshot )中打开，所以导致我在浏览器中渲染出来的效果和他们看到的效果不一样，有时候问题可能是模型并不完整而不是代码问题。\ngltf 在线查看：https://gltf-viewer.donmccurdy.com/\n后续还有一些细节或者问题待优化，需要自己学习和研究一下 Blender ，自己建模和贴图。\n完整代码：(附赠一个 stl 渲染 demo)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;model\u0026#34; style=\u0026#34;width:500px; height: 600px;margin:100px auto;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 包下载路径 --\u0026gt; \u0026lt;!-- https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/STLLoader.js --\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/three.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/GLTFLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/RGBELoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/STLLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function glbViewer(elementID) { var elem = document.getElementById(elementID) var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1; renderer.outputEncoding = THREE.sRGBEncoding; elem.appendChild(renderer.domElement); window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth / elem.clientHeight; camera.updateProjectionMatrix(); }, false); var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.minDistance = 2; controls.maxDistance = 10; controls.target.set(0, 0.5, - 0.2); controls.autoRotate = false; //自动旋转  controls.autoRotateSpeed = 5; //旋转速度  controls.update(); var scene = new THREE.Scene(); new THREE.RGBELoader() // .setPath(\u0026#39;assets/3d/\u0026#39;)  .load(\u0026#39;shanghai_riverside_4k.hdr\u0026#39;, function (texture) { texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = new THREE.Color(0xffffff); scene.environment = texture; const loader = new THREE.GLTFLoader() .setPath(\u0026#39;assets/models/\u0026#39;); loader.load(\u0026#39;white.glb\u0026#39;, function (gltf) { camera.position.set(4, 0.3, -1.2); gltf.scene.position.y = -1.8; scene.add(gltf.scene); var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); }); } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { glbViewer(\u0026#34;model\u0026#34;) } \u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt; function STLViewer(model, elementID) { var elem = document.getElementById(elementID) var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); elem.appendChild(renderer.domElement); window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth / elem.clientHeight; camera.updateProjectionMatrix(); }, false); var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.rotateSpeed = 0.05; controls.dampingFactor = 0.1; controls.enableZoom = true; controls.autoRotate = true; //自动旋转 controls.autoRotateSpeed = .75; var scene = new THREE.Scene(); scene.add(new THREE.HemisphereLight(0xe74c3c, 1)); (new THREE.STLLoader()).load(model, function (geometry) { const material = new THREE.MeshPhysicalMaterial({ metalness: 0.25, roughness: 0.1, opacity: 1.0, transparent: true, transmission: 0.99, clearcoat: 1.0, clearcoatRoughness: 0.25 }) var mesh = new THREE.Mesh(geometry, material); scene.add(mesh); var middle = new THREE.Vector3(); geometry.computeBoundingBox(); geometry.boundingBox.getCenter(middle); mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation( -middle.x, -middle.y, -middle.z)); var largestDimension = Math.max(geometry.boundingBox.max.x, geometry.boundingBox.max.y, geometry.boundingBox.max.z) camera.position.y = -largestDimension * 1.6; var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { STLViewer(\u0026#34;exa.stl\u0026#34;, \u0026#34;model\u0026#34;) } \u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;/body\u0026gt;   参考资料 Three.js 官方文档\n如何在页面极速渲染3D模型-腾讯 ISUX 团队\nThree.js 真实渲染\n","date":"2023-05-03T15:41:16Z","image":"https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1","permalink":"https://neptoo.github.io/2023/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84three.js%E6%B8%B2%E6%9F%933d%E6%A8%A1%E5%9E%8B/","title":"从零开始的Three.js渲染3D模型"},{"content":"需求是商城内的购物车图标遮挡了商品，需要在当前可视区域自由拖动购物车组件，不影响用户点击商品。\n效果预览  录制的gif有一定的掉帧，实际上真机拖动的时候是流畅的。\n 解决思路 查阅文档，微信小程序提供了movable-area和movable-view标签。目前项目里的当前页面是比较简单的，所以可以用movable-area包裹整个可视页面，movable-view包裹你要移动的元素。关键在于项目中使用了自定义导航栏mp-navigation-bar，如何获取页面剩余的内容可用高度。\n代码实现 index.wxml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;mp-navigation-bar background=\u0026#34;#3883ff\u0026#34; title=\u0026#34;商城\u0026#34; back=\u0026#34;{{false}}\u0026#34;\u0026gt;\u0026lt;/mp-navigation-bar\u0026gt; \u0026lt;movable-area\u0026gt; \u0026lt;!-- 内容区域 --\u0026gt; \u0026lt;view style=\u0026#34;height: {{contentHeight}}px\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-box\u0026#34; wx:for=\u0026#34;{{goodsList}}\u0026#34; wx:key=\u0026#34;id\u0026#34; bindtap=\u0026#34;toDetailsTap\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;img-box\u0026#34;\u0026gt; \u0026lt;image src=\u0026#34;{{item.pic}}\u0026#34; class=\u0026#34;image\u0026#34; mode=\u0026#34;aspectFill\u0026#34; lazy-load=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;goods-title van-multi-ellipsis--l2\u0026#34;\u0026gt;{{item.name}}\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;price-parent\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-price\u0026#34;\u0026gt;¥ {{item.price}}\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 内容区域 end --\u0026gt; \u0026lt;!-- 需要拖动的组件 --\u0026gt; \u0026lt;movable-view x=\u0026#34;{{x}}\u0026#34; y=\u0026#34;{{y}}\u0026#34; direction=\u0026#34;all\u0026#34;\u0026gt; \u0026lt;!-- vant-weapp框架中的一个购物车组件，可以替换为其它元素/组件 start --\u0026gt; \u0026lt;van-goods-action-icon icon-class=\u0026#34;goods-icon\u0026#34; icon=\u0026#34;cart-o\u0026#34; text=\u0026#34;购物车\u0026#34; bind:click=\u0026#34;goShopCar\u0026#34; info=\u0026#34;{{ shopNum ? shopNum : \u0026#39;\u0026#39; }}\u0026#34; /\u0026gt; \u0026lt;!-- vant-weapp框架中的一个购物车组件，可以替换为其它元素/组件 end --\u0026gt; \u0026lt;/movable-view\u0026gt; \u0026lt;!-- 需要拖动的组件 end --\u0026gt; \u0026lt;/movable-area\u0026gt;   index.wxss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  movable-view { display: flex; align-items: center; justify-content: center; height: 100rpx; width: 100rpx; background-color: #fff; border-radius: 20rpx; box-shadow: 0rpx 20rpx 50rpx -12rpx rgba(0,0,0,0.25) ; } movable-area { height: 100%; width: 100%; }   index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  Page({ data: { // 设置拖动组件的初始位置  x:340, y: 0, goodsList: [ {id: 15, pic: \u0026#34;https://images.pexels.com/photos/2113994/pexels-photo-2113994.jpeg\u0026#34;, name: \u0026#34;手表\u0026#34;, price: 699}, {id: 17, pic: \u0026#34;https://images.pexels.com/photos/221185/pexels-photo-221185.jpeg\u0026#34;, name: \u0026#34;平板\u0026#34;, price: 1900}, {id: 20, pic: \u0026#34;https://images.pexels.com/photos/1203803/pexels-photo-1203803.jpeg\u0026#34;, name: \u0026#34;相机\u0026#34;, price: 8150}, {id: 21, pic: \u0026#34;https://images.pexels.com/photos/270640/pexels-photo-270640.jpeg\u0026#34;, name: \u0026#34;键盘\u0026#34;, price: 2168} ], }, onLoad(){ this.getCartHeight() }, getCartHeight(){ // 页面初始化时 设置购物车初始位置为 停留在页面高度的2/3的位置 也可以设置成其他值  const height = Math.floor((wx.getSystemInfoSync().windowHeight)*2/3); this.setData({ y: height }) // 获取 自定义导航栏 时 页面高度  let customWindowHeight = wx.getSystemInfoSync().windowHeight // console.log(\u0026#39;customWindowHeight\u0026#39;, customWindowHeight)  let navH = wx.getStorageSync(\u0026#39;navigationBarHeight\u0026#39;) + wx.getStorageSync(\u0026#39;statusBarHeight\u0026#39;) // console.log(\u0026#39;navH\u0026#39;, navH)  let contentHeight = customWindowHeight - navH*2 this.setData({ contentHeight }) }, })   app.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  App({ globalData: {}, onLaunch() { // 自定义导航  this.getNavHeight() }, getNavHeight(){ const { statusBarHeight, platform } = wx.getSystemInfoSync() const { top, height } = wx.getMenuButtonBoundingClientRect() // 状态栏高度 (包含wifi信号、电量、时间的那一行顶部状态栏)  wx.setStorageSync(\u0026#39;statusBarHeight\u0026#39;, statusBarHeight) // 整个导航栏高度 = 胶囊按钮高度 + 状态栏到胶囊按钮间距 * 2 // Android导航栏高度 = 32px + 8px * 2 = 48px // iOS导航栏高度 = 32px + 6px * 2 = 44px  // 判断胶囊按钮信息是否成功获取  if (top \u0026amp;\u0026amp; top !== 0 \u0026amp;\u0026amp; height \u0026amp;\u0026amp; height !== 0) { const navigationBarHeight = (top - statusBarHeight) * 2 + height // 导航栏高度  wx.setStorageSync(\u0026#39;navigationBarHeight\u0026#39;, navigationBarHeight) } else { wx.setStorageSync( \u0026#39;navigationBarHeight\u0026#39;, platform === \u0026#39;android\u0026#39; ? 48 : 40 ) } }, })   参考资料 moveable-area 微信小程序文档\n小程序自定义导航栏适配（完美版）\n","date":"2023-04-28T14:05:29Z","image":"https://images.unsplash.com/photo-1508921340878-ba53e1f016ec?ixlib=rb-4.0.3\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=1170\u0026q=80","permalink":"https://neptoo.github.io/2023/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%BB%91%E5%9D%97%E7%BB%84%E4%BB%B6/","title":"微信小程序实现全屏可拖动滑块组件"},{"content":"生命不息，折腾不止。继几次给同事安利成功后，我决定写一篇博客总结一下我经常使用的笔记软件。\nNotion 19年的时候开始了解到并使用notion，真正几乎每天使用是在去年。之前使用了一段时间的是语雀，我很喜欢日历视图。\n大概等语雀送的一年会员到期，因为语雀改版，页面不再简洁，我就不再使用它。语雀是阿里的技术文档社区，有一批优质程序员博主，这也是它的优势之一。对于我自己来说，作为一个笔记应用，是否订阅博主其实不是很重要，并且它后来推出的很多功能是为了商业化，作为用户使用体验是不大好的。\n在每天的工作中，使用日历视图管理待办事项是很方便的，有时候需要实现的需求，最后周报总结的时候有助于回顾。\nNotion可以用来记账。每次阻止我记账的原因，坚持不下来的原因就是时间久了我会忘记。介于工作的时候使用notion日历管理我的日程，几乎每天都会打开notion，所以很大程度缓解了记账的难度。去年坚持了一整年，年度总结可以导出notion数据到Excel，清晰明了的分析自己的经济状况。\n从最开始使用到高频使用，我之前也试用过，觉得notion使用教程太复杂，不适合我。但是对于功能复杂的软件，选择一个功能点去用就好，如果是适合你的，好用的，后续自然而然就用习惯了。并不需要觉得太有负担。\n我也尝试过notion的看板功能，可以用来记录读过的书或者简历投递记录。\n在看板里每一个项目可以展开一个新的页面，可以在页面里记录详情，你可以灵活创建新的属性。\nObisidian notion唯一的问题是使用的在线服务，如果有一天notion被墙或者官方不再支持查看之前的数据，这些都是很不便的，所以我选择了本地存储数据的文档管理软件\u0026ndash;Obisidian。\nObisidian有一个很好用的热门插件，叫 Daily notes。你可以选择一个文件夹，用来存储你每天的日记文档。可以设置模板，比如每天要做的事项，我自己倾向于使用空白模板。Obisidian可以看作一个markdown文件管理软件。平时工作中更细节的需求、问题记录、思路和代码等我会整理在这里。配合notion 日历视图里写的是任务摘要。\n我也会使用Obisidian管理leetcode刷题记录。本质上还是使用的markdown文档，md文档的树形结构是很方便很有条理性的，在obisidian中可以选择折叠/展开某个目录。复习题目的时候可以不看答案，只看题目或者重点。\nObisidian最大的特色应该就是双向链接，你可以使用图中的格式创建另一个文档的链接，鼠标hover移动上去并且按住ctrl键，可以预览链接文档的内容。\n","date":"2023-03-20T10:55:43Z","image":"https://images.pexels.com/photos/4160094/pexels-photo-4160094.jpeg","permalink":"https://neptoo.github.io/2023/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/","title":"生产力工具推荐"},{"content":"Prerequisite: You have installed Vue.js(^2.5.2) and ElementUI(^2.15.8) in your project.\nCreating our own custom components Get started with Basic HTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-upload :action=\u0026#34;ossUploadUrl\u0026#34; :data=\u0026#34;dataObj\u0026#34; list-type=\u0026#34;picture-card\u0026#34; :file-list=\u0026#34;fileList\u0026#34; :before-upload=\u0026#34;beforeUpload\u0026#34; :on-remove=\u0026#34;handleRemove\u0026#34; :on-success=\u0026#34;handleUploadSuccess\u0026#34; :on-preview=\u0026#34;handlePreview\u0026#34; :limit=\u0026#34;maxCount\u0026#34; accept=\u0026#34;.jpg, .jpeg, .png, .gif, .mp4\u0026#34; :on-exceed=\u0026#34;handleExceed\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-plus\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogVisible\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;100%\u0026#34; :src=\u0026#34;dialogImageUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   Defining data and props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;script\u0026gt; import { policy } from \u0026#39;@/api/oss\u0026#39; export default { name: \u0026#39;multiPicUpload\u0026#39;, props: { // images array from parent template  value: Array, maxCount: { type: Number, default: 5 } }, data() { return { dataObj: { policy: \u0026#39;\u0026#39;, signature: \u0026#39;\u0026#39;, key: \u0026#39;\u0026#39;, ossaccessKeyId: \u0026#39;\u0026#39;, dir: \u0026#39;\u0026#39;, host: \u0026#39;\u0026#39; }, dialogVisible: false, dialogImageUrl: null, ossUploadUrl: \u0026#39;https://xxxxx.aliyun.com\u0026#39;, //replace it with your back-end service  }; },   Compute the array of uploaded images 1 2 3 4 5 6 7 8 9 10 11 12  computed: { fileList() { let fileList = []; if (this.value === undefined) return; for (let i = 0; i \u0026lt; this.value.length; i++) { fileList.push({ url: this.value[i] }); } return fileList; } },   Required Methods in doc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  methods: { emitInput(fileList) { let arr = []; for (let i = 0; i \u0026lt; fileList.length; i++) { arr.push(fileList[i].url); } this.$emit(\u0026#39;input\u0026#39;, arr) }, handleRemove(file, fileList) { this.emitInput(fileList); }, handlePreview(file) { this.dialogImageUrl = file.url; this.dialogVisible = true; }, beforeUpload(file) { // Tell if the image is larger than 5M  const isLt5M = file.size / 1024 / 1024 \u0026lt; 5; // const fileType = file.name.substring(file.name.lastIndexOf(\u0026#39;.\u0026#39;)+1)  // Identify the type of the image  // const isJpg = file.type == \u0026#39;image/jpeg\u0026#39; || file.type == \u0026#39;image/jpg\u0026#39; || file.type == \u0026#39;image/png\u0026#39; || file.type == \u0026#39;image/gif\u0026#39;  // if(!isJpg){  // this.$message.error(\u0026#39;You can only upload these image file types: jpg, jpeg, png, gif！\u0026#39;)  // return false  // }  if (!isLt5M) { this.$message.error(\u0026#39;The size of the uploaded image cannot exceed 5MB!\u0026#39;); return false } let _self = this; return new Promise((resolve, reject) =\u0026gt; { // policy() is a GET request, not POST  policy().then(response =\u0026gt; { _self.dataObj.policy = response.data.policy; _self.dataObj.signature = response.data.signature; _self.dataObj.ossaccessKeyId = response.data.accessKeyId; _self.dataObj.key = response.data.dir + \u0026#39;/${filename}\u0026#39;; _self.dataObj.dir = response.data.dir; _self.dataObj.host = response.data.host; resolve(true) }).catch(err =\u0026gt; { console.log(err) reject(false) }) }) }, handleUploadSuccess(response, file, fileArr) { console.log(\u0026#39;Upload successful!\u0026#39;) let url = this.dataObj.host + \u0026#39;/\u0026#39; + this.dataObj.dir + \u0026#39;/\u0026#39; + fileArr.name; // Get the image url  this.fileList.push({ name: fileArr.name, url: url }); this.emitInput(this.fileList); }, handleExceed(file, fileList) { this.$message({ message: \u0026#39;Maximum of\u0026#39; + this.maxCount + \u0026#39;images can be uploaded\u0026#39;, type: \u0026#39;warning\u0026#39;, duration: 1000 }); }, } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;   how to use this component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-form-item label=\u0026#34;device photos\u0026#34;\u0026gt; \u0026lt;multipic-upload v-model=\u0026#34;selectDevicePicFiles\u0026#34;\u0026gt;\u0026lt;/multipic-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MultipicUpload from \u0026#34;@/components/Upload/multipicUpload\u0026#34;; export default { components: { MultipicUpload }, computed: { selectDevicePicFiles: { get: function () { return this.detailDevice.picUrl; }, set: function (newValue) { console.log(\u0026#34;get a newValue\u0026#34;, newValue); if (newValue == null || newValue.length === 0) { this.detailDevice.picUrl = []; } else { if (newValue.length \u0026gt; 0) { this.detailDevice.picUrl = newValue; } } }, }, }, }; \u0026lt;/script\u0026gt;   Others 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // some utils/methods in case you want to see it  // api/oss.js import request from \u0026#39;@/utils/request\u0026#39; export function policy() { return request({ url:\u0026#39;/zm-admin/aliyun/oss/policy\u0026#39;, method:\u0026#39;get\u0026#39;, }) } // utils/request.js import axios from \u0026#39;axios\u0026#39; import { Message, MessageBox } from \u0026#39;element-ui\u0026#39; import store from \u0026#39;../store\u0026#39; import { getToken } from \u0026#39;@/utils/auth\u0026#39; const service = axios.create({ baseURL: process.env.BASE_API, timeout: 15000 }) service.interceptors.request.use(config =\u0026gt; { if (store.getters.token) { config.headers[\u0026#39;Authorization\u0026#39;] = getToken() // token  } return config }, error =\u0026gt; { console.log(error) // for debug  Promise.reject(error) }) export default service // auth.js import Cookies from \u0026#39;js-cookie\u0026#39; const TokenKey = \u0026#39;xxxxxToken\u0026#39; export function getToken() { return Cookies.get(TokenKey) }   Reference ElementUI Docs\n","date":"2022-08-17T18:01:47Z","image":"https://images.pexels.com/photos/4201333/pexels-photo-4201333.jpeg","permalink":"https://neptoo.github.io/2022/encapsulation-of-el-upload-display-an-image-after-uploading/","title":"Encapsulation of el upload - display an image after uploading"},{"content":"当需要从数据库查询的表有上万条记录的时候，将会导致查询和插入耗时太长，特别是随着数据量的增加特别明显，这时需要对于数据库查询，有很多种方法和优化的点。\n 依然是面试官系列，如何在 MySQL 中处理十万条以上数据？本来打算作为数据库笔记的附加题，查资料后发现可以延伸到很多方面。\n 分页 如果使用的ORM框架是mybatis的话，有开源的分页插件可以使用，如：Mybatis-PageHelper。如果不使用分页插件，那么就需要手动分页了，由于不同的数据库实现分页的SQL语句并不一致，如Mysql使用的是limit关键字，而Oracle使用的是rownum。首先讲讲分页操作必须满足的几个要求：一个是有序性，一个是不重复。\n普通分页 数据分页在网页中十分多见，分页一般都是limit start,offset,然后根据页码page计算start。即，limit后面的第一个参数表示下标，也就是从第10000行记录开始取，第二个参数表示总共取10行记录。\n1  select*fromuserlimit1,20  这种分页在几十万的时候分页效率就会比较低了，MySQL需要从头开始一直往后计算，这样大大影响效率。\n1 2 3  SELECT*fromuserlimit100001,20;-- time 0.151s explainSELECT*fromuserlimit100001,20;  我们可以用explain分析下语句，没有用到任何索引，MySQL执行的行数是16W+。\n优化分页 使用主键索引来优化数据分页\n1  select*fromuserwhereid\u0026gt;(selectidfromuserwhereid\u0026gt;=100000limit1)limit20;-- time 0.003s   比如我们要取的是从第10000行开始的10行记录，那么我们可以先把大于或等于10000行的数据查出来并排序，然后再取出前10行记录，这样也可以完成分页。使用这种方式，当在相邻的两页查询之间插入数据时，分页查询结果不会出现重复。\n1  explainselect*fromuserwhereid\u0026gt;(selectidfromuserwhereid\u0026gt;=100000limit1)limit20;  在数据量比较大的时候，我们尽量去利用索引来优化语句。上面的优化方法如果id不是主键索引，查询效率比第一种还要低点。我们可以先使用explain来分析语句，查看语句的执行顺序和执行性能。\n假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询：\n1  select*fromorderswheretype=2andidbetween1000000and1000100limit100;  一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。如果像是订单库等数据量非常庞大，一般会进行分库分表。先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。\n分页方案比较 MySQL分页的2种常见的方案：\n第一种是基于limit的分页方案，如：\n1  SELECT*FROM`user`ORDERBYidASCLIMIT100,10;  第二种是基于where的分页方案，如：\n1  SELECT*FROM`user`WHEREid\u0026gt;100ORDERBYidASCLIMIT10;  如果表记录数比较多，不建议使用基于limit的分页方案，而要使用基于where的分页方案。\n使用后一种方案，当在相邻的两页查询之间插入数据时，分页查询结果不会出现重复。因为虽然插入记录后，分页的结构变了，但是由于我们现在的分页查询是从固定的id开始查的，所以插入新的数据对后面的分页结果没有影响。当然，这种分页查询也是有限制的，只适用于用来排序的列具有唯一性的情况。\n 同时，我们还要确保MySQL没有开启查询缓存，否则对于同一个SQL的多次查询有可能会命中缓存，这样一来实验就没有意义了。要确认MySQL有没有开启查询缓存，只需要查询下query_cache_type参数就行了。\n 分页offset过大带来的问题 1  SELECTbFROMtWHEREc\u0026lt;1000LIMIT2000000,500  可以看到这个一个分页查询，从位置2000000处开始，取500条数据。mysql分页查询会并不是直接跳过前2000000再取出500条数据，而是把前2000000条和后面的500条都取出来，再把前2000000条抛弃，这样的话，上面的慢查询相当于从表中取2000500条数据，这么大的数据量必然会慢。\n解决方案：\n1  SELECTbFROM(SELECTaFROMtWHEREc\u0026lt;1000LIMIT2000000,500)taINNERJOINttbONta.a=tb.a  这种方式先用一个子查询表的主键（还是和原来一样带有过大分页），结果做为一个临时表，再和原来的t表JOIN，查出需要的字段。\n分表分库 分表就是将一张大表数据通过某种路由算法将数据尽可能的均匀分配到 N 张小表中。\n首先讨论下什么样的情况下适合分表？根据大佬的经验，当某张表的数据量已经达到千万甚至上亿，同时日增数据量在 2% 以上。当然这些数字并不是绝对的，最重要的还是对这张表的写入和查询都已经影响到正常业务执行，比如查询速度明显下降，数据库整体 IO 居高不下等。\n范围 首先第一种是按照范围划分，比如我们可以将某张表的创建时间按照日期划分存为月表；也可以将某张表的主键按照范围划分，比如 【1~10000】在一张表，【10001~20000】在一张表，以此类推。\n这样的分表适合需要对数据做归档处理，比如系统默认只提供近三个月历史数据的查询功能，这样也方便操作；只需要把三月之前的数据单独移走备份保存即可）。\nHash 按照日期这样的范围分表固然简单，但适用范围还是比较窄；毕竟我们大部分的数据查询都不想带上时间。比如某个用户想查询他产生的所有订单信息，这是很常见的需求。于是我们分表的维度就得改改，分表算法可以采用主流的 hash+mod 的组合。\n分表规则确定后，更麻烦的是，如何做到对业务影响最小的数据迁移。同时分表之后还需要兼容其他业务；比如原有的报表业务、分页查询等。分表完成后可以解决单表的压力，但数据库本身的压力却没有下降。将这类数据量巨大但对业务不太影响的表单独迁到一个库后，数据库的整体 IO 下降明显，业务也恢复正常。\n参考文章 「前端进阶」高性能渲染十万条数据(时间分片) （强烈推荐）\n前端如何处理十万级别的大量数据（web worker）\n一次难得的分库分表实践\n如何优雅地实现分页查询\nMySQL分页offset过大性能问题与优化\nMySQL快速插入大量数据\n","date":"2020-04-24T13:34:43Z","image":"https://neptoo.github.io/2020/%E4%BB%8E-mysql-%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%B0%88%E8%B5%B7/326502_hu3d03a01dcc18bc5be0e67db3d8d209a6_169681_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2020/%E4%BB%8E-mysql-%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%B0%88%E8%B5%B7/","title":"从 MySQL 处理大量数据谈起"},{"content":"上一篇文章中，我们只存储了查询数据的过程，也可以用存储过程来插入、删除、更新数据。\n参数验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  CREATEPROCEDUREmake_payment(invoice_idINT,payment_amountDECIMAL(9,2),-- decimal带小数点的数，参数1表示总的数字位数，参数2表示保留小数位 payment_dateDATE)BEGINIFpayment_amount\u0026lt;=0THENSIGNALSQLSTATE\u0026#39;22003\u0026#39;SETMESSAGE_TEXT=\u0026#39;Invalid payment amount.\u0026#39;;ENDIF;UPDATEinvoicesiSETi.payment_total=payment_amount,i.payment_date=payment_dateWHEREi.invoice_id=invoice_id;END  1  CALLPROCEDUREmake_payment(2,-100,\u0026#39;2019-01-01\u0026#39;)   22003是一个标准代码，代表一个数值类型数据超出了范围。👉ibm-sqlstate\n 当我们调用过程，传入非法的值，会在输出面板看到异常信息。最好在用户输入的时候提示错误，数据库数据验证是最后一道防线，为防止有人绕过了应用程序直接调用存储过程。\n输出参数 上面的实践是通过参数向过程提供参数，那么我们如何让在过程外部获得数据（指定参数）？\n1 2 3 4 5 6 7 8 9 10 11 12  CREATEPROCEDUREget_invoices_for_client(client_idINT,-- 默认是输入参数 OUTinvoice_countINT,OUTinvoices_totalDECIMAL(9,2)-- 总位数最多为9，保留两位小数 )BEGINSELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoicesiWHEREi.client_id=client_idANDpayment_total=0;END   使用输出参数读取数据有点复杂，不推荐使用。\n 变量 如上图，存储过程有输出变量的时候，通常是这样定义变量：\n1  SET@invoices_total=0  这些变量在整个客户端的生命周期中都会存在于内存中，当客户端中止与数据库的连接，变量会释放，称为用户变量（user or session variables）。\n还有一种变量称为本地变量(local variables)，通常在存储过程或者函数中定义，只要存储过程运行结束，变量就会被释放了。\n1 2 3 4 5 6 7 8 9 10 11 12 13  CREATEPROCEDUREget_risk_factorBEGINDECLARErisk_factorDECIMAL(9,2)DEFAULT0;DECLAREinvoices_countINT;DECLAREinvoices_totalDECIMAL(9,2);SELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoices;SETrisk_factor=invoices_total/invoices_count*5;SELECTrisk_factor;END   这些变量一旦声明就可以使用，一旦执行结束就会被清除。\n 函数 函数不同于存储过程的是，函数不能返回带行列的结果集，而是返回单一值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  CREATEFUNCTIONget_risk_for_client(client_idINT)RETURNINTEGERREADSQLDATA-- 从数据库读取数据; MODIFES SQL DATA修改数据 BEGINDECLARErisk_factorDECIMAL(9,2)DEFAULT0;DECLAREinvoices_countINT;DECLAREinvoices_totalDECIMAL(9,2);SELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoicesiWHEREi.client_id=client_id;SETrisk_factor=invoices_total/invoices_count*5;RETURNIFNULL(risk_factor,0);END  调用\n1  SELECTclient_id,name,get_risk_for_client(client_id)ASrisk_factorFROMclient;  删除\n1  DROPFUNCTIONIFEXISTSget_risk_for_client;  ","date":"2020-04-15T11:25:18Z","permalink":"https://neptoo.github.io/2020/mysql-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8B/","title":"MySQL 实践之存储过程（下）"},{"content":"如果你创建了一个有数据库的程序，为了方便代码管理，你最好将SQL代码放到数据库中，即存储过程或函数中。\n存储过程，就是在数据库中保存代码块的对象。然后在程序中，通过调用这些过程来获得或存入数据。\n创建 在 MySQL 中创建存储过程：\n1 2 3 4 5 6 7  DELIMITER$$CREATEPROCEDUREget_clients()BEGINSELECT*FROMclients;-- 函数体 END$$DELIMITER;  在 SQL 代码中调用存储过程：\n1  CALLget_clients()  获取发票应收款：\n1 2 3 4 5 6 7 8 9  -- 返回应收款\u0026gt;0的发票数据 DELIMITER$$CREATEPROCEDUREget_invoices_with_balance()BEGINSELECT*FROMinvoicesWHEREinvoice-payment\u0026gt;0;END$$DELIMITER;   在存储过程中，每个语句都需要用分号结尾，我们修改默认的分隔符（delimiter）之后，就可以在过程中用分号结尾。\n对于修改默认的分隔符，每个团队有不同的习惯，有的喜欢DELIMETER $$，有的喜欢DELIMETER //，以公司规范为准。\n 删除存储过程：\n1  DROPPROCEDUREIFEXISTSget_clients  传参 在存储过程中添加参数：\n1 2 3 4 5 6 7 8  -- 通过city获取用户 DELIMITER$$CREATEPROCEDUREget_clients_by_city(countryCHAR(2),cityCHAR(2))BEGINSELECT*FROMclientscWHEREc.city=cityandc.country=country;-- 给表名一个别名，区分表格中与传入的 END$$DELIMITER;  1  CALLPROCEDUREget_clients_by_city(\u0026#39;US\u0026#39;,\u0026#39;LA\u0026#39;)   char 字符串；varchar 可变长度的字符串，如姓名，电话等。\n 练习：通过客户 id 获取发票\n1 2 3 4 5 6 7 8  CREATEPROCEDUREget_invoices_by_client(client_idINT)BEGINSELECT*FROMinvoicesiWHEREi.client_id=client_id;END  默认值 1 2 3 4 5 6 7 8 9  CREATEPROCEDUREget_clients_by_city(countryCHAR(2))BEGINIFcountryISNULLTHENSETcountry=\u0026#39;CH\u0026#39;;ENDIF;SELECT*FROMclientscWHEREc.country=country;END  调用：\n1 2  CALLPROCEDUREget_clients_by_city(NULL)-- 如果括号里为空，会报错   如果不想传入指定值，而是进行其他操作。\n1 2 3 4 5 6 7 8 9  CREATEPROCEDUREget_clients_by_city(countryCHAR(2))BEGINIFcountryISNULLTHENSELECT*FROMclients;ELSESELECT*FROMclientscWHEREc.country=country;ENDIF;END  练习：Write a procedure called get_payments with two parameters.\n 如果只传入0个参数，返回全部消费记录；如果传入第一个参数，返回指定客户的消费记录；传入两个参数，返回指定客户在指定平台的消费记录。\n 1 2 3 4 5 6 7 8 9 10 11  CREATEPROCEDUREget_payments(client_idINT,payment_method_idTINYINT-- 0-255 )BEGINSELECT*FROMpaymentspWHEREp.client_id=IFNULL(client_id,p.client_id)ANDp.payment_method=IFNULL(payment_method,p.payment_method);END  1 2 3 4  CALLPROCEDUREget_payments(NULL,NULL)-- CALL PROCEDURE get_payments(5, NULL) -- CALL PROCEDURE get_payments(NULL, 2) -- CALL PROCEDURE get_payments(5, 2)   ","date":"2020-03-29T19:25:44Z","permalink":"https://neptoo.github.io/2020/mysql-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8A/","title":"MySQL 实践之存储过程（上）"},{"content":"毕业设计最终项目成果展示：点击查看\n基础配置 安装ECharts依赖 1  npm install echarts -S   全局引入  main.js  1 2 3  // 引入echarts import echarts from \u0026#39;echarts\u0026#39; Vue.prototype.$echarts = echarts   页面框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;8\u0026#34; :lg=\u0026#34;8\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;degreeChart\u0026gt;\u0026lt;/degreeChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;16\u0026#34; :lg=\u0026#34;16\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;moneyLine\u0026gt;\u0026lt;/moneyLine\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;12\u0026#34; :lg=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;cityChart\u0026gt;\u0026lt;/cityChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;12\u0026#34; :lg=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;funnelChart\u0026gt;\u0026lt;/funnelChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import degreeChart from \u0026#39;../charts/degreeChart.vue\u0026#39;; import moneyLine from \u0026#39;../charts/moneyLine.vue\u0026#39;; import cityChart from \u0026#39;../charts/cityChart.vue\u0026#39;; import funnelChart from \u0026#39;../charts/funnelChart.vue\u0026#39;; export default { components:{ degreeChart,moneyLine,cityChart,funnelChart }, methods: { } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt;   在index.js中引入文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import AmCharts from \u0026#39;@/components/page/BasicCharts\u0026#39;; Vue.use(Router) export default new Router({ mode: \u0026#39;history\u0026#39;, base: __dirname, routes: [ { path: \u0026#39;/\u0026#39;, component: Home, children: [{ path: \u0026#39;\u0026#39;, component: DashBoard }, { path: \u0026#39;/DashBoard\u0026#39;, component: DashBoard }, { path: \u0026#39;/BasicCharts\u0026#39;, component: AmCharts }, { path: \u0026#39;/TodoList\u0026#39;, component: TodoList }] } ] })   ECharts地图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;echarts\u0026#34;\u0026gt; \u0026lt;div :style=\u0026#34;{height:\u0026#39;400px\u0026#39;,width:\u0026#39;100%\u0026#39;}\u0026#34; ref=\u0026#34;myEchart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var echarts = require(\u0026#39;echarts/lib/echarts\u0026#39;) require(\u0026#39;echarts/map/js/china\u0026#39;) export default { name: \u0026#34;echarts\u0026#34;, props: [\u0026#34;userJson\u0026#34;], data() { return { chart: null }; }, mounted() { this.chinaConfigure(); }, beforeDestroy() { if (!this.chart) { return; } this.chart.dispose(); this.chart = null; }, methods: { chinaConfigure() { let myChart = echarts.init(this.$refs.myEchart); //这里是为了获得容器所在位置  window.onresize = myChart.resize; myChart.setOption({ // 进行相关配置  // backgroundColor: \u0026#34;#02AFDB\u0026#34;,  title: { text: \u0026#34;城市岗位分布\u0026#34;, x: \u0026#39;center\u0026#39;, textStyle: { color: \u0026#34;#777\u0026#34;, fontWeight:\u0026#39;500\u0026#39;, fontSize:16 } }, tooltip: {}, // 鼠标移到图里面的浮动提示框  dataRange: { show: false, min: 0, max: 1000, text: [\u0026#39;High\u0026#39;, \u0026#39;Low\u0026#39;], realtime: true, calculable: true, color: [\u0026#39;#FA8BFF\u0026#39;, \u0026#39;#2BFF88\u0026#39;, \u0026#39;#2BD2FF\u0026#39;] }, geo: { // 这个是重点配置区  map: \u0026#39;china\u0026#39;, // 表示中国地图  roam: false, // 是否允许缩放  label: { normal: { show: true, // 是否显示对应地名  textStyle: { color: \u0026#39;rgba(0,0,0,0.4)\u0026#39; } } }, itemStyle: { normal: { borderColor: \u0026#39;rgba(0, 0, 0, 0.2)\u0026#39;, areaColor: \u0026#39;#BBE4E9\u0026#39; }, emphasis: { areaColor: null, shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 20, borderWidth: 0, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } }, series: [{ type: \u0026#39;scatter\u0026#39;, coordinateSystem: \u0026#39;geo\u0026#39; // 对应上方配置  }, { name: \u0026#39;发布职位\u0026#39;, // 浮动框的标题  type: \u0026#39;map\u0026#39;, geoIndex: 0, data: [{ \u0026#34;name\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;value\u0026#34;: 232 }, { \u0026#34;name\u0026#34;: \u0026#34;广东\u0026#34;, \u0026#34;value\u0026#34;: 318 }, { \u0026#34;name\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;value\u0026#34;: 120 }, { \u0026#34;name\u0026#34;: \u0026#34;浙江\u0026#34;, \u0026#34;value\u0026#34;: 84 }, , { \u0026#34;name\u0026#34;: \u0026#34;四川\u0026#34;, \u0026#34;value\u0026#34;: 46 }, { \u0026#34;name\u0026#34;: \u0026#34;湖北\u0026#34;, \u0026#34;value\u0026#34;: 24 }, { \u0026#34;name\u0026#34;: \u0026#34;重庆\u0026#34;, \u0026#34;value\u0026#34;: 20 }, { \u0026#34;name\u0026#34;: \u0026#34;陕西\u0026#34;, \u0026#34;value\u0026#34;: 18 }, { \u0026#34;name\u0026#34;: \u0026#34;江苏\u0026#34;, \u0026#34;value\u0026#34;: 8 }, { \u0026#34;name\u0026#34;: \u0026#34;福建\u0026#34;, \u0026#34;value\u0026#34;: 20 }, { \u0026#34;name\u0026#34;: \u0026#34;辽宁\u0026#34;, \u0026#34;value\u0026#34;: 6 }, { \u0026#34;name\u0026#34;: \u0026#34;天津\u0026#34;, \u0026#34;value\u0026#34;: 4 }, { \u0026#34;name\u0026#34;: \u0026#34;云南\u0026#34;, \u0026#34;value\u0026#34;: 2 }, { \u0026#34;name\u0026#34;: \u0026#34;广西\u0026#34;, \u0026#34;value\u0026#34;: 2 }] } ] }) } } } \u0026lt;/script\u0026gt;   遇到的问题 横坐标轴文字过长不能完全显示\n 方法1：文字竖直显示  1 2 3 4 5 6 7 8 9 10 11 12 13 14  xAxis: [{ type: \u0026#39;category\u0026#39;, data: [\u0026#39;应届生\u0026#39;, \u0026#39;1年以内\u0026#39;, \u0026#39;1-3年\u0026#39;, \u0026#39;3-5年\u0026#39;, \u0026#39;5-10年\u0026#39;, \u0026#39;10年以上\u0026#39;, \u0026#39;不限\u0026#39;], axisTick: { alignWithLabel: true }, axisLabel: { interval: 0, rotate: -40 formatter: function(value) { //竖直显示  return value.split(\u0026#34;\u0026#34;).join(\u0026#34;\\n\u0026#34;); } } }]    方法2：项目类别间隔显示  1 2 3 4 5 6 7 8 9 10  axisLabel: { interval: 0, formatter: function(params, index) { //隔一行显示  if (index % 2 != 0) { return \u0026#39;\\n\\n\u0026#39; + params; } else { return params; } } }   ","date":"2019-06-30T12:09:22Z","image":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Bvue-elementui-echarts%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/grad_hue107c7b1a91e92072550f51cdf01b031_197868_120x120_fill_box_smart1_3.png","permalink":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Bvue-elementui-echarts%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","title":"毕业设计(下):Vue+ElementUI+ECharts实现前端数据可视化"},{"content":"毕业设计主题是数据可视化，选择的技术栈是Vue2.0，数据库选的是MySQL，首先需要解决的就是前端连接数据库的问题。 本文基于前端网站连接MySQL数据库和Node+Mysql+Vue实现登录注册功能，手把手教你使用前端连接数据库，实现增删改查。\n项目初始化  使用vue-cli搭建一个基于webpack的vue2.0项目，使用脚手架生成项目框架。 安装mysql数据库，附上mysql安装教程，然后安装navicat for mysql，推荐使用mysql的图形化界面管理数据库。  添加服务端目录 在项目根目录下新建server文件夹，目录结构如下\n1 2 3 4 5 6 7  |-- server |-- api // 与数据库的各个表连接接口 |-- userApi.js |-- hireApi.js |-- db.js // mysql数据库连接配置 |-- index.js // Express服务器入口文件 |-- sqlMap.js   db.js为mysql数据库基本配置信息，index.js用来定义与监听后端服务器，sqlMap.js是SQL语句映射文件，以供api逻辑调用。原代码基本上无需更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // sqlMap.js var sqlMap = { // 用户  user: { add: \u0026#39;insert into user(id, username, password) values (0, ?, ?)\u0026#39;, select_name: \u0026#39;SELECT * from user where username = ?\u0026#39;, //查询 username  select_password: \u0026#39;SELECT * from user where password = ?\u0026#39; //查询 password  }, // 招聘  hire: { add: \u0026#39;insert into hire(hire_id, title, money, degree, exp, site, time, addr) values (0, ?, ?, ?, ?, ?, ?, ?)\u0026#39;, getAll: \u0026#39;SELECT * from hire\u0026#39;, search: \u0026#39;select * from hire where title = ?\u0026#39;, update: \u0026#39;update hire set title = ? where hire_id = ?\u0026#39; } } module.exports = sqlMap;   代理与跨域 设置地址映射表，修改项目配置文件index.js中的proxyTable参数\n1 2 3 4 5 6 7 8 9 10 11 12 13  dev:{ // ...  proxyTable: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://127.0.0.1:3000/api/\u0026#39;, changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; } } }, // ... }   数据库表连接入口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  // hireUpi.js var models = require(\u0026#39;../db\u0026#39;); var express = require(\u0026#39;express\u0026#39;); var router = express.Router(); var mysql = require(\u0026#39;mysql\u0026#39;); var $sql = require(\u0026#39;../sqlMap\u0026#39;); // 连接数据库 var conn = mysql.createConnection(models.mysql); conn.connect(); var jsonWrite = function(res, ret) { if (typeof ret === \u0026#39;undefined\u0026#39;) { res.send(\u0026#39;err\u0026#39;) } else { //res.json(ret);  res.send(\u0026#39;ok\u0026#39;) } }; // 增加 router.post(\u0026#39;/addList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.add var params = req.body conn.query(sql, [params.title, params.money, params.degree, params.exp, params.site, params.time, params.addr], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) // 更新 router.post(\u0026#39;/updateList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.update var params = req.body conn.query(sql, [params.title, params.hire_id], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) //查找 router.get(\u0026#39;/searchList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.search var params = req.query console.log(params) conn.query(sql, [params.title], function (err, result) { if (err) { console.log(err) } if (result) { console.log(result) res.send(result) } }) }) // 获取所有list router.get(\u0026#39;/getAllList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.getAll var params = req.query conn.query(sql, function(err, result) { if (err) { console.log(err) } if (result) { console.log(result) res.send(result) } }) }) // 删除 router.post(\u0026#39;/delList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.del var params = req.body conn.query(sql, [params.hire_id], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) module.exports = router;   数据测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // editTable.vue \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;handleAdd\u0026#34;\u0026gt;新增\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;!--列表--\u0026gt; \u0026lt;el-table\u0026gt; \u0026lt;el-table-column type=\u0026#34;selection\u0026#34; width=\u0026#34;55\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;title\u0026#34; label=\u0026#34;岗位名称\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!--编辑界面--\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogFormVisible\u0026#34; @click=\u0026#34;dialogFormVisible=false\u0026#34;\u0026gt; \u0026lt;el-form label-width=\u0026#34;80px\u0026#34; :model=\u0026#34;editForm\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;岗位名称\u0026#34; prop=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;editForm.title\u0026#34; placeholder=\u0026#34;请输入岗位名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34; class=\u0026#34;dialog-footer\u0026#34;\u0026gt; \u0026lt;el-button @click.native=\u0026#34;dialogFormVisible=false\u0026#34;\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-if=\u0026#34;dialogStatus==\u0026#39;create\u0026#39;\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;addList\u0026#34;\u0026gt;添加\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else type=\u0026#34;primary\u0026#34; @click=\u0026#34;updateList\u0026#34;\u0026gt;修改\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/el-dialog\u0026gt; // ... \u0026lt;script\u0026gt; methods: { handleAdd: function() { this.dialogFormVisible = true; // 新增时清空  this.editForm = { title: \u0026#39;\u0026#39; } }, // 添加  addList() { var title = this.editForm.title axios.post(\u0026#39;/api/hire/addList\u0026#39;, { title: title }).then(function(response) { alert(\u0026#39;成功录入\u0026#39; + title + \u0026#39;\u0026#39;) this.dialogFormVisible = false }).catch(function(error) { console.log(error) }) }, // 更改  updateList() { var title = this.editForm.title var hire_id = this.editForm.hire_id axios.post(\u0026#39;/api/hire/updateList\u0026#39;, { title: title, hire_id: hire_id }).then(function(response) { alert(\u0026#39;成功更新\u0026#39; + title + \u0026#39;\u0026#39;) this.dialogFormVisible = false }).catch(function(error) { console.log(error) }) } } \u0026lt;/script\u0026gt;   启动 编写完成后，安装相应的依赖npm install express mysql body-parser 在系统中找到\u0026quot;服务\u0026quot;，将快捷方式发送到桌面。打开services.msc，找到mysql更改为手动启动，调试时候选择启动或停止服务。 开启mysql服务后，在server文件夹下执行node index，看到success listen at port:3000......即服务端启动成功。 在项目根目录下，npm run dev启动web服务器。\n其它 设计数据库表时候，录入字段为中文，出现乱码，解决方法：修改数据库和数据表的编码规则。\n1 2  show creat database test; ALTER DATABASE test DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;   1 2  ALTER TABLE test.hire CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; show create table test.hire;   删除数据清空自增ID\n1  truncate table test.company;   参考 [1]前端网站连接MySQL数据库\n[2]Node+Mysql+Vue实现登录注册功能\n[3]Vue+MySQL+Express小试牛刀\n[4]项目完整代码\n","date":"2019-06-24T16:46:45Z","permalink":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Avue-mysql%E5%89%8D%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"毕业设计(上):Vue+MySQL前端连接数据库实现表格增删改查"},{"content":"前端面试中算法题是比较难的一部分，今天总结下数据结构中的算法实现。\n排序 快速排序 找到一个数作为参考，比这个数字大放左边，比它小放右边，然后分别对左边和右边做相同操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function quickSort(arr) { if (arr.length \u0026lt;= 1) { return arr; // 递归出口  } var left = [], right = [], current = arr.splice(0, 1); for (let i = 0; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt; current) { left.push(arr[i]) } else { right.push(arr[i]) } } return quickSort(left).concat(current,quickSort(right)); // 递归 }   冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13  function bubbleSort(arr){ var len = arr.length; for(let outer = len;outer \u0026gt;= 2;outer--){ for(let inner = 0;inner \u0026lt;= outer-1;inner++){ if(arr[inner] \u0026gt; arr[inner+1]){ let temp = arr[inner]; arr[inner] = arr[inner+1]; arr[inner+1] = temp; } } } return arr; }    外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当\u0026gt;=2时即可停止； 内层是两两比较，从0开始，比较inner与inner+1，因此，临界条件是inner\u0026lt;outer -1  选择排序 1 2 3 4 5 6 7 8 9 10 11  function selectSort(arr){ var len = arr.length; for(let i=0;i \u0026lt; len-1; i++){ for(let j=i; j\u0026lt;len; j++){ if(arr[j] \u0026lt; arr[i]){ [arr[i],arr[j]]=[arr[j],arr[i]]; } } } return arr }   插入排序 1 2 3 4 5 6 7 8 9 10 11 12  function insertSort(arr){ for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i;j\u0026gt;0;j--){ if(arr[j]\u0026lt;arr[j-1]){ [arr[j],arr[j-1]]=[arr[j-1],arr[j]]; }else{ break; } } } return arr; }   栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Stack { constructor() { this.stack = [] } push(item) { this.stack.push(item) } pop() { this.stack.pop() } getLength() { return this.stack.length } isEmpty() { return this.getLength() === 0 } }   应用(匹配括号) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  var isMatch = function(arr){ let map = { \u0026#39;(\u0026#39;:-1, \u0026#39;)\u0026#39;:1, \u0026#39;[\u0026#39;:-2, \u0026#39;]\u0026#39;:2, \u0026#39;{\u0026#39;:-3, \u0026#39;}\u0026#39;:3 } let stack = [] for(let i = 0; i\u0026lt;arr.length; i++){ if(map[arr[i]] \u0026lt; 0){ stack.push(arr[i]) }else{ let last = stack.pop() if(map[last] + map[arr[i]] != 0) return false } } if(stack.length \u0026gt; 0) return false return true };   队列 简单单链队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Queue { constructor(){ this.queue = [] } enQueue(item){ this.queue.push(item) } deQueue(){ return this.queue.shift() } getHeader(){ return this.queue[0] } getLength(){ return this.queue.length } isEmpty(){ return this.getLength() === 0 } }   循环队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  class SqQueue{ constructor(length){ this.queue = new Array(length + 1) this.first = 0 this.last = 0 this.size = 0 } enQueue(item){ // 判断队尾+1是否为队头  // 是就代表需要扩容数组  // %this.queue.length 为了防止数组越界  if(this.first===(this.last + 1) % this.queue.length){ this.resize(this.getLength() * 2 + 1) } this.queue[this.last] = item this.size++ this.last = (this.last+1) % this.queue.length } deQueue(){ if(this.isEmpty()){ throw Error(\u0026#39;Queue is empty\u0026#39;) } let r = this.queue[this.first] this.queue[this.first] = null this.first = (this.first+1) % this.queue.length this.size-- // 判断当前队列大小是否过小  // 在队列空间等于总长度的1/4时缩小总长度为当前一半  if(this.size === this.getLength()/4 \u0026amp;\u0026amp; this.getLength() / 2 !== 0){ this.resize(this.getLength() / 2) } return r } getHeader() { if (this.isEmpty()) { throw Error(\u0026#39;Queue is empty\u0026#39;) } return this.queue[this.first] } getLength(){ return this.queue.length - 1 } isEmpty(){ return this.first ==== this.last } resize(length){ let q = new Array(length) for(let i = 0;i \u0026lt; length; i++){ q[i] = this.queue[(i + this.first) % this.queue.length] } this.queue = q this.first = 0 this.last = this.size } }   链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  class Node { constructor(v, next) { this.value = v this.next = next } } class LinkList { constructor() { // 链表长度  this.size = 0 // 虚拟头部  this.dummyNode = new Node(null, null) } find(header, index, currentIndex) { if (index === currentIndex) return header return this.find(header.next, index, currentIndex + 1) } addNode(v, index) { this.checkIndex(index) // 当往链表末尾插入时，prev.next 为空  // 其他情况时，因为要插入节点，所以插入的节点的 next 应该是prev.next  // 然后设置 prev.next 为插入的节点  let prev = this.find(this.dummyNode, index, 0) prev.next = new Node(v, prev.next) this.size++ return prev.next } insertNode(v, index) { return this.addNode(v, index) } addToFirst(v) { return this.addNode(v, 0) } addToLast(v) { return this.addNode(v, this.size) } removeNode(index, isLast) { this.checkIndex(index) index = isLast ? index - 1 : index let prev = this.find(this.dummyNode, index, 0) let node = prev.next prev.next = node.next node.next = null this.size-- return node } removeFirstNode() { return this.removeNode(0) } removeLastNode() { return this.removeNode(this.size, true) } checkIndex(index) { if (index \u0026lt; 0 || index \u0026gt; this.size) throw Error(\u0026#39;Index error\u0026#39;) } getNode(index) { this.checkIndex(index) if (this.isEmpty()) return return this.find(this.dummyNode, index, 0).next } isEmpty() { return this.size === 0 } getSize() { return this.size } }   二叉查找树BST 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Node{ constructor(value){ this.value = value this.left = null this.right = null } } class BST{ constructor(){ this.root = null this.size = 0 } getSize(){ return this.size } isEmpty(){ return this.size === 0 } addNode(v) { this.root = this._addChild(this.root, v) } // 添加节点时，需要比较添加的节点值和当前节点值的大小  _addChild(node, v) { if (!node) { this.size++ return new Node(v) } if (node.value \u0026gt; v) { node.left = this._addChild(node.left, v) } else if (node.value \u0026lt; v) { node.right = this._addChild(node.right, v) } return node } }   堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class MaxHeap{ constructor(){ this.heap=[] } size(){ return this.heap.length } empty(){ return this.size() == 0 } add(item){ this.heap.push(item) this._shiftUp(this.size()-1) } removeMax(){ this._shiftDown(0) } getParentIndex(k){ return parseInt((k - 1) / 2) } getLeftIndex(k){ return k * 2 + 1 } _shiftUp(k){ // 如果当前节点比父节点大，就交换  while(this.heap[k]\u0026gt;this.heap[this.getParentIndex(k)]){ this._swap(k,this.getParentIndex(k)) // 将索引变成父节点  k = this.getParentIndex(k) } } _swap(left, right) { let rightValue = this.heap[right] this.heap[right] = this.heap[left] this.heap[left] = rightValue } _shiftDown(k){ // 交换首位并删除末尾  this._swap(k, this.size() - 1) this.heap.splice(this.size() - 1, 1) // 判断节点是否有孩子，二叉堆有左必有右  while(this.getLeftIndex(k) \u0026lt; this.size()){ let j=this.getLeftIndex(k) // 判断是否有右孩子 并且右是否比左大  if(j+1 \u0026lt; this.size() \u0026amp;\u0026amp; this.heap[j+1] \u0026gt; this.heap[j]) j++ // 判断父节点是否比子节点都大  if(this.heap[k] \u0026gt;= this.heap[j]) break this._swap(k, j) k = j } } }   二叉树的先序/中序/后序遍历 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function TreeNode(val){ this.val = val; this.left = this.right = null; } var traversal = function(root){ if(root){ // 先序  console.log(root); traversal(root.left); // 中序 左之后输出  // console.log(root);  traversal(root.right); // 后序 左右根  // console.log(root);  } }   非递归实现 先序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function pre(root) { if (root) { let stack = []; stack.push(root); //先push根节点  while (stack.length \u0026gt; 0) { // 弹出栈顶元素  root = stack.pop(); console.log(root); // 栈是先进后出 先序遍历是先左后右  // 所以先push右边 再push左边  if(root.right){ stack.push(root.right); } if(root.left){ stack.push(root.left); } } } }   中序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function mid(root){ if(root){ let stack = []; // 中序遍历是左根右  // 先把左边节点遍历到底 依次push进栈  // 当左边没有节点时打印栈顶元素 然后寻找右节点  // 左边打印不出东西就打印父节点，然后看右节点  while(stack.length\u0026gt;0 || root){ if(root){ stack.push(root); root = root.left; }else{ root = stack.pop(); console.log(root); root = root.right; } } } }   后序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function pos(root){ if(root){ let stack1 = []; let stack2 = []; // 左右根 对于栈来说 先push根节点  // 然后push右节点 最后左节点  stack1.push(root); while(stack1.length \u0026gt; 0){ root = stack1.pop(); stack2.push(root); if(root.left){ stack1.push(root.left); } if(root.right){ stack1.push(root.right); } } while(stack2.length \u0026gt; 0){ console.log(s2.pop()); } } }   动态规划 解决斐波那契数列问题\n 斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层 通过数组来存储每一位所对应的斐波那契数列的值  1 2 3 4 5 6 7 8 9  function fib(n){ let array=new Array(n+1).fill(null) array[0] = 0 array[1] = 1 for(let i=2; i \u0026lt;= n; i++){ array[i] = array[i-1]+array[i-2] } return array[n] }   学习算法时，可视化界面可以帮助我们更好的理解，推荐配合VisualAlgo或Algorithm Visualizer。\n","date":"2019-02-15T18:24:10Z","image":"https://neptoo.github.io/2019/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/data-structure_hu639d2c065a0b82b0b98f6af0a78cd49d_33146_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2019/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","title":"前端数据结构的算法实现"},{"content":"最近在学习微信小程序的开发，涉及到移动端设备适配的知识点，想到之前秋招一位面试官问我的问题\u0026ndash;怎么判断用户是用什么设备访问的，是pc端还是移动端？ 我回答的是根据屏幕分辨率大小尺寸，他又表示电脑端也可以竖屏。。。然后我就不知道了，后来他也给我讲了应该怎么解决，现在时间有点久了答案已经忘了，于是决定搜集资料写篇博客记录这个问题。 网上给出的大多数方案，用js判断的原理是浏览器提交的user agent，不管是PC还是手机浏览器。\n第一种，使用indexOf判断\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;script\u0026gt; var userAgentInfo = navigator.userAgent; var mAgents = new Array(\u0026#34;Android\u0026#34;, \u0026#34;iPhone\u0026#34;, \u0026#34;SymbianOS\u0026#34;, \u0026#34;Windows Phone\u0026#34;, \u0026#34;iPad\u0026#34;, \u0026#34;iPod\u0026#34;); var pAgents = new Array(\u0026#34;Trident\u0026#34;, \u0026#34;Presto\u0026#34;, \u0026#34;Gecko\u0026#34;, \u0026#34;Webkit\u0026#34;); var flag = false; for (var v = 0; v \u0026lt; mAgents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u0026gt; 0) { flag = true; break; } } if (flag) { // 来自于移动端，同理判断PC浏览器 } \u0026lt;/script\u0026gt;   第二种，使用正则表达式判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;script\u0026gt; function browserRedirect() { var ua = navigator.userAgent.toLowerCase() || window.navigator.userAgent.toLowerCase(); var isWX = /MicroMessenger/i.test(ua), isIOS = /(iPhone|iPad|iPod|iOS)/i.test(ua), isAndroid = /(android|nexus)/i.test(ua), isBlackBerry = /BlackBerry/i.test(ua), isWindows = /(Window Phone|windows[\\s+]phone)/i.test(ua), isMidp = /midp/i.test(ua); document.writeln(\u0026#34;您的浏览设备为：\u0026#34;); if (isWX || isIOS || isAndroid || isBlackBerry || isWindows || isMidp) { document.writeln(\u0026#34;phone\u0026#34;); } else { document.writeln(\u0026#34;pc\u0026#34;); } } browserRedirect(); \u0026lt;/script\u0026gt;   除此之外，在移动端开发时有的项目还要考虑到兼容横竖屏。\n","date":"2019-01-16T17:32:44Z","permalink":"https://neptoo.github.io/2019/%E4%BB%8E%E4%B8%80%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7/","title":"从一道前端面试题说起"},{"content":"所谓模块化就是将需要用到的方法封装成为一个模块，哪里需要直接调用即可。\njs库+命名空间 网上常用的较为简单的一种方法是创建js库，要避免重复，封装自己的函数，要使用命名空间，对象就是天然的命名空间。\n(function(global){ var myfun1=function(){ console.log('myfun1'); }; var myfun2=function(){ console.log('myfun2'); }; //设置你的命名空间 var mypackageName=\u0026quot;com.mydomain.utils\u0026quot;; var packageArray=mypackageName.split(\u0026quot;.\u0026quot;); var finalObj=packageArray.reduce(function(prev,current){ return prev[current]||(prev[current]={}); }, global); //将你的函数绑定到命名空间上 finalObj.myfun1= myfun1; finalObj.myfun2= myfun2; }(window)); com.mydomain.utils.myfun1();//输出 myfun1 com.mydomain.utils.myfun2();//输出 myfun2  ES模块封装 现在模块化机制已经成熟，另一种是使用ES2015 module封装模块。 (1)首先学会怎么用 ES2015 来编写／封装模块（node／npm，加上 babel 的入门知识）； (2)学会发布到npm； (3)如何引入模块到应用体系中，如何加载/打包(gulp/webpack/jspm等)。 封装不只是要学习代码怎么写，更要知道如何维护和应用，否则封装就不具备普适性。\nJavaScript不是基于OO的语言，class不是必需的，还有其他模式，比如工厂函数（Factory Functions）要远比 class 简洁、灵活。\n简单工厂模式 它的作用是，利用面向对象的方法，把一些对象封装，使一些占用空间多的，重复的代码封装起来。 实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性以及方法再将对象返回即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function creatper(name,age){ var per=new Object(); //原料  //加工  per.name=name; per.age=age; per.sayHi=function(){ console.log(per.name+\u0026#39;\u0026#39;+per.age); } return per; //出厂  } var me=creatper(\u0026#39;katherine\u0026#39;,22); me.sayHi(); console.log(me.name);   可以看出使用工厂模式，可以重复调用这个per函数来生成不同属性值得对象，这就像工厂一样，批量生产，里面的原料，加工，出厂都很清晰。但是你会发现工厂模式是无法识别对象的类型，因为全都是object，不像Date，Array等，但是构造函数就不是了。这还只是简单的工厂模式，复杂的工厂模式（抽象模式）等以后再回来详细了解。\n","date":"2018-09-30T18:44:32Z","permalink":"https://neptoo.github.io/2018/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85js-%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85/","title":"如何封装JS-模块化与封装"}]