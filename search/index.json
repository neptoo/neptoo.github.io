[{"content":"需求是商城内的购物车图标遮挡了商品，需要在当前可视区域自由拖动购物车组件，不影响用户点击商品。\n效果预览  录制的gif有一定的掉帧，实际上真机拖动的时候是流畅的。\n 解决思路 查阅文档，微信小程序提供了movable-area和movable-view标签。目前项目里的当前页面是比较简单的，所以可以用movable-area包裹整个可视页面，movable-view包裹你要移动的元素。关键在于项目中使用了自定义导航栏mp-navigation-bar，如何获取页面剩余的内容可用高度。\n代码实现 index.wxml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;mp-navigation-bar background=\u0026#34;#3883ff\u0026#34; title=\u0026#34;商城\u0026#34; back=\u0026#34;{{false}}\u0026#34;\u0026gt;\u0026lt;/mp-navigation-bar\u0026gt; \u0026lt;movable-area\u0026gt; \u0026lt;!-- 内容区域 --\u0026gt; \u0026lt;view style=\u0026#34;height: {{contentHeight}}px\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-box\u0026#34; wx:for=\u0026#34;{{goodsList}}\u0026#34; wx:key=\u0026#34;id\u0026#34; bindtap=\u0026#34;toDetailsTap\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;img-box\u0026#34;\u0026gt; \u0026lt;image src=\u0026#34;{{item.pic}}\u0026#34; class=\u0026#34;image\u0026#34; mode=\u0026#34;aspectFill\u0026#34; lazy-load=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;goods-title van-multi-ellipsis--l2\u0026#34;\u0026gt;{{item.name}}\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;price-parent\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;goods-price\u0026#34;\u0026gt;¥ {{item.price}}\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 内容区域 end --\u0026gt; \u0026lt;!-- 需要拖动的组件 --\u0026gt; \u0026lt;movable-view x=\u0026#34;{{x}}\u0026#34; y=\u0026#34;{{y}}\u0026#34; direction=\u0026#34;all\u0026#34;\u0026gt; \u0026lt;!-- vant-weapp框架中的一个购物车组件，可以替换为其它元素/组件 start --\u0026gt; \u0026lt;van-goods-action-icon icon-class=\u0026#34;goods-icon\u0026#34; icon=\u0026#34;cart-o\u0026#34; text=\u0026#34;购物车\u0026#34; bind:click=\u0026#34;goShopCar\u0026#34; info=\u0026#34;{{ shopNum ? shopNum : \u0026#39;\u0026#39; }}\u0026#34; /\u0026gt; \u0026lt;!-- vant-weapp框架中的一个购物车组件，可以替换为其它元素/组件 end --\u0026gt; \u0026lt;/movable-view\u0026gt; \u0026lt;!-- 需要拖动的组件 end --\u0026gt; \u0026lt;/movable-area\u0026gt;   index.wxss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  movable-view { display: flex; align-items: center; justify-content: center; height: 100rpx; width: 100rpx; background-color: #fff; border-radius: 20rpx; box-shadow: 0rpx 20rpx 50rpx -12rpx rgba(0,0,0,0.25) ; } movable-area { height: 100%; width: 100%; }   index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  Page({ data: { // 设置拖动组件的初始位置  x:340, y: 0, goodsList: [ {id: 15, pic: \u0026#34;https://images.pexels.com/photos/2113994/pexels-photo-2113994.jpeg\u0026#34;, name: \u0026#34;手表\u0026#34;, price: 699}, {id: 17, pic: \u0026#34;https://images.pexels.com/photos/221185/pexels-photo-221185.jpeg\u0026#34;, name: \u0026#34;平板\u0026#34;, price: 1900}, {id: 20, pic: \u0026#34;https://images.pexels.com/photos/1203803/pexels-photo-1203803.jpeg\u0026#34;, name: \u0026#34;相机\u0026#34;, price: 8150}, {id: 21, pic: \u0026#34;https://images.pexels.com/photos/270640/pexels-photo-270640.jpeg\u0026#34;, name: \u0026#34;键盘\u0026#34;, price: 2168} ], }, onLoad(){ this.getCartHeight() }, getCartHeight(){ // 页面初始化时 设置购物车初始位置为 停留在页面高度的2/3的位置 也可以设置成其他值  const height = Math.floor((wx.getSystemInfoSync().windowHeight)*2/3); this.setData({ y: height }) // 获取 自定义导航栏 时 页面高度  let customWindowHeight = wx.getSystemInfoSync().windowHeight // console.log(\u0026#39;customWindowHeight\u0026#39;, customWindowHeight)  let navH = wx.getStorageSync(\u0026#39;navigationBarHeight\u0026#39;) + wx.getStorageSync(\u0026#39;statusBarHeight\u0026#39;) // console.log(\u0026#39;navH\u0026#39;, navH)  let contentHeight = customWindowHeight - navH*2 this.setData({ contentHeight }) }, })   app.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  App({ globalData: {}, onLaunch() { // 自定义导航  this.getNavHeight() }, getNavHeight(){ const { statusBarHeight, platform } = wx.getSystemInfoSync() const { top, height } = wx.getMenuButtonBoundingClientRect() // 状态栏高度 (包含wifi信号、电量、时间的那一行顶部状态栏)  wx.setStorageSync(\u0026#39;statusBarHeight\u0026#39;, statusBarHeight) // 整个导航栏高度 = 胶囊按钮高度 + 状态栏到胶囊按钮间距 * 2 // Android导航栏高度 = 32px + 8px * 2 = 48px // iOS导航栏高度 = 32px + 6px * 2 = 44px  // 判断胶囊按钮信息是否成功获取  if (top \u0026amp;\u0026amp; top !== 0 \u0026amp;\u0026amp; height \u0026amp;\u0026amp; height !== 0) { const navigationBarHeight = (top - statusBarHeight) * 2 + height // 导航栏高度  wx.setStorageSync(\u0026#39;navigationBarHeight\u0026#39;, navigationBarHeight) } else { wx.setStorageSync( \u0026#39;navigationBarHeight\u0026#39;, platform === \u0026#39;android\u0026#39; ? 48 : 40 ) } }, })   参考资料 moveable-area 微信小程序文档\n小程序自定义导航栏适配（完美版）\n","date":"2023-04-28T14:05:29Z","image":"https://images.unsplash.com/photo-1508921340878-ba53e1f016ec?ixlib=rb-4.0.3\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=1170\u0026q=80","permalink":"https://neptoo.github.io/2023/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%BB%91%E5%9D%97%E7%BB%84%E4%BB%B6/","title":"微信小程序实现全屏可拖动滑块组件"},{"content":"生命不息，折腾不止。继几次给同事安利成功后，我决定写一篇博客总结一下我经常使用的笔记软件。\nNotion 19年的时候开始了解到并使用notion，真正几乎每天使用是在去年。之前使用了一段时间的是语雀，我很喜欢日历视图。\n大概等语雀送的一年会员到期，因为语雀改版，页面不再简洁，我就不再使用它。语雀是阿里的技术文档社区，有一批优质程序员博主，这也是它的优势之一。对于我自己来说，作为一个笔记应用，是否订阅博主其实不是很重要，并且它后来推出的很多功能是为了商业化，作为用户使用体验是不大好的。\n在每天的工作中，使用日历视图管理待办事项是很方便的，有时候需要实现的需求，最后周报总结的时候有助于回顾。\nNotion可以用来记账。每次阻止我记账的原因，坚持不下来的原因就是时间久了我会忘记。介于工作的时候使用notion日历管理我的日程，几乎每天都会打开notion，所以很大程度缓解了记账的难度。去年坚持了一整年，年度总结可以导出notion数据到Excel，清晰明了的分析自己的经济状况。\n从最开始使用到高频使用，我之前也试用过，觉得notion使用教程太复杂，不适合我。但是对于功能复杂的软件，选择一个功能点去用就好，如果是适合你的，好用的，后续自然而然就用习惯了。并不需要觉得太有负担。\n我也尝试过notion的看板功能，可以用来记录读过的书或者简历投递记录。\n在看板里每一个项目可以展开一个新的页面，可以在页面里记录详情，你可以灵活创建新的属性。\nObisidian notion唯一的问题是使用的在线服务，如果有一天notion被墙或者官方不再支持查看之前的数据，这些都是很不便的，所以我选择了本地存储数据的文档管理软件\u0026ndash;Obisidian。\nObisidian有一个很好用的热门插件，叫 Daily notes。你可以选择一个文件夹，用来存储你每天的日记文档。可以设置模板，比如每天要做的事项，我自己倾向于使用空白模板。Obisidian可以看作一个markdown文件管理软件。平时工作中更细节的需求、问题记录、思路和代码等我会整理在这里。配合notion 日历视图里写的是任务摘要。\n我也会使用Obisidian管理leetcode刷题记录。本质上还是使用的markdown文档，md文档的树形结构是很方便很有条理性的，在obisidian中可以选择折叠/展开某个目录。复习题目的时候可以不看答案，只看题目或者重点。\nObisidian最大的特色应该就是双向链接，你可以使用图中的格式创建另一个文档的链接，鼠标hover移动上去并且按住ctrl键，可以预览链接文档的内容。\n","date":"2023-03-29T10:55:43Z","image":"https://images.pexels.com/photos/4050315/pexels-photo-4050315.jpeg","permalink":"https://neptoo.github.io/2023/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/","title":"生产力工具推荐"},{"content":"效果预览 点击地图上的散点，默认展示公司设备状态；点击公司标题，切换信息；再次点击公司名，返回展示之前的信息。\n散点数据处理(可跳过) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  handleData(){ // 测试数据  this.normalGroup = [ { value: [112.2, 34.4], companyName: \u0026#34;河南有限公司\u0026#34;, device: \u0026#39;test123456\u0026#39;, status: \u0026#39;正常\u0026#39;, type: 1 }, { value: [111.2, 24.4], companyName: \u0026#34;湖北有限公司\u0026#34;, device: \u0026#39;test111111\u0026#39;, status: \u0026#39;正常\u0026#39;, type: 2 }, { value: [113.2, 35.4], companyName: \u0026#34;北京有限公司\u0026#34;, device: \u0026#39;test222222\u0026#39;, status: \u0026#39;正常\u0026#39;, type: 1 } ]; this.warnGroup = [ { value: [76.2, 39.4], companyName: \u0026#34;新疆有限公司\u0026#34;, device: \u0026#39;test123456\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 }, { value: [111.2, 24.4], companyName: \u0026#34;湖北有限公司\u0026#34;, device: \u0026#39;test333333\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 }, { value: [110.2, 35.4], companyName: \u0026#34;广东有限公司\u0026#34;, device: \u0026#39;test222222\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 }, { value: [112.2, 35.4], companyName: \u0026#34;广东有限公司\u0026#34;, device: \u0026#39;test232222\u0026#39;, status: \u0026#39;警告\u0026#39;, type: 1 } ]; this.reHandleData(); this.initMap(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  // 处理一家公司名下的设备 组成树形数据 subdata reHandleData(){ // 深拷贝创建数据处理前的局部变量  let localGreenData = this.normalGroup.concat(); // 正常组  let localBlueData = this.warnGroup.concat(); // 警告组  // 数据处理后的局部变量  let newLocalGreenData = []; let newLocalBlueData = []; // 数据处理的判断条件，用于保存所有点的不重复的坐标  let greenPositionList = []; let bluePositionList = []; localGreenData.forEach((element) =\u0026gt; { if (greenPositionList.toString().indexOf(element.value.toString()) === -1) { greenPositionList.push(element.value); } }); localBlueData.forEach((element) =\u0026gt; { if (bluePositionList.toString().indexOf(element.value.toString()) === -1) { bluePositionList.push(element.value); } }); // 业务逻辑：如果一家公司名下，设备A是异常警告状态，设备B是正常状态，  // 地图上这个公司的点应该是警告的颜色，警告的优先级更高  // 根据两种positionList对2个数组进行过滤，并组装，从警告级别开始  // 组装数组内，同坐标点的节点  localBlueData = this.getTreeByArray(localBlueData); localBlueData.forEach((element) =\u0026gt; { // element.subData = []  if (greenPositionList.toString().indexOf(element.value.toString()) \u0026gt; -1) { localGreenData.forEach((element1) =\u0026gt; { if (element.value.toString() === element1.value.toString()) { element.subData.push(element1); } }); localGreenData = localGreenData.filter((item) =\u0026gt; { return item.value.toString() !== element.value.toString(); }); } newLocalBlueData.push(element); }); localGreenData = this.getTreeByArray(localGreenData); this.warnGroup = newLocalBlueData; this.normalGroup = newLocalGreenData; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //将数组中坐标值(value)相同的数据项折叠，生成树结构 getTreeByArray(array) { let repeatList = []; //合并数组自身的同坐标项  let leftArray = []; let rightArray = []; array.forEach((element) =\u0026gt; { if (repeatList.toString().indexOf(element.value.toString()) === -1) { repeatList.push(element.value); leftArray.push(element); } else { rightArray.push(element); } }); leftArray.forEach((element) =\u0026gt; { element.subData = []; rightArray.forEach((element1) =\u0026gt; { if (element.value.toString() === element1.value.toString()) { element.subData.push(element1); } }); }); array = leftArray.concat(); return array; },   ECharts 地图展示散点 1  \u0026lt;div class=\u0026#34;map\u0026#34; id=\u0026#34;mymap\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163  initMap(){ const _this = this; let mychart = echarts.init(document.getElementById(\u0026#34;mymap\u0026#34;)) mychart.off(\u0026#39;click\u0026#39;) let convertData = function (data) { // 处理数据函数  let res = []; for (let i = 0; i \u0026lt; data.length; i++) { let obj = { device: data[i].device, companyName: data[i].companyName, subData: data[i].subData, value: data[i].value, type: data[i].type, } res.push(obj) } return res } let convertSeries = [{ type: \u0026#34;effectScatter\u0026#34;, coordinateSystem: \u0026#34;bmap\u0026#34;, data: convertData(_this.normalGroup), symbolSize: 24, label: { show: true, color: \u0026#34;#fff\u0026#34;, fontSize: 16, // distance: 0,  formatter: function (item) { // 散点中心显示数字-公司名下的设备总数  let label = item.data.subData.length + 1; return label; }, }, showEffectOn: \u0026#34;emphasis\u0026#34;, hoverAnimation: true, animation: false, itemStyle: { normal: { color: \u0026#34;#0CB481\u0026#34;, }, }, zlevel: 2, },{ type: \u0026#34;effectScatter\u0026#34;, coordinateSystem: \u0026#34;bmap\u0026#34;, data: convertData(_this.warnGroup), symbolSize: 24, label: { show: true, color: \u0026#34;#fff\u0026#34;, fontSize: 16, distance: 0, formatter: function (item) { let label = item.data.subData.length + 1; return label; }, }, showEffectOn: \u0026#34;render\u0026#34;, rippleEffect: { period: 8, scale: 1.5, brushType: \u0026#34;stroke\u0026#34;, }, hoverAnimation: true, animation: false, itemStyle: { normal: { color: \u0026#34;#0D86F5\u0026#34;, }, emphasis: { color: \u0026#34;#0D86F5\u0026#34;, }, }, zlevel: 3, }] let oldTooltip = { trigger: \u0026#39;item\u0026#39;, triggerOn: \u0026#39;click\u0026#39;, enterable: true, borderWidth: 0, showDelay: 0, hideDelay: 0, transitionDuration: 0, // 白底黑字  extraCssText: \u0026#34;z-index:100;background:rgba(0,0,0,0.8);color:#fff;padding:0;\u0026#34;, formatter: function(item){ // 重要警告！！！这里使用了formatter返回原生html字符串，使用了大量的字符串拼接操作  // 测试发现这里不支持对象的{}表示方式，所以只能使用[[],[]]二维数组的方式  // 使用了大量单引号双引号和转义符，如果出错一般就是字符串拼接时候引号对应错误  let data = []; let allPage = item.data.subData.length + 1; // 将当前页码和总页数存储为二维数组的第一项  // 注意data里每个字段的顺序和展示的tooltip顺序保持一致  let pushArr = [ item.data.device, item.data.companyName, item.data.type, ] data.push(pushArr); item.data.subData.forEach((element) =\u0026gt; { data.push([ element.device, element.companyName, element.type ]) // 每次打开新的tooltip，初始化页码和当前deviceName  _this.tooltipCurDeviceName = data[0][0]; _this.tooltipCurPage = 1; data = JSON.stringify(data); let newData = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; data.length; i++) { if (data[i] === \u0026#39;\u0026#34;\u0026#39;) { newData += \u0026#34;\u0026#39;\u0026#34;; } else { newData += data[i]; } } data = newData; // 使用字符串拼接，根据条件修改原生css  let conditionalCSS = \u0026#34;\u0026#34;; switch (item.data.status) { case \u0026#34;警告\u0026#34;: conditionalCSS += \u0026#34;style=\u0026#39;color:#0D86F5\u0026#39;\u0026#34;; break; case \u0026#34;正常\u0026#34;: conditionalCSS += \u0026#34;style=\u0026#39;color:#0CB481\u0026#39;\u0026#34;; break; } let resultHtml = ` \u0026lt;div id=\u0026#34;tooltipDiv\u0026#34; style=\u0026#34;padding: 20px;\u0026#34;\u0026gt; \u0026lt;div onclick=\u0026#34;titleClick(${data})\u0026#34;\u0026gt; \u0026lt;span\u0026gt;${item.data.companyName}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ` +\u0026#39;\u0026lt;div id=\u0026#34;statusDiv\u0026#34;\u0026gt;状态：\u0026lt;b\u0026#39; + conditionalCSS + item.data.status + \u0026#34;\u0026lt;/b\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;; return resultHtml } } } let option = { bmap: { center: [104.5, 30.8], roam: true, }, tooltip: oldTooltip, animation: false, series: convertSeries }; // 每次点击散点的时候 初始化tooltip  mychart.on(\u0026#39;click\u0026#39;, function (element) { let tempOption = mychart.getOption() tempOption.tooltip = oldTooltip mychart.setOption(tempOption) }) mychart.setOption(option) }   点击标题切换 tooltip 信息内容 在模板字符串中，使用 onclick 绑定事件 titleClick；在 created 阶段中，将方法赋给 window 全局事件。\n1 2 3 4  created() { window.titleClick = this.handleTitleCheck; // window.titleBack = this.handleTitleBack; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // 点击公司名 tooltip信息展示 handleTitleCheck(){ let mychart = echarts.init(document.getElementById(\u0026#34;mymap\u0026#34;)); let newTooltip = { trigger: \u0026#39;item\u0026#39;, triggerOn: \u0026#39;click\u0026#39;, enterable: true, borderWidth: 0, showDelay: 0, hideDelay: 0, transitionDuration: 0, extraCssText: \u0026#34;z-index:100;background:rgba(0,0,0,0.8);color:#fff;padding:0;\u0026#34;, formatter: function (item) { let data = []; let pushArr = [ item.data.companyName, item.data.type, ] data.push(pushArr); data = JSON.stringify(data); let newData = \u0026#34;\u0026#34;; //将data中的双引号替换成单引号，不然字符串拼接就会错误  for (let i = 0; i \u0026lt; data.length; i++) { if (data[i] === \u0026#39;\u0026#34;\u0026#39;) { newData += \u0026#34;\u0026#39;\u0026#34;; } else { newData += data[i]; } } data = newData; let resultHtml = `\u0026lt;div id=\u0026#34;tooltipDiv\u0026#34; style=\u0026#34;padding: 20px;\u0026#34;\u0026gt; \u0026lt;div onclick=\u0026#34;titleBack(${data})\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-back\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span style=\u0026#34;margin-left:6px;\u0026#34;\u0026gt;设备名${item.data.device}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; `; return resultHtml }, } let myoption = mychart.getOption() myoption.tooltip = newTooltip mychart.setOption(myoption) },   ","date":"2022-11-09T15:41:16Z","image":"https://images.pexels.com/photos/41949/earth-earth-at-night-night-lights-41949.jpeg","permalink":"https://neptoo.github.io/2022/vue-%E4%B8%AD-echarts-tooltip-%E6%95%A3%E7%82%B9%E4%BF%A1%E6%81%AF%E5%88%87%E6%8D%A2%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","title":"Vue 中 ECharts tooltip 散点信息切换和事件绑定"},{"content":"预览效果 ECharts组件封装 传入指定的 id 、option、宽高，然后渲染图表。\n封装 component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  // ehistogram.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div ref=\u0026#34;chart\u0026#34; :id=\u0026#34;idName\u0026#34; :style=\u0026#34;{ height: height, width: width }\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;ehistogram\u0026#39;, props: { width: { type: String, default: \u0026#39;100%\u0026#39; }, height: { type: String, default: \u0026#39;350px\u0026#39; }, autoResize: { type: Boolean, default: true }, chartOption: { type: Object, required: true }, idName: { type: String, required: true }, type: { type: String, default: \u0026#39;canvas\u0026#39; } }, data() { return { chart: null } }, watch: { chartOption: { deep: true, handler(newVal) { this.setOptions(newVal) } } }, mounted() { this.initChart() if (this.autoResize) { window.addEventListener(\u0026#39;resize\u0026#39;, this.resizeHandler) } }, beforeDestroy() { if (!this.chart) { return } if (this.autoResize) { window.removeEventListener(\u0026#39;resize\u0026#39;, this.resizeHandler) } this.chart.dispose() this.chart = null }, methods: { resizeHandler() { this.chart.resize() }, initChart() { this.chart = this.$echarts.init(this.$refs.chart, \u0026#39;\u0026#39;, { renderer: this.type }) this.chart.setOption(this.chartOption) this.chart.on(\u0026#39;click\u0026#39;, this.handleClick) }, handleClick(params) { this.$emit(\u0026#39;click\u0026#39;, params) }, setOptions(option) { this.clearChart() this.resizeHandler() if (this.chart) { this.chart.setOption(option) } }, refresh() { this.setOptions(this.chartOption) }, clearChart() { this.chart \u0026amp;\u0026amp; this.chart.clear() } } } \u0026lt;/script\u0026gt;   联动和数据共享  官网提供了实例，但是它是上下布局，并且 dataset 数据和我从后端拿到数据不一样，处理方法相对复杂，所以我没有采用。\n 初始化数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ehistogram idName=\u0026#34;pieLineContainer\u0026#34; :chart-option=\u0026#34;pieLineOption\u0026#34; :auto-resize=\u0026#34;true\u0026#34; height=\u0026#34;400px\u0026#34; width=\u0026#34;100%\u0026#34;\u0026gt;\u0026lt;/ehistogram\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ehistogram from \u0026#34;./components/ehistogram.vue\u0026#34; export default { components: { ehistogram }, data() { this.pieLineOption = { \u0026#34;legend\u0026#34;: { \u0026#34;data\u0026#34;: [], \u0026#34;textStyle\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#fff\u0026#34; }, \u0026#34;show\u0026#34;: true, \u0026#34;x\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;left\u0026#34;: \u0026#34;center\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;3%\u0026#34; }, \u0026#34;tooltip\u0026#34;: { \u0026#34;show\u0026#34;: true, \u0026#34;trigger\u0026#34;: \u0026#34;axis\u0026#34; }, \u0026#34;grid\u0026#34;: { \u0026#34;left\u0026#34;: \u0026#34;40%\u0026#34;, \u0026#34;right\u0026#34;: \u0026#34;5%\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;25%\u0026#34;, \u0026#34;bottom\u0026#34;: \u0026#34;10%\u0026#34;, \u0026#34;containLabel\u0026#34;: true }, \u0026#34;xAxis\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;category\u0026#34;, \u0026#34;axisLabel\u0026#34;: { \u0026#34;show\u0026#34;: true, \u0026#34;textStyle\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#fff\u0026#34; } }, \u0026#34;axisTick\u0026#34;: { \u0026#34;show\u0026#34;: false }, \u0026#34;data\u0026#34;: [] }, \u0026#34;yAxis\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;value\u0026#34;, \u0026#34;axisLabel\u0026#34;: { \u0026#34;show\u0026#34;: true, \u0026#34;textStyle\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#fff\u0026#34; } }, \u0026#34;axisLine\u0026#34;: { \u0026#34;show\u0026#34;: false }, \u0026#34;axisTick\u0026#34;: { \u0026#34;show\u0026#34;: false } }, \u0026#34;series\u0026#34;: [] }; return { pieColors: [\u0026#39;#69D2E7\u0026#39;, \u0026#39;#AAB3AB\u0026#39;, \u0026#39;#61a0a8\u0026#39;, \u0026#39;#d48265\u0026#39;, \u0026#39;#A8E6CE\u0026#39;, \u0026#39;#FF9933\u0026#39;, \u0026#39;#C2C287\u0026#39;], } },   数据处理和图表渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  mounted() { this.handleData() }, methods() { handleData(){ //从api获取你需要的真实数据 此处就直接赋值了 \tlet xAixsData = [ \u0026#34;2022-09-01 00\u0026#34;, \u0026#34;2022-09-01 01\u0026#34;, \u0026#34;2022-09-01 02\u0026#34;, \u0026#34;2022-09-01 03\u0026#34;, \u0026#34;2022-09-01 04\u0026#34;, \u0026#34;2022-09-01 05\u0026#34;, \u0026#34;2022-09-01 06\u0026#34;, \u0026#34;2022-09-01 07\u0026#34;, \u0026#34;2022-09-01 08\u0026#34;, \u0026#34;2022-09-01 09\u0026#34;, \u0026#34;2022-09-01 10\u0026#34;, \u0026#34;2022-09-01 11\u0026#34;, \u0026#34;2022-09-01 12\u0026#34;, \u0026#34;2022-09-01 13\u0026#34;, \u0026#34;2022-09-01 14\u0026#34;, \u0026#34;2022-09-01 15\u0026#34;, \u0026#34;2022-09-01 16\u0026#34; ]; let legendName = [ \u0026#34;羽毛\u0026#34;, \u0026#34;地膜\u0026#34;, \u0026#34;棉花\u0026#34;, ]; let line1 = [7,10,14,5,5,9,6,4,7,10, 3,5,2,6,11,5,5]; let line2 = [ 51,43,43,37,30,37,36,36,30,27,25,25,48,43,31,37,23]; let line3 = [0,0,2,0,0,0,0,0,0,0,0,0,8,0,0,0,0]; let lineObj = [line1, line2, line3] let allSum = [{ \u0026#34;name\u0026#34;: \u0026#34;羽毛\u0026#34;, \u0026#34;value\u0026#34;: 114 }, { \u0026#34;name\u0026#34;: \u0026#34;地膜\u0026#34;, \u0026#34;value\u0026#34;: 602 }, { \u0026#34;name\u0026#34;: \u0026#34;棉花\u0026#34;, \u0026#34;value\u0026#34;: 10 }] let seriesTemp = [] for (let i = 0; i \u0026lt; legendName.length; i++) { let objLine = { name: legendName[i], type: \u0026#34;line\u0026#34;, color: this.pieColors[i], smooth: true, data: lineObj[i] } seriesTemp.push(objLine) } let pieObj = { name: \u0026#34;总数\u0026#34;, type: \u0026#39;pie\u0026#39;, color: this.pieColors, center: [\u0026#39;15%\u0026#39;, \u0026#39;54%\u0026#39;], radius: \u0026#39;50%\u0026#39;, data: allSum, label: { formatter: (params) =\u0026gt; { return params.name + \u0026#39;:\u0026#39; + params.value } }, } seriesTemp.push(pieObj) this.initChart(xAixsData, legendName, seriesTemp) }, initChart(xAixsData, legendName, seriesTemp){ this.pieLineOption.xAxis.data = xAixsData this.pieLineOption.legend.data = legendName this.pieLineOption.series = seriesTemp this.pieLineChart = this.$echarts.init(document.getElementById(\u0026#39;pieLineContainer\u0026#39;)); this.pieLineChart.setOption(this.pieLineOption); } } } \u0026lt;/script\u0026gt;   ","date":"2022-09-02T10:13:24Z","image":"https://images.pexels.com/photos/7947663/pexels-photo-7947663.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1","permalink":"https://neptoo.github.io/2022/vue-echarts-%E5%AE%9E%E7%8E%B0%E9%A5%BC%E5%9B%BE%E5%92%8C%E6%8A%98%E7%BA%BF%E5%9B%BE%E8%81%94%E5%8A%A8/","title":"Vue+ ECharts 实现饼图和折线图联动"},{"content":"Prerequisite: You have installed Vue.js(^2.5.2) and ElementUI(^2.15.8) in your project.\nCreating our own custom components Get started with Basic HTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-upload :action=\u0026#34;ossUploadUrl\u0026#34; :data=\u0026#34;dataObj\u0026#34; list-type=\u0026#34;picture-card\u0026#34; :file-list=\u0026#34;fileList\u0026#34; :before-upload=\u0026#34;beforeUpload\u0026#34; :on-remove=\u0026#34;handleRemove\u0026#34; :on-success=\u0026#34;handleUploadSuccess\u0026#34; :on-preview=\u0026#34;handlePreview\u0026#34; :limit=\u0026#34;maxCount\u0026#34; accept=\u0026#34;.jpg, .jpeg, .png, .gif, .mp4\u0026#34; :on-exceed=\u0026#34;handleExceed\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-plus\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogVisible\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;100%\u0026#34; :src=\u0026#34;dialogImageUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   Defining data and props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;script\u0026gt; import { policy } from \u0026#39;@/api/oss\u0026#39; export default { name: \u0026#39;multiPicUpload\u0026#39;, props: { // images array from parent template  value: Array, maxCount: { type: Number, default: 5 } }, data() { return { dataObj: { policy: \u0026#39;\u0026#39;, signature: \u0026#39;\u0026#39;, key: \u0026#39;\u0026#39;, ossaccessKeyId: \u0026#39;\u0026#39;, dir: \u0026#39;\u0026#39;, host: \u0026#39;\u0026#39; }, dialogVisible: false, dialogImageUrl: null, ossUploadUrl: \u0026#39;https://xxxxx.aliyun.com\u0026#39;, //replace it with your back-end service  }; },   Compute the array of uploaded images 1 2 3 4 5 6 7 8 9 10 11 12  computed: { fileList() { let fileList = []; if (this.value === undefined) return; for (let i = 0; i \u0026lt; this.value.length; i++) { fileList.push({ url: this.value[i] }); } return fileList; } },   Required Methods in doc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  methods: { emitInput(fileList) { let arr = []; for (let i = 0; i \u0026lt; fileList.length; i++) { arr.push(fileList[i].url); } this.$emit(\u0026#39;input\u0026#39;, arr) }, handleRemove(file, fileList) { this.emitInput(fileList); }, handlePreview(file) { this.dialogImageUrl = file.url; this.dialogVisible = true; }, beforeUpload(file) { // Tell if the image is larger than 5M  const isLt5M = file.size / 1024 / 1024 \u0026lt; 5; // const fileType = file.name.substring(file.name.lastIndexOf(\u0026#39;.\u0026#39;)+1)  // Identify the type of the image  // const isJpg = file.type == \u0026#39;image/jpeg\u0026#39; || file.type == \u0026#39;image/jpg\u0026#39; || file.type == \u0026#39;image/png\u0026#39; || file.type == \u0026#39;image/gif\u0026#39;  // if(!isJpg){  // this.$message.error(\u0026#39;You can only upload these image file types: jpg, jpeg, png, gif！\u0026#39;)  // return false  // }  if (!isLt5M) { this.$message.error(\u0026#39;The size of the uploaded image cannot exceed 5MB!\u0026#39;); return false } let _self = this; // 获取策略  return new Promise((resolve, reject) =\u0026gt; { // policy() is a GET request, not POST  policy().then(response =\u0026gt; { _self.dataObj.policy = response.data.policy; _self.dataObj.signature = response.data.signature; _self.dataObj.ossaccessKeyId = response.data.accessKeyId; _self.dataObj.key = response.data.dir + \u0026#39;/${filename}\u0026#39;; _self.dataObj.dir = response.data.dir; _self.dataObj.host = response.data.host; resolve(true) }).catch(err =\u0026gt; { console.log(err) reject(false) }) }) }, handleUploadSuccess(response, file, fileArr) { console.log(\u0026#39;Upload successful!\u0026#39;) let url = this.dataObj.host + \u0026#39;/\u0026#39; + this.dataObj.dir + \u0026#39;/\u0026#39; + fileArr.name; // Get the image url  this.fileList.push({ name: fileArr.name, url: url }); this.emitInput(this.fileList); }, handleExceed(file, fileList) { this.$message({ message: \u0026#39;Maximum of\u0026#39; + this.maxCount + \u0026#39;images can be uploaded\u0026#39;, type: \u0026#39;warning\u0026#39;, duration: 1000 }); }, } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;   how to use this component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-form-item label=\u0026#34;device photos\u0026#34;\u0026gt; \u0026lt;multipic-upload v-model=\u0026#34;selectDevicePicFiles\u0026#34;\u0026gt;\u0026lt;/multipic-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MultipicUpload from \u0026#34;@/components/Upload/multipicUpload\u0026#34;; export default { components: { MultipicUpload }, computed: { selectDevicePicFiles: { get: function () { return this.detailDevice.picUrl; }, set: function (newValue) { console.log(\u0026#34;get a newValue\u0026#34;, newValue); if (newValue == null || newValue.length === 0) { this.detailDevice.picUrl = []; } else { if (newValue.length \u0026gt; 0) { this.detailDevice.picUrl = newValue; } } }, }, }, }; \u0026lt;/script\u0026gt;   Finishing up Others  代码中用到的一些公共的方法\u0026ndash;此部分可以跳过\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // some utils/methods in case you want to see it  // api/oss.js import request from \u0026#39;@/utils/request\u0026#39; export function policy() { return request({ url:\u0026#39;/zm-admin/aliyun/oss/policy\u0026#39;, method:\u0026#39;get\u0026#39;, }) } // utils/request.js import axios from \u0026#39;axios\u0026#39; import { Message, MessageBox } from \u0026#39;element-ui\u0026#39; import store from \u0026#39;../store\u0026#39; import { getToken } from \u0026#39;@/utils/auth\u0026#39; const service = axios.create({ baseURL: process.env.BASE_API, timeout: 15000 }) service.interceptors.request.use(config =\u0026gt; { if (store.getters.token) { config.headers[\u0026#39;Authorization\u0026#39;] = getToken() // token  } return config }, error =\u0026gt; { console.log(error) // for debug  Promise.reject(error) }) export default service // auth.js import Cookies from \u0026#39;js-cookie\u0026#39; const TokenKey = \u0026#39;xxxxxToken\u0026#39; export function getToken() { return Cookies.get(TokenKey) }   Reference ElementUI Docs\n","date":"2022-08-17T18:01:47Z","image":"https://images.pexels.com/photos/3584996/pexels-photo-3584996.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1","permalink":"https://neptoo.github.io/2022/encapsulation-of-el-upload-display-an-image-after-uploading/","title":"Encapsulation of el upload - display an image after uploading"},{"content":" 三个月前的项目，一直想写一篇文章整理下，拖延了这么久，都忘得差不多了。其实最好是在知识还热乎的时候记下来，这篇文章最好的发表时间是三个月前╮(╯▽╰)╭\n 先放效果图：\n引入 Library 首先，引入需要的js库，可以从 three.js 官方github仓库中找到并下载，你可能会用到的：\n three.js OrbitControls.js GLTFLoader.js RGBELoader.js   前两个是必须用到的，最后一个是根据你使用的文件格式，选择不同的 loader 处理器。我还尝试过 STLLoader 和 FBXLoader 。\n 1 2 3 4 5 6  \u0026lt;!-- 包下载路径 --\u0026gt; \u0026lt;!-- https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/STLLoader.js --\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/three.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/GLTFLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/RGBELoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;    引入 RGBELoader 是因为在后面用到了 HDR 贴图，简而言之，就是调整环境光，给模型上色。\n 在 html 文件中创建一个 div ，让我们的模型能够显示出来。\n1  \u0026lt;div id=\u0026#34;mymodel\u0026#34; style=\u0026#34;width:500px; height: 600px;margin:100px auto;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   加载模型 初始处理 首先，创建一个模型渲染方法，需要传入要绑定的页面元素的 ID，在方法里对模型进行处理。\n1 2 3 4 5 6 7 8  function glbViewer(id){ var elem = document.getElementById(elementID); var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); }   添加相机 camera，它决定了元素在页面中看起来的效果，就像一个投影相机，它接收4个参数，表示垂直视野角度，渲染窗口的长宽比，最近端的截面，最远端的截面。\n添加渲染器 renderer，设置 aplha 为 true，这样背景颜色透明，模型就可以浸染到页面背景中。设置渲染器画布的宽高和元素宽高一致，然后将它 append 到页面中。\n1 2 3 4 5 6 7 8 9  var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1; renderer.outputEncoding = THREE.sRGBEncoding; elem.appendChild(renderer.domElement);   outputEncoding 控制输出渲染编码，toneMapping 即使贴图不是 HDR，也可以塑造更真实的效果，toneMappingExposure 调整曝光度。\n添加页面自适应，窗口调整时重置画布的大小\n1 2 3 4 5  window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth/elem.clientHeight; camera.updateProjectionMatrix(); }, false);   然后，我们来定义 controls \u0026ndash;控制模型的变换缩放和旋转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; // 启用 damping 给控制器带来重量感 controls.dampingFactor = 0.1; //动态系数因子 越小越灵敏 controls.rotateSpeed = 0.05; controls.enableZoom = true; // 是否可以缩放 controls.autoRotate = true; // 是否自动旋转 controls.autoRotateSpeed = 5; // 自动旋转速度  controls.minDistance = 2; controls.maxDistance = 10; controls.target.set(0, 0.5, - 0.2); // 决定了初始化时 模型在页面视野中的角度  controls.update();   设置场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var scene = new THREE.Scene(); new THREE.RGBELoader() .load(\u0026#39;shanghai_riverside_4k.hdr\u0026#39;, function (texture) { // hdr 文件和 index.html 在同级  texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = new THREE.Color(0xffffff); scene.environment = texture; const loader = new THREE.GLTFLoader() .setPath(\u0026#39;assets/models/\u0026#39;); //根据你放的模型或者图片的位置决定是否要使用setPath  loader.load(\u0026#39;white.glb\u0026#39;, function (gltf) { camera.position.set(4, 0.3, -1.2); gltf.scene.position.y = -1.8; scene.add(gltf.scene); // 创建闭包 不断调用 animate 动画函数  // animate 函数通过调用 controls 的 update 函数来更新整个场景，然后让 three.js 去渲染  var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); });   你可以在 HDR 资源网站下载你需要的 hdr 文件\u0026ndash;可以理解为全景图。\n完工 调用上面的方法，将模型和我们前面定义的页面元素绑定起来。\n1 2 3 4 5  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { glbViewer(\u0026#34;mymodel\u0026#34;) } \u0026lt;/script\u0026gt;   总结 three.js 官网不仅仅有文档，也提供了各种文件格式各种效果渲染的实例，可以结合例子和 Github 中实例源码进行学习，手把手带你上手 three.js 。\n有一次建模的同事提供的是零件版 3D 模型，UI 同事是在专业的 3D 渲染和处理的软件( keyshot )中打开，所以导致我在浏览器中渲染出来的效果和他们看到的效果不一样，有时候问题可能是模型并不完整而不是代码问题。\ngltf 在线查看：https://gltf-viewer.donmccurdy.com/\n后续还有一些细节或者问题待优化，需要自己学习和研究一下 Blender ，自己建模和贴图。\n完整代码：(附赠一个 stl 渲染 demo)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;model\u0026#34; style=\u0026#34;width:500px; height: 600px;margin:100px auto;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 包下载路径 --\u0026gt; \u0026lt;!-- https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/STLLoader.js --\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/three.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/OrbitControls.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/GLTFLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/RGBELoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;assets/js/3d/STLLoader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function glbViewer(elementID) { var elem = document.getElementById(elementID) var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1; renderer.outputEncoding = THREE.sRGBEncoding; elem.appendChild(renderer.domElement); window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth / elem.clientHeight; camera.updateProjectionMatrix(); }, false); var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.minDistance = 2; controls.maxDistance = 10; controls.target.set(0, 0.5, - 0.2); controls.autoRotate = false; //自动旋转  controls.autoRotateSpeed = 5; //旋转速度  controls.update(); var scene = new THREE.Scene(); new THREE.RGBELoader() // .setPath(\u0026#39;assets/3d/\u0026#39;)  .load(\u0026#39;shanghai_riverside_4k.hdr\u0026#39;, function (texture) { texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = new THREE.Color(0xffffff); scene.environment = texture; const loader = new THREE.GLTFLoader() .setPath(\u0026#39;assets/models/\u0026#39;); loader.load(\u0026#39;white.glb\u0026#39;, function (gltf) { camera.position.set(4, 0.3, -1.2); gltf.scene.position.y = -1.8; scene.add(gltf.scene); var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); }); } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { glbViewer(\u0026#34;model\u0026#34;) } \u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt; function STLViewer(model, elementID) { var elem = document.getElementById(elementID) var camera = new THREE.PerspectiveCamera(70, elem.clientWidth / elem.clientHeight, 1, 1000); var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(elem.clientWidth, elem.clientHeight); elem.appendChild(renderer.domElement); window.addEventListener(\u0026#39;resize\u0026#39;, function () { renderer.setSize(elem.clientWidth, elem.clientHeight); camera.aspect = elem.clientWidth / elem.clientHeight; camera.updateProjectionMatrix(); }, false); var controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.rotateSpeed = 0.05; controls.dampingFactor = 0.1; controls.enableZoom = true; controls.autoRotate = true; //自动旋转 controls.autoRotateSpeed = .75; var scene = new THREE.Scene(); scene.add(new THREE.HemisphereLight(0xe74c3c, 1)); (new THREE.STLLoader()).load(model, function (geometry) { const material = new THREE.MeshPhysicalMaterial({ metalness: 0.25, roughness: 0.1, opacity: 1.0, transparent: true, transmission: 0.99, clearcoat: 1.0, clearcoatRoughness: 0.25 }) var mesh = new THREE.Mesh(geometry, material); scene.add(mesh); var middle = new THREE.Vector3(); geometry.computeBoundingBox(); geometry.boundingBox.getCenter(middle); mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation( -middle.x, -middle.y, -middle.z)); var largestDimension = Math.max(geometry.boundingBox.max.x, geometry.boundingBox.max.y, geometry.boundingBox.max.z) camera.position.y = -largestDimension * 1.6; var animate = function () { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }; animate(); }); } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { STLViewer(\u0026#34;exa.stl\u0026#34;, \u0026#34;model\u0026#34;) } \u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;/body\u0026gt;   参考资料 Three.js 官方文档\n如何在页面极速渲染3D模型-腾讯 ISUX 团队\nThree.js 真实渲染\n","date":"2022-07-05T17:19:43Z","image":"https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1","permalink":"https://neptoo.github.io/2022/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84three.js%E6%B8%B2%E6%9F%933d%E6%A8%A1%E5%9E%8B/","title":"从零开始的Three.js渲染3D模型"},{"content":"问题描述 如上图：el-table 最后一列设置为 fixed=\u0026quot;right\u0026quot; 后，如果页面宽度不足，数据列较多，移动底部横向滚动条，可以看到其他列和最后一列文字重叠了。\n之前的同事解决方法是设置最后一个单元格的背景色，\n1 2 3  .table-line-row td:last-child { background-color: #062462 !important; }   但是考虑到系统中表格很多，这样设置会导致其它表格的样式有点奇怪。\n解决方法 查阅了 element 文档，找到官方推荐的，通过 JS 来设置表格的样式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  \u0026lt;el-table :cell-style=\u0026#34;setCellStyle\u0026#34;\u0026gt; \u0026lt;el-table-column type=\u0026#34;index\u0026#34; align=\u0026#34;center\u0026#34; label=\u0026#34;序号\u0026#34; width=\u0026#34;80\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;!-- 省略其他列 --\u0026gt; \u0026lt;el-table-column fixed=\u0026#34;right\u0026#34; label=\u0026#34;操作\u0026#34; width=\u0026#34;180\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button size=\u0026#34;mini\u0026#34; type=\u0026#34;text\u0026#34; @click=\u0026#34;handleUpdate(scope.$index, scope.row)\u0026#34;\u0026gt; 编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button size=\u0026#34;mini\u0026#34; type=\u0026#34;text\u0026#34; @click=\u0026#34;handleDelete(scope.$index, scope.row)\u0026#34; class=\u0026#34;color-danger\u0026#34;\u0026gt; 删除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;script\u0026gt; export default{ methods: { // 防止最后一列文字重叠  setCellStyle({ row, column, rowIndex, columnIndex }){ let columns = [13]; //最后一列的索引  if (columns.indexOf(columnIndex) \u0026gt; -1) { return \u0026#34;background-color: #031337;\u0026#34;; } else { return \u0026#34;\u0026#34;; } }, } } \u0026lt;/script\u0026gt;   实现效果如上图，样式上满足了我们的需求。\n更好的解决方案 但是项目中使用的表格比较多，不同表格的列数也不等，每次手动获取最后一列的索引也比较麻烦。\n目前最佳的解决方法是：\n1 2 3 4  // 最后一列重叠问题 .tableClass .el-table__fixed-right{ background-color: #031337; }   在全局的样式文件中增加一个类，如果表格需要处理这个问题，就给el-table增加一个 class=\u0026quot;tableClass\u0026quot;。\n","date":"2022-06-08T15:58:18Z","image":"https://images.pexels.com/photos/590045/pexels-photo-590045.jpeg?auto=compress\u0026cs=tinysrgb","permalink":"https://neptoo.github.io/2022/%E8%A7%A3%E5%86%B3el-table%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%97%E6%A0%B7%E5%BC%8F%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98/","title":"解决el-table最后一列样式重叠问题"},{"content":"当需要从数据库查询的表有上万条记录的时候，将会导致查询和插入耗时太长，特别是随着数据量的增加特别明显，这时需要对于数据库查询，有很多种方法和优化的点。\n 依然是面试官系列，如何在 MySQL 中处理十万条以上数据？本来打算作为数据库笔记的附加题，查资料后发现可以延伸到很多方面。\n 分页 如果使用的ORM框架是mybatis的话，有开源的分页插件可以使用，如：Mybatis-PageHelper。如果不使用分页插件，那么就需要手动分页了，由于不同的数据库实现分页的SQL语句并不一致，如Mysql使用的是limit关键字，而Oracle使用的是rownum。首先讲讲分页操作必须满足的几个要求：一个是有序性，一个是不重复。\n普通分页 数据分页在网页中十分多见，分页一般都是limit start,offset,然后根据页码page计算start。即，limit后面的第一个参数表示下标，也就是从第10000行记录开始取，第二个参数表示总共取10行记录。\n1  select*fromuserlimit1,20  这种分页在几十万的时候分页效率就会比较低了，MySQL需要从头开始一直往后计算，这样大大影响效率。\n1 2 3  SELECT*fromuserlimit100001,20;-- time 0.151s explainSELECT*fromuserlimit100001,20;  我们可以用explain分析下语句，没有用到任何索引，MySQL执行的行数是16W+。\n优化分页 使用主键索引来优化数据分页\n1  select*fromuserwhereid\u0026gt;(selectidfromuserwhereid\u0026gt;=100000limit1)limit20;-- time 0.003s   比如我们要取的是从第10000行开始的10行记录，那么我们可以先把大于或等于10000行的数据查出来并排序，然后再取出前10行记录，这样也可以完成分页。使用这种方式，当在相邻的两页查询之间插入数据时，分页查询结果不会出现重复。\n1  explainselect*fromuserwhereid\u0026gt;(selectidfromuserwhereid\u0026gt;=100000limit1)limit20;  在数据量比较大的时候，我们尽量去利用索引来优化语句。上面的优化方法如果id不是主键索引，查询效率比第一种还要低点。我们可以先使用explain来分析语句，查看语句的执行顺序和执行性能。\n假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询：\n1  select*fromorderswheretype=2andidbetween1000000and1000100limit100;  一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。如果像是订单库等数据量非常庞大，一般会进行分库分表。先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。\n分页方案比较 MySQL分页的2种常见的方案：\n第一种是基于limit的分页方案，如：\n1  SELECT*FROM`user`ORDERBYidASCLIMIT100,10;  第二种是基于where的分页方案，如：\n1  SELECT*FROM`user`WHEREid\u0026gt;100ORDERBYidASCLIMIT10;  如果表记录数比较多，不建议使用基于limit的分页方案，而要使用基于where的分页方案。\n使用后一种方案，当在相邻的两页查询之间插入数据时，分页查询结果不会出现重复。因为虽然插入记录后，分页的结构变了，但是由于我们现在的分页查询是从固定的id开始查的，所以插入新的数据对后面的分页结果没有影响。当然，这种分页查询也是有限制的，只适用于用来排序的列具有唯一性的情况。\n 同时，我们还要确保MySQL没有开启查询缓存，否则对于同一个SQL的多次查询有可能会命中缓存，这样一来实验就没有意义了。要确认MySQL有没有开启查询缓存，只需要查询下query_cache_type参数就行了。\n 分页offset过大带来的问题 1  SELECTbFROMtWHEREc\u0026lt;1000LIMIT2000000,500  可以看到这个一个分页查询，从位置2000000处开始，取500条数据。mysql分页查询会并不是直接跳过前2000000再取出500条数据，而是把前2000000条和后面的500条都取出来，再把前2000000条抛弃，这样的话，上面的慢查询相当于从表中取2000500条数据，这么大的数据量必然会慢。\n解决方案：\n1  SELECTbFROM(SELECTaFROMtWHEREc\u0026lt;1000LIMIT2000000,500)taINNERJOINttbONta.a=tb.a  这种方式先用一个子查询表的主键（还是和原来一样带有过大分页），结果做为一个临时表，再和原来的t表JOIN，查出需要的字段。\n分表分库 分表就是将一张大表数据通过某种路由算法将数据尽可能的均匀分配到 N 张小表中。\n首先讨论下什么样的情况下适合分表？根据大佬的经验，当某张表的数据量已经达到千万甚至上亿，同时日增数据量在 2% 以上。当然这些数字并不是绝对的，最重要的还是对这张表的写入和查询都已经影响到正常业务执行，比如查询速度明显下降，数据库整体 IO 居高不下等。\n范围 首先第一种是按照范围划分，比如我们可以将某张表的创建时间按照日期划分存为月表；也可以将某张表的主键按照范围划分，比如 【1~10000】在一张表，【10001~20000】在一张表，以此类推。\n这样的分表适合需要对数据做归档处理，比如系统默认只提供近三个月历史数据的查询功能，这样也方便操作；只需要把三月之前的数据单独移走备份保存即可）。\nHash 按照日期这样的范围分表固然简单，但适用范围还是比较窄；毕竟我们大部分的数据查询都不想带上时间。比如某个用户想查询他产生的所有订单信息，这是很常见的需求。于是我们分表的维度就得改改，分表算法可以采用主流的 hash+mod 的组合。\n分表规则确定后，更麻烦的是，如何做到对业务影响最小的数据迁移。同时分表之后还需要兼容其他业务；比如原有的报表业务、分页查询等。分表完成后可以解决单表的压力，但数据库本身的压力却没有下降。将这类数据量巨大但对业务不太影响的表单独迁到一个库后，数据库的整体 IO 下降明显，业务也恢复正常。\n参考文章 「前端进阶」高性能渲染十万条数据(时间分片) （强烈推荐）\n前端如何处理十万级别的大量数据（web worker）\n一次难得的分库分表实践\n如何优雅地实现分页查询\nMySQL分页offset过大性能问题与优化\nMySQL快速插入大量数据\n","date":"2020-04-24T13:34:43Z","image":"https://neptoo.github.io/2020/%E4%BB%8E-mysql-%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%B0%88%E8%B5%B7/326502_hu3d03a01dcc18bc5be0e67db3d8d209a6_169681_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2020/%E4%BB%8E-mysql-%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%B0%88%E8%B5%B7/","title":"从 MySQL 处理大量数据谈起"},{"content":"上一篇文章中，我们只存储了查询数据的过程，也可以用存储过程来插入、删除、更新数据。\n参数验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  CREATEPROCEDUREmake_payment(invoice_idINT,payment_amountDECIMAL(9,2),-- decimal带小数点的数，参数1表示总的数字位数，参数2表示保留小数位 payment_dateDATE)BEGINIFpayment_amount\u0026lt;=0THENSIGNALSQLSTATE\u0026#39;22003\u0026#39;SETMESSAGE_TEXT=\u0026#39;Invalid payment amount.\u0026#39;;ENDIF;UPDATEinvoicesiSETi.payment_total=payment_amount,i.payment_date=payment_dateWHEREi.invoice_id=invoice_id;END  1  CALLPROCEDUREmake_payment(2,-100,\u0026#39;2019-01-01\u0026#39;)   22003是一个标准代码，代表一个数值类型数据超出了范围。👉ibm-sqlstate\n 当我们调用过程，传入非法的值，会在输出面板看到异常信息。最好在用户输入的时候提示错误，数据库数据验证是最后一道防线，为防止有人绕过了应用程序直接调用存储过程。\n输出参数 上面的实践是通过参数向过程提供参数，那么我们如何让在过程外部获得数据（指定参数）？\n1 2 3 4 5 6 7 8 9 10 11 12  CREATEPROCEDUREget_invoices_for_client(client_idINT,-- 默认是输入参数 OUTinvoice_countINT,OUTinvoices_totalDECIMAL(9,2)-- 总位数最多为9，保留两位小数 )BEGINSELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoicesiWHEREi.client_id=client_idANDpayment_total=0;END   使用输出参数读取数据有点复杂，不推荐使用。\n 变量 如上图，存储过程有输出变量的时候，通常是这样定义变量：\n1  SET@invoices_total=0  这些变量在整个客户端的生命周期中都会存在于内存中，当客户端中止与数据库的连接，变量会释放，称为用户变量（user or session variables）。\n还有一种变量称为本地变量(local variables)，通常在存储过程或者函数中定义，只要存储过程运行结束，变量就会被释放了。\n1 2 3 4 5 6 7 8 9 10 11 12 13  CREATEPROCEDUREget_risk_factorBEGINDECLARErisk_factorDECIMAL(9,2)DEFAULT0;DECLAREinvoices_countINT;DECLAREinvoices_totalDECIMAL(9,2);SELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoices;SETrisk_factor=invoices_total/invoices_count*5;SELECTrisk_factor;END   这些变量一旦声明就可以使用，一旦执行结束就会被清除。\n 函数 函数不同于存储过程的是，函数不能返回带行列的结果集，而是返回单一值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  CREATEFUNCTIONget_risk_for_client(client_idINT)RETURNINTEGERREADSQLDATA-- 从数据库读取数据; MODIFES SQL DATA修改数据 BEGINDECLARErisk_factorDECIMAL(9,2)DEFAULT0;DECLAREinvoices_countINT;DECLAREinvoices_totalDECIMAL(9,2);SELECTCOUNT(*),SUM(invoice_total)INTOinvoices_count,invoices_totalFROMinvoicesiWHEREi.client_id=client_id;SETrisk_factor=invoices_total/invoices_count*5;RETURNIFNULL(risk_factor,0);END  调用\n1  SELECTclient_id,name,get_risk_for_client(client_id)ASrisk_factorFROMclient;  删除\n1  DROPFUNCTIONIFEXISTSget_risk_for_client;  ","date":"2020-04-15T11:25:18Z","permalink":"https://neptoo.github.io/2020/mysql-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8B/","title":"MySQL 实践之存储过程（下）"},{"content":"如果你创建了一个有数据库的程序，为了方便代码管理，你最好将SQL代码放到数据库中，即存储过程或函数中。\n存储过程，就是在数据库中保存代码块的对象。然后在程序中，通过调用这些过程来获得或存入数据。\n创建 在 MySQL 中创建存储过程：\n1 2 3 4 5 6 7  DELIMITER$$CREATEPROCEDUREget_clients()BEGINSELECT*FROMclients;-- 函数体 END$$DELIMITER;  在 SQL 代码中调用存储过程：\n1  CALLget_clients()  获取发票应收款：\n1 2 3 4 5 6 7 8 9  -- 返回应收款\u0026gt;0的发票数据 DELIMITER$$CREATEPROCEDUREget_invoices_with_balance()BEGINSELECT*FROMinvoicesWHEREinvoice-payment\u0026gt;0;END$$DELIMITER;   在存储过程中，每个语句都需要用分号结尾，我们修改默认的分隔符（delimiter）之后，就可以在过程中用分号结尾。\n对于修改默认的分隔符，每个团队有不同的习惯，有的喜欢DELIMETER $$，有的喜欢DELIMETER //，以公司规范为准。\n 删除存储过程：\n1  DROPPROCEDUREIFEXISTSget_clients  传参 在存储过程中添加参数：\n1 2 3 4 5 6 7 8  -- 通过city获取用户 DELIMITER$$CREATEPROCEDUREget_clients_by_city(countryCHAR(2),cityCHAR(2))BEGINSELECT*FROMclientscWHEREc.city=cityandc.country=country;-- 给表名一个别名，区分表格中与传入的 END$$DELIMITER;  1  CALLPROCEDUREget_clients_by_city(\u0026#39;US\u0026#39;,\u0026#39;LA\u0026#39;)   char 字符串；varchar 可变长度的字符串，如姓名，电话等。\n 练习：通过客户 id 获取发票\n1 2 3 4 5 6 7 8  CREATEPROCEDUREget_invoices_by_client(client_idINT)BEGINSELECT*FROMinvoicesiWHEREi.client_id=client_id;END  默认值 1 2 3 4 5 6 7 8 9  CREATEPROCEDUREget_clients_by_city(countryCHAR(2))BEGINIFcountryISNULLTHENSETcountry=\u0026#39;CH\u0026#39;;ENDIF;SELECT*FROMclientscWHEREc.country=country;END  调用：\n1 2  CALLPROCEDUREget_clients_by_city(NULL)-- 如果括号里为空，会报错   如果不想传入指定值，而是进行其他操作。\n1 2 3 4 5 6 7 8 9  CREATEPROCEDUREget_clients_by_city(countryCHAR(2))BEGINIFcountryISNULLTHENSELECT*FROMclients;ELSESELECT*FROMclientscWHEREc.country=country;ENDIF;END  练习：Write a procedure called get_payments with two parameters.\n 如果只传入0个参数，返回全部消费记录；如果传入第一个参数，返回指定客户的消费记录；传入两个参数，返回指定客户在指定平台的消费记录。\n 1 2 3 4 5 6 7 8 9 10 11  CREATEPROCEDUREget_payments(client_idINT,payment_method_idTINYINT-- 0-255 )BEGINSELECT*FROMpaymentspWHEREp.client_id=IFNULL(client_id,p.client_id)ANDp.payment_method=IFNULL(payment_method,p.payment_method);END  1 2 3 4  CALLPROCEDUREget_payments(NULL,NULL)-- CALL PROCEDURE get_payments(5, NULL) -- CALL PROCEDURE get_payments(NULL, 2) -- CALL PROCEDURE get_payments(5, 2)   ","date":"2020-03-29T19:25:44Z","permalink":"https://neptoo.github.io/2020/mysql-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8A/","title":"MySQL 实践之存储过程（上）"},{"content":"React16 学习第二篇，分享自己总结的学习笔记以及需要注意的点。\nJSX 防止踩坑  在 JSX 中使用 样式，用 className 而不是 class dangerouslySetInnerHTML 添加 HTML 解析  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  import React,{Component, Fragment} from \u0026#39;react\u0026#39; import \u0026#39;./style.css\u0026#39; class List extends Component{ constructor(props){ super(props) this.state = { inputValue: \u0026#39;default\u0026#39;, list: [\u0026#39;Sing\u0026#39;,\u0026#39;Dance\u0026#39;,\u0026#39;Basketball\u0026#39;] } } render(){ return ( \u0026lt;Fragment\u0026gt; \u0026lt;input value={this.state.inputValue} onChange={this.inputChange.bind(this)} className=\u0026#39;inp\u0026#39; /\u0026gt; \u0026lt;button onClick={this.addContent.bind(this)}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; { this.state.list.map((item,index)=\u0026gt;{ return \u0026lt;li key={item+index} onClick={this.deleteItem.bind(this,index)} dangerouslySetInnerHTML={{__html:item}} \u0026gt; \u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; ) } inputChange(e){ this.setState({ inputValue: e.target.value }) } addContent(){ this.setState({ list: [...this.state.list, this.state.inputValue], inputValue: \u0026#39;\u0026#39; }) } } export default List   父子组件传值 父组件向子组件传值：属性传值，子组件使用 props 进行接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  {/* 父组件List */} \u0026lt;Fragment\u0026gt; \u0026lt;label htmlFor=\u0026#34;inputId\u0026#34;\u0026gt;Add Skills:\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input id=\u0026#34;inputId\u0026#34; value={this.state.inputValue} onChange={this.inputChange.bind(this)} className=\u0026#39;inp\u0026#39; /\u0026gt; \u0026lt;button onClick={this.addContent.bind(this)}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; { this.state.list.map((item,index)=\u0026gt;{ return ( \u0026lt;div\u0026gt; {/* 自定义属性 */} \u0026lt;Skill content={item} /\u0026gt; \u0026lt;/div\u0026gt; ) }) } \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt;   1 2 3 4 5 6 7 8 9 10  {/* 子组件Skill */} import React, { Component } from \u0026#39;react\u0026#39;; class Skill extends Component { render() { return ( \u0026lt;li\u0026gt;{ this.props.content }\u0026lt;/li\u0026gt; ); } } export default Skill;   子组件\u0026quot;操作\u0026quot;父组件的数据：不能直接操作，应该用传值的方式将父组件的方法传递给子组件，再进行操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  {/* 父组件List */} \u0026lt;Fragment\u0026gt; \u0026lt;label htmlFor=\u0026#34;inputId\u0026#34;\u0026gt;Add Skills:\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input id=\u0026#34;inputId\u0026#34; value={this.state.inputValue} onChange={this.inputChange.bind(this)} className=\u0026#39;inp\u0026#39; /\u0026gt; \u0026lt;button onClick={this.addContent.bind(this)}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; { this.state.list.map((item,index)=\u0026gt;{ return ( \u0026lt;Skill content={item} key={item+index} idx={index} deleteItem={this.deleteItem.bind(this)} /\u0026gt; ) }) } \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; {/* ... */} // 删除列表项  deleteItem(index){ // console.log(index)  // 不能直接操作 state 里的值 需要赋值给一个局部变量 再操作  let list = this.state.list list.splice(index,1) this.setState({ list: list }) }   ","date":"2020-02-27T17:54:10Z","permalink":"https://neptoo.github.io/2020/react-16-%E4%B9%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/","title":"React 16 之父子组件传值"},{"content":"React16 学习第一篇，分享自己总结的学习笔记以及需要注意的点。\n开发环境搭建 1  npm i -g create-react-app    如果网络不好，推荐使用淘宝镜像 cnpm 安装。\n 1  create-react-app demo1   React 实例 删除 src 下文件，从零开始写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import React,{Component, Fragment} from \u0026#39;react\u0026#39; class List extends Component{ render(){ return ( \u0026lt;Fragment\u0026gt; \u0026lt;input /\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1.Create\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2.Modify\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3.Upload\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; ) } } export default List   \u0026lt;Fragment\u0026gt;可以让组件返回一系列元素，不用添加额外的 Dom 节点。\n事件绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  import React,{Component, Fragment} from \u0026#39;react\u0026#39; class List extends Component{ constructor(props){ super(props) this.state = { inputValue: \u0026#39;default\u0026#39;, list: [\u0026#39;Sing\u0026#39;,\u0026#39;Dance\u0026#39;,\u0026#39;Basketball\u0026#39;] } } render(){ return ( \u0026lt;Fragment\u0026gt; {/* 绑定 this */} {/* 绑定事件需要用驼峰命名法 */} \u0026lt;input value={this.state.inputValue} onChange={this.inputChange.bind(this)} /\u0026gt; \u0026lt;button onClick={this.addContent.bind(this)}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; { this.state.list.map((item,index)=\u0026gt;{ // 绑定 this 和 index  return \u0026lt;li key={item+index} onClick={this.deleteItem.bind(this,index)}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; ) } inputChange(e){ this.setState({ inputValue: e.target.value }) } addContent(){ this.setState({ list: [...this.state.list, this.state.inputValue], inputValue: \u0026#39;\u0026#39; }) } // 删除列表项  deleteItem(index){ // console.log(index)  // 不能直接操作 state 里的值 需要赋值给一个局部变量 再操作  let list = this.state.list list.splice(index,1) this.setState({ list: list }) } } export default List   ","date":"2020-02-26T18:21:30Z","image":"https://neptoo.github.io/2020/react-16-%E4%B9%8B%E5%AE%9E%E4%BE%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/react_huee4b577817e89283bceb68ee1366e7dd_341486_120x120_fill_box_smart1_3.png","permalink":"https://neptoo.github.io/2020/react-16-%E4%B9%8B%E5%AE%9E%E4%BE%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/","title":"React 16 之实例那些事"},{"content":"Ajax 是浏览器提供的一套 API，可以通过JavaScript 调用，从而实现通过代码的方式控制请求与响应，进行网络编程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // XMLHttpRequest——Ajax核心 // xhr就类似于浏览器（发送请求接收响应） // 1.安装浏览器（用户代理） var xhr = new XMLHttpRequest() // 2.打开浏览器，输入网址 xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://www.abc.net/admanage.php?jsonpCallback=aa\u0026amp;action=getList\u0026#39;) // 3.回车，发送请求 xhr.send() // 4.等待响应（响应需要时间，无法通过返回值的方式返回响应） // 因为客户端永远不知道服务端何时才能返回我们需要的响应 // 所以 AJAX 采用事件的机制处理  // xhr.onreadystatechange = function(){} 下面的方法注册更优化 xhr.addEventListener(\u0026#39;readystatechange\u0026#39;, function(){ // xhr状态改变的时候触发事件  // console.log(this.readyState)  // 2 3 4 如果需要捕获第一个状态 需要注意代码执行顺序  if(xhr.readyState!==4) return // 获取响应体  console.log(this.responseText) }) // 5。查看结果   readyState 状态变化 1 2 3 4 5 6 7 8 9 10 11 12 13 14  var xhr = new XMLHttpRequest() console.log(xhr.readyState) // 0 =\u0026gt; 初始化请求代理对象 unsent xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;./article.php\u0026#39;) console.log(xhr.readyState) // 1 =\u0026gt; open()已调用，建立起与服务端端口的连接 opened xhr.send() xhr.addEventListener(\u0026#39;readystate\u0026#39;, function(){ console.log(this.readyState) // 2 =\u0026gt; 已经接收到响应报文的响应头 headers_received  // console.log(this.getAllResponseHeaders().split(\u0026#39;\\n\u0026#39;))  // console.log(this.getAllResponseHeaders(\u0026#39;server\u0026#39;))  // 3=\u0026gt;正在下载loading, 4 =\u0026gt;可以拿到整个响应报文 done })   onload 兼容 1 2 3 4 5 6 7 8 9 10  var xhr = new XMLHttpRequest() xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;/a.php\u0026#39;) xhr.send(null) xhr.onload = function(){ console.log(this.readyState) // always 4 =\u0026gt;  // xhr.onreadystatechange = function(){ if(readyState === 4){...} }  console.log(this.responseText) } // onload 是 HTML5 新提供的API   遵循HTTP协议 1 2 3 4 5 6  var xhr = new XMLHttpRequest() xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;/add.php\u0026#39;) xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;) xhr.send(\u0026#39;key1=value1\u0026amp;key2=value2\u0026#39;) // 请求头的 Content-Type 需要跟随请求体的内容格式变化 // xhr.send(\u0026#39;{\u0026#34;foo\u0026#34;:\u0026#34;123\u0026#34;}\u0026#39;) =\u0026gt; \u0026#39;application/json\u0026#39;   ","date":"2020-02-25T19:43:18Z","image":"https://neptoo.github.io/2020/ajax-%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93%E4%B8%80/ajax_hucdb7eb08be7cbdbbbd6a4d2a641e5e53_96170_120x120_fill_q75_box_smart1.jpeg","permalink":"https://neptoo.github.io/2020/ajax-%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93%E4%B8%80/","title":"Ajax - 基础小结（一）"},{"content":" 本文主要是作为Promise面试常用知识梳理。如有错误或建议，欢迎指出，将在第一时间改进。\n最近，一些笔记知识改在Github Issues更新了，欢迎 star, comment, folow 。\n 概念 JS是单线程，浏览器是多线程，需要事件循环去决定异步操作(定时器、请求、事件监听等)事件的顺序。使用回调函数处理异步，你不知道第三方库到底会怎么执行回调（多次执行），以及在回调函数中再嵌套回调函数会导致代码非常难以维护。\n针对回调函数的缺点，ES6引入Promise对象。\n 引入链式调用，每个then方法同样也是一个Promise。 Promise的then方法会接受2个函数，一个是被resolve时执行的回调，另一个是被reject时执行的回调。 Promise所有响应的处理回调都是异步调用的，不会阻塞代码的执行，Promise将then方法的回调放入一个叫微任务的队列中（MicroTask），确保这些回调任务在同步任务执行完以后再执行。  用法 一个异步加载图片的例子\n1 2 3 4 5 6 7 8 9 10 11 12  function loadImageAsync(url){ return new Promise(function(resolve, reject){ const image = new Image(); image.onload = function(){ resolve(image); }; image.onerror = function(){ reject(new Error(\u0026#39;can not load image at\u0026#39; + url)); }; image.src = url; }); }    Image() 方法会创建一个新的HTML Image Element对象\n 方法 Promise.prototype.then() then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。\nthen的链式写法\n1 2 3 4 5 6  getJSON(\u0026#34;/post/1.json\u0026#34;).then( post =\u0026gt; getJSON(post.commentURL) ).then( comments =\u0026gt; (\u0026#34;resolved: \u0026#34;, comments), err =\u0026gt; (\u0026#34;rejected: \u0026#34;, err) );   then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。\nPromise.prototype.catch() 1 2 3 4 5 6 7  promise .then((data) =\u0026gt; { console.log(\u0026#39;resolved\u0026#39;,data); }) .catch((err) =\u0026gt; { console.log(\u0026#39;rejected\u0026#39;,err); });   1 2 3 4 5 6  const promise = new Promise(function(resolve, reject) { reject(new Error(\u0026#39;test\u0026#39;)); }); promise.catch(function(error) { console.log(error); });   Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。一般 Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。\nPromise.prototype.finally() finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES9 引入标准的。\n1 2 3 4 5  server.listen(port) .then(function () { // ...  }) .finally(server.stop); // 最后关掉服务器   Promise.all() Promise的all方法一般接收一个数组参数，里面的值最终都算返回Promise对象，并且在所有异步操作执行完后才执行回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;hello\u0026#39;); }) .then(result =\u0026gt; result) .catch(e =\u0026gt; e); const p2 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;报错了\u0026#39;); }) .then(result =\u0026gt; result) .catch(e =\u0026gt; e); Promise.all([p1, p2]) .then(result =\u0026gt; console.log(result)) .catch(e =\u0026gt; console.log(e)); // [\u0026#34;hello\u0026#34;, Error: 报错了]   如果p2没有自己的catch方法，才会调用Promise.all()的catch方法。\nPromise.race() Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //请求某个图片资源  function requestImg(){ var p = new Promise((resolve, reject) =\u0026gt; { var img = new Image(); img.onload = function(){ resolve(img); } img.src = \u0026#39;图片的路径\u0026#39;; }); return p; } //延时函数，用于给请求计时  function timeout(){ var p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(\u0026#39;图片请求超时\u0026#39;); }, 5000); }); return p; } Promise.race([requestImg(), timeout()]).then((data) =\u0026gt;{ console.log(data); }).catch((err) =\u0026gt; { console.log(err); });   Promise.resolve()  参数是一个 Promise 实例，不做任何修改、原封不动地返回这个实例。 参数是一个原始值，或者是一个不具有then方法的对象，则返回一个新的 Promise 对象，状态为resolved。 参数是一个具有then方法的对象，会将这个对象转为 Promise 对象，然后立即执行then方法。  1 2 3 4 5 6 7 8 9 10  let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 });   Promise.reject() 把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let p = new Promise((resolve, reject) =\u0026gt; { // Promise构造函数接收一个函数作为参数  //做一些异步操作  setTimeout(function() { var num = Math.ceil(Math.random() * 10); //生成1-10的随机数  if (num \u0026lt;= 5) { resolve(num); } else { reject(\u0026#39;数字太大了\u0026#39;); } }, 2000); }); p.then((data) =\u0026gt; { console.log(\u0026#39;resolved\u0026#39;, data); }, (err) =\u0026gt; { console.log(\u0026#39;rejected\u0026#39;, err); });   推荐文章 Promise 对象-by阮一峰\n近一万字的ES6语法知识点补充\nPromise的源码实现（完美符合Promise/A+规范）\n","date":"2019-09-21T16:07:24Z","permalink":"https://neptoo.github.io/2019/%E9%87%8D%E5%AD%A6es6%E4%B9%8Bpromise/","title":"重学ES6之Promise"},{"content":"初中级前端工程必须掌握的CSS基础知识——布局。\n话题起源  如何实现两列布局-左边固定，右边自适应？  1 2 3 4 5 6 7 8 9 10 11 12  .wrapper-flex { display: flex; align-items: flex-start; } .wrapper-flex .left { flex: 0 0 auto; } .wrapper-flex .right { flex: 1 1 auto; }   创建flex布局 元素设置display: flex; 或者 display: inline-flex;\n属性    作用在flex容器上 作用在flex子项上     flex-direction order   flex-wrap flex-grow   flex-flow flex-shrink   justify-content flex-basis   align-items flex   align-content align-self    flex容器默认有两根轴，主轴和侧轴，默认情况下主轴为水平分布，但可以通过flex-direction来改变主侧轴的分布方向。\n1  flex-direction: row | row-reverse | column | column-reverse;/*显示为行|行反向|显示为列|反向*/   1  flex-wrap: nowrap | wrap | wrap-reverse; /*不换行|换行|换行到上方*/   1  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; /*水平方向子项的分布:左对齐|右对齐|居中|两端对齐|边缘空白相等|子项等间距*/   1 2  align-items: stretch | flex-start | flex-end | center | baseline; /*拉伸|顶部对齐|底部对齐|垂直居中|第一行文字基线对齐*/   1  align-content: stretch | flex-start | flex-end | center | space-between | space-around | space-evenly; /*多行对齐方式：拉伸|顶部堆放|底部堆放|整体垂直居中|上下两端对齐|两侧间隔相等|上下等分*/   1  order: -1 | 0 | 1; /*整数值：该子项在最前面|默认|最后面*/   1  flex-grow: 0.5| 1 | 2; /*正数：扩展剩余空间总量的一半|剩余空间|同1*/   1  flex-shrink: \u0026lt;number\u0026gt;; /* 单个元素收缩比例，数值，默认值是 1 */   1 2  align-self: auto | flex-start | flex-end | center | baseline | stretch; /*子项的垂直对齐方式*/   参考资料 flex在线练习小游戏\n写给自己看的display: flex布局教程\n写在结尾 昨天和timing的前端面试官聊了半小时左右，发现一些前端基础忘得差不多，写几篇博客学习和巩固。\n 重学CSS之定位 重学CSS之浮动 重学CSS之grid布局  ","date":"2019-08-31T17:41:57Z","image":"https://neptoo.github.io/2019/%E9%87%8D%E5%AD%A6css%E4%B9%8Bflex%E5%B8%83%E5%B1%80/flex_hu758da22b4ab034afc2963ec670a0d253_99343_120x120_fill_box_smart1_3.png","permalink":"https://neptoo.github.io/2019/%E9%87%8D%E5%AD%A6css%E4%B9%8Bflex%E5%B8%83%E5%B1%80/","title":"重学CSS之flex布局"},{"content":"针对初中级前端，总结了自己的几场面试中，容易遗忘的知识点，希望对准备跳槽或者正在跳槽中的小伙伴有所帮助。\nVue   生命周期\n创建前/后: 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。\n挂载前/后: 在beforeMount阶段，vue实例的el和data都初始化了，但还是虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。\n更新前/后: 当data变化时，会触发beforeUpdate和updated方法。\n销毁前/后: 在执行destroy方法后，vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。\n  组件传值\n 父组件传给子组件：子组件通过props接收参数 子组件传给父组件： $emit 方法传递参数 非父子间的数据传递: eventBus创建事件中心，用来传递和接收事件    Vue计算属性computed和侦听属性watch\n computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。    CSS   三角形\n1 2 3 4 5 6 7  .triangle { /*顶点朝上的三角形*/ width: 0px; height: 0px; border: 40px solid; border-color: transparent transparent red transparent; }     省略号\n1 2 3 4 5 6 7  /*文本超出显示...*/ .line { max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }     动画\n1 2 3 4 5  div{ animation: mymove 2s linear 3 alternate both; /* name duration timing-function count direction */ } @keyframes mymove{ /*...*/ }     阴影\n1 2 3 4  div { box-shadow: 10px 10px 5px #888888; /*h-shadow v-shadow spread color inset;*/ }     JS   ajax跨域\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 1.创建XMLHttpRequest对象 var xhr; if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject(\u0026#34;Microsoft XMLHTTP\u0026#34;); } // 2.连接服务器 xhr.open(\u0026#34;post\u0026#34;, url.true); // 3.创建新的http请求 并指定请求的类型和验证信息 xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); // 4.设置响应请求状态变化的函数 xhr.onreadystatechange = function() { if (xhr.readyState == 4 \u0026amp;\u0026amp; (xhr.status == 200 || xhr.status == 304)) { fn.call(this, xhr.responseText); } }; // 5.发送请求 xhr.send(data);     HTTP 从输入url到页面呈现\n1.DNS查询\n 首先查看浏览器缓存，没有缓存就发送请求，有缓存就检验是否足够新鲜；在发送http请求前，需要DNS域名解析获取相应的IP地址。\n 2.三次握手建立连接\n3.完成握手，建立http连接\n 使用https的网站还需要进行SSL/TSL握手\n 4.服务器检验http header 足够新鲜返回304\n5.浏览器接受请求，根据情况选择关闭TCP连接或保留复用，断开连接四次挥手\n6.检查状态码\n7.如资源可缓存，进行缓存\n8.GZIP解码\n9.解析HTML文档(DOM、CSSOM、构建渲染树、布局绘制)\n","date":"2019-08-29T13:00:58Z","permalink":"https://neptoo.github.io/2019/%E5%88%9D%E4%B8%AD%E7%BA%A7%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/","title":"初中级前端面试系列"},{"content":"毕业设计最终项目成果展示：点击查看\n基础配置 安装ECharts依赖 1  npm install echarts -S   全局引入  main.js  1 2 3  // 引入echarts import echarts from \u0026#39;echarts\u0026#39; Vue.prototype.$echarts = echarts   页面框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;8\u0026#34; :lg=\u0026#34;8\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;degreeChart\u0026gt;\u0026lt;/degreeChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;16\u0026#34; :lg=\u0026#34;16\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;moneyLine\u0026gt;\u0026lt;/moneyLine\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;12\u0026#34; :lg=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;cityChart\u0026gt;\u0026lt;/cityChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;24\u0026#34; :sm=\u0026#34;24\u0026#34; :md=\u0026#34;12\u0026#34; :lg=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;el-card class=\u0026#34;box-card\u0026#34;\u0026gt; \u0026lt;funnelChart\u0026gt;\u0026lt;/funnelChart\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import degreeChart from \u0026#39;../charts/degreeChart.vue\u0026#39;; import moneyLine from \u0026#39;../charts/moneyLine.vue\u0026#39;; import cityChart from \u0026#39;../charts/cityChart.vue\u0026#39;; import funnelChart from \u0026#39;../charts/funnelChart.vue\u0026#39;; export default { components:{ degreeChart,moneyLine,cityChart,funnelChart }, methods: { } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt;   在index.js中引入文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import AmCharts from \u0026#39;@/components/page/BasicCharts\u0026#39;; Vue.use(Router) export default new Router({ mode: \u0026#39;history\u0026#39;, base: __dirname, routes: [ { path: \u0026#39;/\u0026#39;, component: Home, children: [{ path: \u0026#39;\u0026#39;, component: DashBoard }, { path: \u0026#39;/DashBoard\u0026#39;, component: DashBoard }, { path: \u0026#39;/BasicCharts\u0026#39;, component: AmCharts }, { path: \u0026#39;/TodoList\u0026#39;, component: TodoList }] } ] })   ECharts地图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;echarts\u0026#34;\u0026gt; \u0026lt;div :style=\u0026#34;{height:\u0026#39;400px\u0026#39;,width:\u0026#39;100%\u0026#39;}\u0026#34; ref=\u0026#34;myEchart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var echarts = require(\u0026#39;echarts/lib/echarts\u0026#39;) require(\u0026#39;echarts/map/js/china\u0026#39;) export default { name: \u0026#34;echarts\u0026#34;, props: [\u0026#34;userJson\u0026#34;], data() { return { chart: null }; }, mounted() { this.chinaConfigure(); }, beforeDestroy() { if (!this.chart) { return; } this.chart.dispose(); this.chart = null; }, methods: { chinaConfigure() { let myChart = echarts.init(this.$refs.myEchart); //这里是为了获得容器所在位置  window.onresize = myChart.resize; myChart.setOption({ // 进行相关配置  // backgroundColor: \u0026#34;#02AFDB\u0026#34;,  title: { text: \u0026#34;城市岗位分布\u0026#34;, x: \u0026#39;center\u0026#39;, textStyle: { color: \u0026#34;#777\u0026#34;, fontWeight:\u0026#39;500\u0026#39;, fontSize:16 } }, tooltip: {}, // 鼠标移到图里面的浮动提示框  dataRange: { show: false, min: 0, max: 1000, text: [\u0026#39;High\u0026#39;, \u0026#39;Low\u0026#39;], realtime: true, calculable: true, color: [\u0026#39;#FA8BFF\u0026#39;, \u0026#39;#2BFF88\u0026#39;, \u0026#39;#2BD2FF\u0026#39;] }, geo: { // 这个是重点配置区  map: \u0026#39;china\u0026#39;, // 表示中国地图  roam: false, // 是否允许缩放  label: { normal: { show: true, // 是否显示对应地名  textStyle: { color: \u0026#39;rgba(0,0,0,0.4)\u0026#39; } } }, itemStyle: { normal: { borderColor: \u0026#39;rgba(0, 0, 0, 0.2)\u0026#39;, areaColor: \u0026#39;#BBE4E9\u0026#39; }, emphasis: { areaColor: null, shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 20, borderWidth: 0, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } }, series: [{ type: \u0026#39;scatter\u0026#39;, coordinateSystem: \u0026#39;geo\u0026#39; // 对应上方配置  }, { name: \u0026#39;发布职位\u0026#39;, // 浮动框的标题  type: \u0026#39;map\u0026#39;, geoIndex: 0, data: [{ \u0026#34;name\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;value\u0026#34;: 232 }, { \u0026#34;name\u0026#34;: \u0026#34;广东\u0026#34;, \u0026#34;value\u0026#34;: 318 }, { \u0026#34;name\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;value\u0026#34;: 120 }, { \u0026#34;name\u0026#34;: \u0026#34;浙江\u0026#34;, \u0026#34;value\u0026#34;: 84 }, , { \u0026#34;name\u0026#34;: \u0026#34;四川\u0026#34;, \u0026#34;value\u0026#34;: 46 }, { \u0026#34;name\u0026#34;: \u0026#34;湖北\u0026#34;, \u0026#34;value\u0026#34;: 24 }, { \u0026#34;name\u0026#34;: \u0026#34;重庆\u0026#34;, \u0026#34;value\u0026#34;: 20 }, { \u0026#34;name\u0026#34;: \u0026#34;陕西\u0026#34;, \u0026#34;value\u0026#34;: 18 }, { \u0026#34;name\u0026#34;: \u0026#34;江苏\u0026#34;, \u0026#34;value\u0026#34;: 8 }, { \u0026#34;name\u0026#34;: \u0026#34;福建\u0026#34;, \u0026#34;value\u0026#34;: 20 }, { \u0026#34;name\u0026#34;: \u0026#34;辽宁\u0026#34;, \u0026#34;value\u0026#34;: 6 }, { \u0026#34;name\u0026#34;: \u0026#34;天津\u0026#34;, \u0026#34;value\u0026#34;: 4 }, { \u0026#34;name\u0026#34;: \u0026#34;云南\u0026#34;, \u0026#34;value\u0026#34;: 2 }, { \u0026#34;name\u0026#34;: \u0026#34;广西\u0026#34;, \u0026#34;value\u0026#34;: 2 }] } ] }) } } } \u0026lt;/script\u0026gt;   遇到的问题 横坐标轴文字过长不能完全显示\n 方法1：文字竖直显示  1 2 3 4 5 6 7 8 9 10 11 12 13 14  xAxis: [{ type: \u0026#39;category\u0026#39;, data: [\u0026#39;应届生\u0026#39;, \u0026#39;1年以内\u0026#39;, \u0026#39;1-3年\u0026#39;, \u0026#39;3-5年\u0026#39;, \u0026#39;5-10年\u0026#39;, \u0026#39;10年以上\u0026#39;, \u0026#39;不限\u0026#39;], axisTick: { alignWithLabel: true }, axisLabel: { interval: 0, rotate: -40 formatter: function(value) { //竖直显示  return value.split(\u0026#34;\u0026#34;).join(\u0026#34;\\n\u0026#34;); } } }]    方法2：项目类别间隔显示  1 2 3 4 5 6 7 8 9 10  axisLabel: { interval: 0, formatter: function(params, index) { //隔一行显示  if (index % 2 != 0) { return \u0026#39;\\n\\n\u0026#39; + params; } else { return params; } } }   ","date":"2019-06-30T12:09:22Z","image":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Bvue-elementui-echarts%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/grad_hue107c7b1a91e92072550f51cdf01b031_197868_120x120_fill_box_smart1_3.png","permalink":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Bvue-elementui-echarts%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","title":"毕业设计(下):Vue+ElementUI+ECharts实现前端数据可视化"},{"content":"毕业设计主题是数据可视化，选择的技术栈是Vue2.0，数据库选的是MySQL，首先需要解决的就是前端连接数据库的问题。 本文基于前端网站连接MySQL数据库和Node+Mysql+Vue实现登录注册功能，手把手教你使用前端连接数据库，实现增删改查。\n项目初始化  使用vue-cli搭建一个基于webpack的vue2.0项目，使用脚手架生成项目框架。 安装mysql数据库，附上mysql安装教程，然后安装navicat for mysql，推荐使用mysql的图形化界面管理数据库。  添加服务端目录 在项目根目录下新建server文件夹，目录结构如下\n1 2 3 4 5 6 7  |-- server |-- api // 与数据库的各个表连接接口 |-- userApi.js |-- hireApi.js |-- db.js // mysql数据库连接配置 |-- index.js // Express服务器入口文件 |-- sqlMap.js   db.js为mysql数据库基本配置信息，index.js用来定义与监听后端服务器，sqlMap.js是SQL语句映射文件，以供api逻辑调用。原代码基本上无需更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // sqlMap.js var sqlMap = { // 用户  user: { add: \u0026#39;insert into user(id, username, password) values (0, ?, ?)\u0026#39;, select_name: \u0026#39;SELECT * from user where username = ?\u0026#39;, //查询 username  select_password: \u0026#39;SELECT * from user where password = ?\u0026#39; //查询 password  }, // 招聘  hire: { add: \u0026#39;insert into hire(hire_id, title, money, degree, exp, site, time, addr) values (0, ?, ?, ?, ?, ?, ?, ?)\u0026#39;, getAll: \u0026#39;SELECT * from hire\u0026#39;, search: \u0026#39;select * from hire where title = ?\u0026#39;, update: \u0026#39;update hire set title = ? where hire_id = ?\u0026#39; } } module.exports = sqlMap;   代理与跨域 设置地址映射表，修改项目配置文件index.js中的proxyTable参数\n1 2 3 4 5 6 7 8 9 10 11 12 13  dev:{ // ...  proxyTable: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://127.0.0.1:3000/api/\u0026#39;, changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; } } }, // ... }   数据库表连接入口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  // hireUpi.js var models = require(\u0026#39;../db\u0026#39;); var express = require(\u0026#39;express\u0026#39;); var router = express.Router(); var mysql = require(\u0026#39;mysql\u0026#39;); var $sql = require(\u0026#39;../sqlMap\u0026#39;); // 连接数据库 var conn = mysql.createConnection(models.mysql); conn.connect(); var jsonWrite = function(res, ret) { if (typeof ret === \u0026#39;undefined\u0026#39;) { res.send(\u0026#39;err\u0026#39;) } else { //res.json(ret);  res.send(\u0026#39;ok\u0026#39;) } }; // 增加 router.post(\u0026#39;/addList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.add var params = req.body conn.query(sql, [params.title, params.money, params.degree, params.exp, params.site, params.time, params.addr], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) // 更新 router.post(\u0026#39;/updateList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.update var params = req.body conn.query(sql, [params.title, params.hire_id], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) //查找 router.get(\u0026#39;/searchList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.search var params = req.query console.log(params) conn.query(sql, [params.title], function (err, result) { if (err) { console.log(err) } if (result) { console.log(result) res.send(result) } }) }) // 获取所有list router.get(\u0026#39;/getAllList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.getAll var params = req.query conn.query(sql, function(err, result) { if (err) { console.log(err) } if (result) { console.log(result) res.send(result) } }) }) // 删除 router.post(\u0026#39;/delList\u0026#39;, (req, res) =\u0026gt; { var sql = $sql.hire.del var params = req.body conn.query(sql, [params.hire_id], function (err, result) { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) module.exports = router;   数据测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // editTable.vue \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;handleAdd\u0026#34;\u0026gt;新增\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;!--列表--\u0026gt; \u0026lt;el-table\u0026gt; \u0026lt;el-table-column type=\u0026#34;selection\u0026#34; width=\u0026#34;55\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;title\u0026#34; label=\u0026#34;岗位名称\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!--编辑界面--\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogFormVisible\u0026#34; @click=\u0026#34;dialogFormVisible=false\u0026#34;\u0026gt; \u0026lt;el-form label-width=\u0026#34;80px\u0026#34; :model=\u0026#34;editForm\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;岗位名称\u0026#34; prop=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;editForm.title\u0026#34; placeholder=\u0026#34;请输入岗位名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34; class=\u0026#34;dialog-footer\u0026#34;\u0026gt; \u0026lt;el-button @click.native=\u0026#34;dialogFormVisible=false\u0026#34;\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-if=\u0026#34;dialogStatus==\u0026#39;create\u0026#39;\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;addList\u0026#34;\u0026gt;添加\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else type=\u0026#34;primary\u0026#34; @click=\u0026#34;updateList\u0026#34;\u0026gt;修改\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/el-dialog\u0026gt; // ... \u0026lt;script\u0026gt; methods: { handleAdd: function() { this.dialogFormVisible = true; // 新增时清空  this.editForm = { title: \u0026#39;\u0026#39; } }, // 添加  addList() { var title = this.editForm.title axios.post(\u0026#39;/api/hire/addList\u0026#39;, { title: title }).then(function(response) { alert(\u0026#39;成功录入\u0026#39; + title + \u0026#39;\u0026#39;) this.dialogFormVisible = false }).catch(function(error) { console.log(error) }) }, // 更改  updateList() { var title = this.editForm.title var hire_id = this.editForm.hire_id axios.post(\u0026#39;/api/hire/updateList\u0026#39;, { title: title, hire_id: hire_id }).then(function(response) { alert(\u0026#39;成功更新\u0026#39; + title + \u0026#39;\u0026#39;) this.dialogFormVisible = false }).catch(function(error) { console.log(error) }) } } \u0026lt;/script\u0026gt;   启动 编写完成后，安装相应的依赖npm install express mysql body-parser 在系统中找到\u0026quot;服务\u0026quot;，将快捷方式发送到桌面。打开services.msc，找到mysql更改为手动启动，调试时候选择启动或停止服务。 开启mysql服务后，在server文件夹下执行node index，看到success listen at port:3000......即服务端启动成功。 在项目根目录下，npm run dev启动web服务器。\n其它 设计数据库表时候，录入字段为中文，出现乱码，解决方法：修改数据库和数据表的编码规则。\n1 2  show creat database test; ALTER DATABASE test DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;   1 2  ALTER TABLE test.hire CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; show create table test.hire;   删除数据清空自增ID\n1  truncate table test.company;   参考 [1]前端网站连接MySQL数据库\n[2]Node+Mysql+Vue实现登录注册功能\n[3]Vue+MySQL+Express小试牛刀\n[4]项目完整代码\n","date":"2019-06-24T16:46:45Z","permalink":"https://neptoo.github.io/2019/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E4%B8%8Avue-mysql%E5%89%8D%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"毕业设计(上):Vue+MySQL前端连接数据库实现表格增删改查"},{"content":"换了新电脑，重新配置hexo博客：\n1 2 3  npm install hexo-cli -g npm install hexo --save npm install hexo-deployer-git --save   然后push代码，报错git@github.com: Permission denied，大意是git没有权限。\n打开git bash，解决过程： 1.查看是否已经有了ssh密钥：\n1  cd ~/.ssh   2.生成密钥：\n1  ssh-keygen -t rsa -C \u0026#34;neptoo57@gmail.com\u0026#34;   按3个回车，密码为空。 3.将本地生成的id_rsa.pub添加到github的新ssh密钥 4.测试\n1  ssh git@github.com   提示\n1 2 3  PTY allocation request failed on channel 0 Hi neptoo! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed.   5.配置\n1 2  git config --global user.name \u0026#34;example\u0026#34; git config --global user.email \u0026#34;example@gmail.com\u0026#34;   问题解决，可以使用更新博客了。\n","date":"2019-05-01T22:12:27Z","permalink":"https://neptoo.github.io/2019/%E8%A7%A3%E5%86%B3git%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E9%97%AE%E9%A2%98/","title":"解决git身份验证的问题"},{"content":"前端面试中算法题是比较难的一部分，今天总结下数据结构中的算法实现。\n排序 快速排序 找到一个数作为参考，比这个数字大放左边，比它小放右边，然后分别对左边和右边做相同操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function quickSort(arr) { if (arr.length \u0026lt;= 1) { return arr; // 递归出口  } var left = [], right = [], current = arr.splice(0, 1); for (let i = 0; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt; current) { left.push(arr[i]) } else { right.push(arr[i]) } } return quickSort(left).concat(current,quickSort(right)); // 递归 }   冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13  function bubbleSort(arr){ var len = arr.length; for(let outer = len;outer \u0026gt;= 2;outer--){ for(let inner = 0;inner \u0026lt;= outer-1;inner++){ if(arr[inner] \u0026gt; arr[inner+1]){ let temp = arr[inner]; arr[inner] = arr[inner+1]; arr[inner+1] = temp; } } } return arr; }    外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当\u0026gt;=2时即可停止； 内层是两两比较，从0开始，比较inner与inner+1，因此，临界条件是inner\u0026lt;outer -1  选择排序 1 2 3 4 5 6 7 8 9 10 11  function selectSort(arr){ var len = arr.length; for(let i=0;i \u0026lt; len-1; i++){ for(let j=i; j\u0026lt;len; j++){ if(arr[j] \u0026lt; arr[i]){ [arr[i],arr[j]]=[arr[j],arr[i]]; } } } return arr }   插入排序 1 2 3 4 5 6 7 8 9 10 11 12  function insertSort(arr){ for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i;j\u0026gt;0;j--){ if(arr[j]\u0026lt;arr[j-1]){ [arr[j],arr[j-1]]=[arr[j-1],arr[j]]; }else{ break; } } } return arr; }   栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Stack { constructor() { this.stack = [] } push(item) { this.stack.push(item) } pop() { this.stack.pop() } getLength() { return this.stack.length } isEmpty() { return this.getLength() === 0 } }   应用(匹配括号) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  var isMatch = function(arr){ let map = { \u0026#39;(\u0026#39;:-1, \u0026#39;)\u0026#39;:1, \u0026#39;[\u0026#39;:-2, \u0026#39;]\u0026#39;:2, \u0026#39;{\u0026#39;:-3, \u0026#39;}\u0026#39;:3 } let stack = [] for(let i = 0; i\u0026lt;arr.length; i++){ if(map[arr[i]] \u0026lt; 0){ stack.push(arr[i]) }else{ let last = stack.pop() if(map[last] + map[arr[i]] != 0) return false } } if(stack.length \u0026gt; 0) return false return true };   队列 简单单链队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Queue { constructor(){ this.queue = [] } enQueue(item){ this.queue.push(item) } deQueue(){ return this.queue.shift() } getHeader(){ return this.queue[0] } getLength(){ return this.queue.length } isEmpty(){ return this.getLength() === 0 } }   循环队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  class SqQueue{ constructor(length){ this.queue = new Array(length + 1) this.first = 0 this.last = 0 this.size = 0 } enQueue(item){ // 判断队尾+1是否为队头  // 是就代表需要扩容数组  // %this.queue.length 为了防止数组越界  if(this.first===(this.last + 1) % this.queue.length){ this.resize(this.getLength() * 2 + 1) } this.queue[this.last] = item this.size++ this.last = (this.last+1) % this.queue.length } deQueue(){ if(this.isEmpty()){ throw Error(\u0026#39;Queue is empty\u0026#39;) } let r = this.queue[this.first] this.queue[this.first] = null this.first = (this.first+1) % this.queue.length this.size-- // 判断当前队列大小是否过小  // 在队列空间等于总长度的1/4时缩小总长度为当前一半  if(this.size === this.getLength()/4 \u0026amp;\u0026amp; this.getLength() / 2 !== 0){ this.resize(this.getLength() / 2) } return r } getHeader() { if (this.isEmpty()) { throw Error(\u0026#39;Queue is empty\u0026#39;) } return this.queue[this.first] } getLength(){ return this.queue.length - 1 } isEmpty(){ return this.first ==== this.last } resize(length){ let q = new Array(length) for(let i = 0;i \u0026lt; length; i++){ q[i] = this.queue[(i + this.first) % this.queue.length] } this.queue = q this.first = 0 this.last = this.size } }   链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  class Node { constructor(v, next) { this.value = v this.next = next } } class LinkList { constructor() { // 链表长度  this.size = 0 // 虚拟头部  this.dummyNode = new Node(null, null) } find(header, index, currentIndex) { if (index === currentIndex) return header return this.find(header.next, index, currentIndex + 1) } addNode(v, index) { this.checkIndex(index) // 当往链表末尾插入时，prev.next 为空  // 其他情况时，因为要插入节点，所以插入的节点的 next 应该是prev.next  // 然后设置 prev.next 为插入的节点  let prev = this.find(this.dummyNode, index, 0) prev.next = new Node(v, prev.next) this.size++ return prev.next } insertNode(v, index) { return this.addNode(v, index) } addToFirst(v) { return this.addNode(v, 0) } addToLast(v) { return this.addNode(v, this.size) } removeNode(index, isLast) { this.checkIndex(index) index = isLast ? index - 1 : index let prev = this.find(this.dummyNode, index, 0) let node = prev.next prev.next = node.next node.next = null this.size-- return node } removeFirstNode() { return this.removeNode(0) } removeLastNode() { return this.removeNode(this.size, true) } checkIndex(index) { if (index \u0026lt; 0 || index \u0026gt; this.size) throw Error(\u0026#39;Index error\u0026#39;) } getNode(index) { this.checkIndex(index) if (this.isEmpty()) return return this.find(this.dummyNode, index, 0).next } isEmpty() { return this.size === 0 } getSize() { return this.size } }   二叉查找树BST 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Node{ constructor(value){ this.value = value this.left = null this.right = null } } class BST{ constructor(){ this.root = null this.size = 0 } getSize(){ return this.size } isEmpty(){ return this.size === 0 } addNode(v) { this.root = this._addChild(this.root, v) } // 添加节点时，需要比较添加的节点值和当前节点值的大小  _addChild(node, v) { if (!node) { this.size++ return new Node(v) } if (node.value \u0026gt; v) { node.left = this._addChild(node.left, v) } else if (node.value \u0026lt; v) { node.right = this._addChild(node.right, v) } return node } }   堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class MaxHeap{ constructor(){ this.heap=[] } size(){ return this.heap.length } empty(){ return this.size() == 0 } add(item){ this.heap.push(item) this._shiftUp(this.size()-1) } removeMax(){ this._shiftDown(0) } getParentIndex(k){ return parseInt((k - 1) / 2) } getLeftIndex(k){ return k * 2 + 1 } _shiftUp(k){ // 如果当前节点比父节点大，就交换  while(this.heap[k]\u0026gt;this.heap[this.getParentIndex(k)]){ this._swap(k,this.getParentIndex(k)) // 将索引变成父节点  k = this.getParentIndex(k) } } _swap(left, right) { let rightValue = this.heap[right] this.heap[right] = this.heap[left] this.heap[left] = rightValue } _shiftDown(k){ // 交换首位并删除末尾  this._swap(k, this.size() - 1) this.heap.splice(this.size() - 1, 1) // 判断节点是否有孩子，二叉堆有左必有右  while(this.getLeftIndex(k) \u0026lt; this.size()){ let j=this.getLeftIndex(k) // 判断是否有右孩子 并且右是否比左大  if(j+1 \u0026lt; this.size() \u0026amp;\u0026amp; this.heap[j+1] \u0026gt; this.heap[j]) j++ // 判断父节点是否比子节点都大  if(this.heap[k] \u0026gt;= this.heap[j]) break this._swap(k, j) k = j } } }   二叉树的先序/中序/后序遍历 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function TreeNode(val){ this.val = val; this.left = this.right = null; } var traversal = function(root){ if(root){ // 先序  console.log(root); traversal(root.left); // 中序 左之后输出  // console.log(root);  traversal(root.right); // 后序 左右根  // console.log(root);  } }   非递归实现 先序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function pre(root) { if (root) { let stack = []; stack.push(root); //先push根节点  while (stack.length \u0026gt; 0) { // 弹出栈顶元素  root = stack.pop(); console.log(root); // 栈是先进后出 先序遍历是先左后右  // 所以先push右边 再push左边  if(root.right){ stack.push(root.right); } if(root.left){ stack.push(root.left); } } } }   中序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function mid(root){ if(root){ let stack = []; // 中序遍历是左根右  // 先把左边节点遍历到底 依次push进栈  // 当左边没有节点时打印栈顶元素 然后寻找右节点  // 左边打印不出东西就打印父节点，然后看右节点  while(stack.length\u0026gt;0 || root){ if(root){ stack.push(root); root = root.left; }else{ root = stack.pop(); console.log(root); root = root.right; } } } }   后序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function pos(root){ if(root){ let stack1 = []; let stack2 = []; // 左右根 对于栈来说 先push根节点  // 然后push右节点 最后左节点  stack1.push(root); while(stack1.length \u0026gt; 0){ root = stack1.pop(); stack2.push(root); if(root.left){ stack1.push(root.left); } if(root.right){ stack1.push(root.right); } } while(stack2.length \u0026gt; 0){ console.log(s2.pop()); } } }   动态规划 解决斐波那契数列问题\n 斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层 通过数组来存储每一位所对应的斐波那契数列的值  1 2 3 4 5 6 7 8 9  function fib(n){ let array=new Array(n+1).fill(null) array[0] = 0 array[1] = 1 for(let i=2; i \u0026lt;= n; i++){ array[i] = array[i-1]+array[i-2] } return array[n] }   学习算法时，可视化界面可以帮助我们更好的理解，推荐配合VisualAlgo或Algorithm Visualizer。\n","date":"2019-02-15T18:24:10Z","image":"https://neptoo.github.io/2019/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/data-structure_hu639d2c065a0b82b0b98f6af0a78cd49d_33146_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2019/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","title":"前端数据结构的算法实现"},{"content":"最近在学习微信小程序的开发，涉及到移动端设备适配的知识点，想到之前秋招一位面试官问我的问题\u0026ndash;怎么判断用户是用什么设备访问的，是pc端还是移动端？ 我回答的是根据屏幕分辨率大小尺寸，他又表示电脑端也可以竖屏。。。然后我就不知道了，后来他也给我讲了应该怎么解决，现在时间有点久了答案已经忘了，于是决定搜集资料写篇博客记录这个问题。 网上给出的大多数方案，用js判断的原理是浏览器提交的user agent，不管是PC还是手机浏览器。\n第一种，使用indexOf判断\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;script\u0026gt; var userAgentInfo = navigator.userAgent; var mAgents = new Array(\u0026#34;Android\u0026#34;, \u0026#34;iPhone\u0026#34;, \u0026#34;SymbianOS\u0026#34;, \u0026#34;Windows Phone\u0026#34;, \u0026#34;iPad\u0026#34;, \u0026#34;iPod\u0026#34;); var pAgents = new Array(\u0026#34;Trident\u0026#34;, \u0026#34;Presto\u0026#34;, \u0026#34;Gecko\u0026#34;, \u0026#34;Webkit\u0026#34;); var flag = false; for (var v = 0; v \u0026lt; mAgents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u0026gt; 0) { flag = true; break; } } if (flag) { // 来自于移动端，同理判断PC浏览器 } \u0026lt;/script\u0026gt;   第二种，使用正则表达式判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;script\u0026gt; function browserRedirect() { var ua = navigator.userAgent.toLowerCase() || window.navigator.userAgent.toLowerCase(); var isWX = /MicroMessenger/i.test(ua), isIOS = /(iPhone|iPad|iPod|iOS)/i.test(ua), isAndroid = /(android|nexus)/i.test(ua), isBlackBerry = /BlackBerry/i.test(ua), isWindows = /(Window Phone|windows[\\s+]phone)/i.test(ua), isMidp = /midp/i.test(ua); document.writeln(\u0026#34;您的浏览设备为：\u0026#34;); if (isWX || isIOS || isAndroid || isBlackBerry || isWindows || isMidp) { document.writeln(\u0026#34;phone\u0026#34;); } else { document.writeln(\u0026#34;pc\u0026#34;); } } browserRedirect(); \u0026lt;/script\u0026gt;   除此之外，在移动端开发时有的项目还要考虑到兼容横竖屏。\n","date":"2019-01-16T17:32:44Z","permalink":"https://neptoo.github.io/2019/%E4%BB%8E%E4%B8%80%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7/","title":"从一道前端面试题说起"},{"content":"很久没有更新博客，最近终于学完了Vue全家桶，总结使用Vue开发的快餐店POS系统。系统采用的技术栈是Vue+Element+vueRouter+webpack，成果展示点击查看。\n项目初始化 使用Mockplus将POS系统的框线图画出来，再使用技术实现，可以保持开发时的整体性，避免大范围修改。 webpack+Vue-cli搭建项目结构\n1 2  npm install vue-cli -g vue init webpack vpos   输入npm run dev，如果能正常显示说明安装正确。 新建Pos组件，在该文件中编写vue模板的架构。 修改路由文件，引入Pos模板组件，将入口文件更改为Pos组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13  import Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import Pos from \u0026#39;@/components/page/Pos\u0026#39; Vue.use(Router) export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Pos\u0026#39;, component: Pos } ] })   配置使用项目图标 在阿里巴巴图标库中，新建项目，添加需要的图标到项目中。选择Font Class查看在线链接，在项目首页中引入。 \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;http://at.alicdn.com/t/font_999368_80h0n0s7xy9.css\u0026quot;\u0026gt; 在\u0026quot;我的项目\u0026quot;中选择单个图标，直接复制代码就可以在项目中使用了。\n1  \u0026lt;i class=\u0026#34;icon iconfont icon-hanbao\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;   编写侧边栏导航组件 在src/components目录下，新建common和page文件夹，前者存放共用组件，后者存放页面模板文件。 在common文件夹下新建leftNav.vue文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;left-nav\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026#34;icon iconfont icon-hanbao\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div\u0026gt;商品\u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026#34;icon iconfont icon-dianpu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div\u0026gt;店铺\u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026#34;icon iconfont icon-goumai\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div\u0026gt;收银\u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026#34;icon iconfont icon-huiyuanqia\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div\u0026gt;会员\u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026#34;icon iconfont icon-gongnengjianyi\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;div\u0026gt;设置\u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name:\u0026#39;leftNav\u0026#39;, data(){ return{} } } \u0026lt;/script\u0026gt;   然后给组件设置一些CSS样式，就算写好了。再在App.vue中引入leftNav组件，然后在构造器里添加components属性，放入leftNav组件。最后在\u0026lt;template\u0026gt;区域使用就可以查看了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;leftNav\u0026gt;\u0026lt;/leftNav\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import leftNav from \u0026#39;@/components/common/leftNav\u0026#39; export default { name: \u0026#39;App\u0026#39;, components:{ leftNav } } \u0026lt;/script\u0026gt;   引入Element组件库 1  npm install element-ui --save   在main.js中引入\n1 2 3 4 5  import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.config.productionTip = false Vue.use(ElementUI);   用Element标签实现栅栏布局 在Pos.vue中添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;pos\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-col :span=\u0026#39;7\u0026#39;\u0026gt; 我是订单栏 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;17\u0026#34;\u0026gt; 我是商品栏 \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   实现两栏高度100% 给对应的\u0026lt;el-row\u0026gt;添加id，在使用钩子函数设置高度。\n1 2 3 4  mounted:function(){ var orderHeight=document.body.clientHeight; document.getElementById(\u0026#34;order-list\u0026#34;).style.height=orderHeight+\u0026#39;px\u0026#39;; }   用el-tabs制作标签页，el-table组件制作表格，el-button设置按钮。具体使用方法可以到Element的官网查看API。\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border style=\u0026#34;width:100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;goodsName\u0026#34; label=\u0026#34;商品名称\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;count\u0026#34; label=\u0026#34;数量\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;金额\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; fixed=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;增加\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt;   其中:data用于绑定数据源，tableData为示例数据数组，实际开发中可以使用axios从后台读取。 在\u0026lt;el-col :span=17\u0026gt;标签里增加一个层，然后在层内使用无序列表来布局常用商品。\n1 2 3 4 5 6 7 8  \u0026lt;div class=\u0026#34;often-goods\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;常用商品\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;often-goods-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;goods in oftenGoods\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{goods.goodsName}}\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;o-price\u0026#34;\u0026gt;￥{{goods.price}}\u0026lt;/span\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   在vue构造器里声明食品数组typeGoods，再用v-for来输出数据。\n1 2 3 4 5  \u0026lt;li v-for=\u0026#34;goods in typeGoods[0]\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;foodImg\u0026#34;\u0026gt;\u0026lt;img :src=\u0026#34;goods.goodsImg\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;60px\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;foodName\u0026#34;\u0026gt;{{goods.goodsName}}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;foodPrice\u0026#34;\u0026gt;￥{{goods.price}}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt;   使用方法实现对商品操作 添加商品到订单界面 在vue的构造器里加入methods方法，在methods方法里再加入addOrderList方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  methods:{ //添加订单列表的方法 addOrderList(goods){ this.totalCount=0; //汇总数量清0 this.totalMoney=0; let isHave=false; //判断是否这个商品已经存在于订单列表 for (let i=0; i\u0026lt;this.tableData.length;i++){ console.log(this.tableData[i].goodsId); if(this.tableData[i].goodsId==goods.goodsId){ isHave=true; //存在 } } //根据isHave的值判断订单列表中是否已经有此商品 if(isHave){ //存在就进行数量添加 let arr = this.tableData.filter(o =\u0026gt;o.goodsId == goods.goodsId); arr[0].count++; //console.log(arr); }else{ //不存在就推入数组 let newGoods={goodsId:goods.goodsId,goodsName:goods.goodsName,price:goods.price,count:1}; this.tableData.push(newGoods); } //进行数量和价格的汇总计算 this.sumMoney(); }, // 汇总数量和金额 sumMoney() { this.totalCount = 0; this.totalMoney = 0; if (this.tableData) { this.tableData.forEach((element) =\u0026gt; { this.totalCount += element.count; this.totalMoney = this.totalMoney + (element.price * element.count); }) } } }   在商品上绑定方法\n1  \u0026lt;li v-for=\u0026#34;goods in typeGoods[0]\u0026#34; @click=\u0026#34;addOrderList(goods)\u0026#34;\u0026gt;\u0026lt;/li\u0026gt;   在订单列表中绑定方法\n1  \u0026lt;el-button type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34; @click=\u0026#34;addOrderList(scope.row)\u0026#34;\u0026gt;增加\u0026lt;/el-button\u0026gt;   删除单个商品：在veu构造器methods属性里增加一个delSingleGoods方法，并接收goods对象为参数，用数组的filter可以轻松删除数组中单个的商品。 删除全部订单商品：清空tableData，totalMoney，totalCount数据即可。\n模拟结账 1 2 3 4 5 6 7 8 9 10 11 12 13  checkOut() { if (this.totalCount != 0) { this.tableData = []; this.totalCount = 0; this.totalMoney = 0; this.$message({ message: \u0026#39;结账成功，感谢你又完成了一笔订单！\u0026#39;, type: \u0026#39;success\u0026#39; }); } else { this.$message.error(\u0026#39;购物车为空，不能结账！\u0026#39;); } }   ","date":"2019-01-09T17:58:02Z","permalink":"https://neptoo.github.io/2019/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%BC%80%E5%8F%91%E5%BF%AB%E9%A4%90%E5%BA%97pos%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","title":"Vue全家桶开发快餐店POS系统项目总结"},{"content":"本文主要总结了正则表达式的一些基础知识点，完整详细的正则知识学习，推荐老姚的JS正则表达式完整教程（略长）。\n2020年2月21日更新：\n强烈推荐学习/使用正则表达式的在线网站：在线测试，验证正则表达式的工具。\n regexper regex101 refiddle  正则表达式基础知识 ^匹配开始 $匹配结束 ? 0个或1个 do(es)?能匹配do和does * 0个或多个 zo*能匹配z和zoo + 1次或多次 zo+能匹配zo或zoo，但不能匹配z . 匹配除\u0026quot;\\n\u0026quot;以外的任意字符 \\d 任何一个数字字符，等价于0-9 \\D任何非数字字符 \\w 包括下划线在内的任何单词字符 等价 [0-9a-zA-Z_] {number} 设置匹配字符数量  创建正则实例化对象  字面量方式:通过两个反斜杠“/”，/模式/修饰符；  1 2 3  var str1 = \u0026#34;wwww22222\u0026#34;; var exp1 = /[a-z 0-9]/; console.log(exp1.test(str1));//true   手机号正则表达式验证\n1 2 3  var str = \u0026#39;15012345678\u0026#39;; var exp = /^1[3|4|5|7|8]\\d{9}$/; console.log(exp.test(str)); //true   用户名正则，4到16位（字母，数字，下划线，减号） var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;\n整数正则var intPattern = /^-?\\d+$/;\n邮箱Email正则 var reg = /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/; 2. 构造函数方式：通过new RegExp(模式，修饰符)；\n1 2 3  var str = \u0026#34;cdbbdz\u0026#34;; var exp = new RegExp(\u0026#34;d(b+)d\u0026#34;, \u0026#34;g\u0026#34;); console.log(exp.test(str)); //true   使用正则表达式的方法 test() 测试是否包含exp方法，返回true或false 字符串的方法：search()、match()、 replace()、split() 当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。\nstrObj.search( regexp )：检查字符串与当前的正则模式所匹配的子字符串首次出现的位置，返回匹配成功子字符串的位置；若没有的话，则返回-1。\n1 2 3 4 5  var str = \u0026#34;javascript\u0026#34;; console.log(str.search(/script/)); //下标为：4 if (str.search(/script/) !== -1) { console.log(\u0026#34;通过\u0026#34;); }   strObj.match(regexp)：检查字符串把与正则模式所匹配的子字符串，以数组的形式输出。\n1 2  var str = \u0026#34;0你好，1我好，大家好\u0026#34;; console.log(str.match(/\\d/g)); //[\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;]   strObj.replace( regexp，newStr | fn )：检查字符串与正则模式所匹配的子字符串，并替换。\n1 2  var str = \u0026#34;如果你感兴趣，可添加淘宝或微信账号x12345联系\u0026#34;; console.log(str.replace(/淘宝|微信|百度/g, \u0026#34;**\u0026#34;)); // 如果你感兴趣，可添加**或**账号x12345联系   strObj.split(regexp，n)：切割字符串，返回数组格式的结果。第二个参数是限制返回的数组长度。\n1 2 3  var str = \u0026#34;如果你111爱我.2222如果我也爱你333 那我们就在一起吧\u0026#34;; console.log(str.split(/\\d+/g)); //[\u0026#34;如果你\u0026#34;, \u0026#34;爱我.\u0026#34;, \u0026#34;如果我也爱你\u0026#34;, \u0026#34; 那我们就在一起吧\u0026#34;] console.log(str.split(/\\d+/g,2));//[\u0026#34;如果你\u0026#34;, \u0026#34;爱我.\u0026#34;]   exec()：查找当前字符串与正则模式所匹配的文本，最终存储在数组里；匹配不成功返回null。\n1 2 3 4 5  var user = \u0026#34;{{1007}},{{1008}},{{1009}},{{1010}}\u0026#34;; var exp = /\\{\\{(\\d+)\\}\\}/g; var result = exp.exec(user); console.log(result); // [\u0026#34;{{1007}}\u0026#34;, \u0026#34;1007\u0026#34;, index: 0, input: \u0026#34;{{1007}},{{1008}},{{1009}},{{1010}}\u0026#34;]   参考资料：正则表达式 | MDN\n","date":"2018-12-10T15:03:06Z","image":"https://neptoo.github.io/2018/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regexp_hu94d6803a612734235fdcf581ede0213d_273026_120x120_fill_q75_box_smart1.jpg","permalink":"https://neptoo.github.io/2018/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"JS正则表达式"},{"content":"本文先介绍开发前的准备工作（搭建静态资源服务器+图标生成+安装node.js环境），并通过vue命令生成vue-cli脚手架，形成项目开发框架。具体的阅读器功能实现见下篇。本次开发采用的是epub(电子书出版物)格式的电子书，目前比较主流的电子书阅读器对epub都有良好的支持。\n图标生成 首先通过阿里巴巴矢量图标库等下载好需要的图标，本项目使用的电子书和图标资源下载。 在IcoMoon新建图标集合，导入本地图标，点击generate font生成字体图标，然后下载解压。\n环境搭建 **安装Node.js和Vue.js环境 ** 通过vue init webpack搭建Vue项目脚手架 启动项目 npm run dev启动项目，成功，可在localhost:8080访问站点。 打开项目文件中config/index.js将host:'localhost'改为host:'0.0.0.0'，就可以通过本地ip地址查看。windows下查看本地ip：打开控制台，输入ipconfig;uinx指令是ifconfig。 搭建静态资源服务器 将电子书拷贝到static目录下，然后通过站点地址加上static/Engine.epub，下载电子书。下载成功，说明静态资源服务器搭建好了。 下载依赖包\n1 2  npm install node-sass sass-loader --save-dev npm install epubjs --save   在src/assets下新建styles文件夹，将字体图标的fonts和style.css拷贝进去，将style.css改为icon.css。然后在main.js中import '@/assets/styles/icon.css'。\nviewport配置 在index.html中找到viewport更改为\n1  \u0026lt;meta name=\u0026#34;viewport\u0026#34;content=\u0026#34;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\u0026#34;\u0026gt;   以上配置可以让网页配置，适配手机屏幕宽度，并且不允许用户修改，不允许用户缩放。\nrem配置 rem是css3新增的相对长度单位，随着屏幕宽度的动态变化，rem的值也会动态变化。 打开App.vue，删除style里默认样式，在script里增加事件使字体随屏幕宽度动态变化。\n1 2 3 4 5 6 7 8 9  document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, setFontSize); window.addEventListener(\u0026#39;resize\u0026#39;, setFontSize) function setFontSize() { const html = document.querySelector(\u0026#34;html\u0026#34;); let fontSize = window.innerWidth / 10; \u0026lt;!-- 限制字体最大值 --\u0026gt; fontSize = fontSize \u0026gt; 50 ? 50 : fontSize; html.style.fontSize = fontSize + \u0026#34;px\u0026#34;; }   基本样式 在styles下面新建reset.scss，消除浏览器默认样式，将网上下载的样式重置代码拷贝进去，并设置\n1 2 3 4 5 6  html,body{ width:100%; height:100%; font-family: \u0026#39;PingFangSC-Light\u0026#39;,\u0026#39;PingFang SC\u0026#39;,\u0026#39;STHeitiSC-Light\u0026#39;, \u0026#39;Helvetica-Light\u0026#39;,\u0026#39;Arial\u0026#39;,\u0026#39;sans-serif\u0026#39;; }   创建global.scss规定整个站点的公共样式和方法，在main.js中引入import \u0026lsquo;@/assets/styles/global.scss\u0026rsquo;。\n1 2 3 4 5 6 7 8 9 10 11 12  @import \u0026#39;reset\u0026#39;; $fontSize: 37.5; \u0026lt;!-- px2rem将px转化为rem --\u0026gt; @function px2rem($px) { @return ($px / $fontSize)+rem; } \u0026lt;!-- mixin定义后面要用的样式 --\u0026gt; @mixin center() { display: flex; justify-content: center; align-items: center; }   ","date":"2018-11-22T12:52:09Z","permalink":"https://neptoo.github.io/2018/%E7%94%A8vue%E5%AE%9E%E7%8E%B0web%E9%98%85%E8%AF%BB%E5%99%A8%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","title":"用Vue实现Web阅读器开发项目总结"},{"content":"最近几天登陆博客，发现底部的访问量无法显示了，以为是上次更改的时候不小心删除或修改了某些配置，查找了一遍footer.swig等关于访客量的配置，没有发现问题。搜了下才发现是不蒜子的域名过期了，原来引用的js地址自然需要更改。\n解决方法：更换js引用，打开主题配置中的next\\layout\\_third-party\\analytics\\busuanzi-counter.swig 将原来的\u0026lt;script async src=\u0026quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 更改为\u0026lt;script async src=\u0026quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n","date":"2018-10-14T17:30:42Z","permalink":"https://neptoo.github.io/2018/%E8%A7%A3%E5%86%B3hexo-next%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E8%AE%BF%E9%97%AE%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/","title":"解决Hexo+Next博客无法正常显示访问量的问题"},{"content":"从ES6测试环境搭建到重点知识点小结。\n浏览器环境搭建 ES6语法虽然也是原生JS，但并不是所有浏览器都支持，要在chrome下正常运行，还需要一些构建工具。 首先安装好Git(windows系统下)，然后在在git bash输入git clone https://github.com/cucygh/es6-webpack.git下载源码，然后安装\n1 2 3 4  cd es6-webpack npm install npm install webpack -g npm install webpack-dev-server -g   运行\n1  npm start   浏览器自动打开localhost:9000，页面显示h33，说明服务已经正常启动。\n执行代码 打开文件夹es6-webpack，例如在src下编辑example.js，在index.js中导入\n1 2  import \u0026#34;./src/example\u0026#34; test()   即可在浏览器端自动输出。\n使用 配置好后，想测试任何ES6的语法，可以在对应文件夹中编写js代码，打开Git输入cd es6-webpack，在命令行执行npm start，浏览器会自动打开http://localhost:9000/，打开浏览器调试面板查看结果就可以了。\n工程环境搭建 在E盘新建文件夹es6，作为工程目录，在目录下新建文件夹src和dist\n src存放es6代码文件 dist存放被编译为es5的代码文件 在src下新建index.html和index.js，在html里引入js文件  1  \u0026lt;script src=\u0026#34;./dist/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   在index.js里用es6语法写一个变量声明，接下来我们将它转换为es5的语法文件。\n打开终端，在es6文件夹下npm init -y初始化项目，会生成package.json文件。 全局安装babel-cli\n1  npm install -g babel-cli   本地安装babel-preset-es2015 和 babel-cli\n1  npm install --save-dev babel-preset-es2015 babel-cli   然后在src下新建.babelrc，添加以下代码\n1 2 3 4 5 6  { \u0026#34;presets\u0026#34;:[ \u0026#34;es2015\u0026#34; ], \u0026#34;plugins\u0026#34;:[] }   输入以下命令，就可以看到dist下的index.js是es5的写法。\n1  babel src/index.js -o dist/index.js   简化命令：打开package.json，找到\u0026quot;scripts\u0026quot;，将\u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot;\u0026amp;\u0026amp; exit 1\u0026quot;更改为\u0026quot;build\u0026quot;: \u0026quot;babel src/index.js -o dist/index.js\u0026quot;，就可以使用npm run build(替换babel src/index.js -o dist/index.js)命令来转换了。\n核心知识点 模板字符串 1 2 3 4 5 6  // 所有模板字符串的空格、换行和缩进，都是被保留的 // 原生 JS const message = \u0026#39;This is my\\n\u0026#39;+\u0026#39;first message.\u0026#39;; // This is my \u0026#39;first\u0026#39; message. const another = `This is my \u0026#39;first\u0026#39; message`;   1 2 3 4 5 6 7 8 9  // 模板字符串中嵌入变量，需要将变量名写在${}之中。 const name = \u0026#39;John\u0026#39;; const another= `Hi ${name}, Thank you for joining my team. Regards, Mosh`;   ","date":"2018-10-05T20:08:00Z","image":"https://neptoo.github.io/2018/es6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ES6_huefcc174cf854441921fc297999d1dc65_123717_120x120_fill_box_smart1_3.png","permalink":"https://neptoo.github.io/2018/es6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","title":"ES6基础入门"},{"content":"所谓模块化就是将需要用到的方法封装成为一个模块，哪里需要直接调用即可。\njs库+命名空间 网上常用的较为简单的一种方法是创建js库，要避免重复，封装自己的函数，要使用命名空间，对象就是天然的命名空间。\n(function(global){ var myfun1=function(){ console.log('myfun1'); }; var myfun2=function(){ console.log('myfun2'); }; //设置你的命名空间 var mypackageName=\u0026quot;com.mydomain.utils\u0026quot;; var packageArray=mypackageName.split(\u0026quot;.\u0026quot;); var finalObj=packageArray.reduce(function(prev,current){ return prev[current]||(prev[current]={}); }, global); //将你的函数绑定到命名空间上 finalObj.myfun1= myfun1; finalObj.myfun2= myfun2; }(window)); com.mydomain.utils.myfun1();//输出 myfun1 com.mydomain.utils.myfun2();//输出 myfun2  ES模块封装 现在模块化机制已经成熟，另一种是使用ES2015 module封装模块。 (1)首先学会怎么用 ES2015 来编写／封装模块（node／npm，加上 babel 的入门知识）； (2)学会发布到npm； (3)如何引入模块到应用体系中，如何加载/打包(gulp/webpack/jspm等)。 封装不只是要学习代码怎么写，更要知道如何维护和应用，否则封装就不具备普适性。\nJavaScript不是基于OO的语言，class不是必需的，还有其他模式，比如工厂函数（Factory Functions）要远比 class 简洁、灵活。\n简单工厂模式 它的作用是，利用面向对象的方法，把一些对象封装，使一些占用空间多的，重复的代码封装起来。 实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性以及方法再将对象返回即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function creatper(name,age){ var per=new Object(); //原料  //加工  per.name=name; per.age=age; per.sayHi=function(){ console.log(per.name+\u0026#39;\u0026#39;+per.age); } return per; //出厂  } var me=creatper(\u0026#39;katherine\u0026#39;,22); me.sayHi(); console.log(me.name);   可以看出使用工厂模式，可以重复调用这个per函数来生成不同属性值得对象，这就像工厂一样，批量生产，里面的原料，加工，出厂都很清晰。但是你会发现工厂模式是无法识别对象的类型，因为全都是object，不像Date，Array等，但是构造函数就不是了。这还只是简单的工厂模式，复杂的工厂模式（抽象模式）等以后再回来详细了解。\n","date":"2018-09-30T18:44:32Z","permalink":"https://neptoo.github.io/2018/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85js-%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%B0%81%E8%A3%85/","title":"如何封装JS-模块化与封装"},{"content":"搭建好博客后，再对博客进行个性化设置，优化页面。\n添加分类、标签、关于等页面 打开git bash，在站点目录下输入hexo new page \u0026quot;categories\u0026quot; 在站点目录source文件夹下，会新增categories文件夹，里面有一个index.md文件，打开后即可更改配置。tags,about页面创建类似，输入\nhexo new page \u0026quot;tags\u0026quot; hexo new page \u0026quot;about\u0026quot;  打开主题配置文件_config.yml找到menu，添加对应菜单。 打开next\\language文件下的zh-CN，添加菜单标签项：\n menu home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 music: 音乐\n 设置右侧栏头像 编辑站点配置文件，找到avatar，设置url地址为/image/avatar.png，avatar.png放在/站点目录/source/image/里。\n设置头像旋转效果 打开themes\\next\\source\\css\\_common\\components\\sidebar\\sidebar-author.styl,添加以下注释代码。\n.site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转时间 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; }  设置RSS 在站点目录下，执行git bash命令： npm install --save hexo-generator-feed 安装插件后，打开全局配置文件，加入代码：\n# Extensions ## Plugins: http://hexo.io/plugins/ plugins: hexo-generate-feed  然后打开主题配置文件_config.yml，找到rss，添加rss: /atom.xml。\n自定义博客底部效果   隐藏power by hexo/强力驱动 打开themes/next/layout/_partials/footer.swig,直接注释隐藏以下代码即可,建议不要删除，代码如下:\n 实现网站底部访问量显示 打开主题配置文件_config.yml,修改如下代码：     busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye\n 首页文章阴影边框效果 打开next\\source\\css\\_custom\\custom.styl文件,添加以下代码:\n1 2 3 4 5 6 7 8  // 主页文章添加阴影效果 .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); }   添加社交链接 编辑站点配置文件，添加\n social: github: https://github.com/your-user-name || github twitter: https://twitter.com/your-user-name|| twitter weibo: http://weibo.com/your-user-name || weibo douban: http://douban.com/people/your-user-name || douban zhihu: http://www.zhihu.com/people/your-user-name || name\n ||后面可以自定义需要的社交图标，name是图标名字\n发表新文章 在站点根目录下，打开git bash,输入hexo n \u0026quot;name of new post\u0026quot; 回车后，可以在source文件夹下的_post文件下，看到新建了一个name of new post.md文件，可以给文章贴上相应标签tags，[tag1,tag2,...]，在\u0026ndash;下方添加正文内容。\n首页博客相关设置  文章以摘要形式显示 打开主题配置文件，找到如下位置并修改   auto_excerpt: enable: true length: 150 其中length代表显示摘要的截取字符长度\n   设置首页文章显示篇数 安装插件：\nnpm install \u0026ndash;save hexo-generator-index npm install \u0026ndash;save hexo-generator-archive npm install \u0026ndash;save hexo-generator-tag 在站点配置文件中添加代码（per_page是显示篇数）\nindex_generator: per_page: 8 archive-generator: per_page: 20 yearly: true monthly: true  tag_generator: per_page: 10\n  文章置顶 打开站点根目录下node_modules/hexo-generator-index/lib/generator.js,将以下代码替换原来的。在文章中添加top值，数值越大文章越靠前。\n\u0026lsquo;use strict\u0026rsquo;; var pagination = require(\u0026lsquo;hexo-pagination\u0026rsquo;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top \u0026amp;\u0026amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top \u0026amp;\u0026amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面 return -1; } else if(!a.top \u0026amp;\u0026amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || \u0026lsquo;page\u0026rsquo;; return pagination(\u0026rsquo;\u0026rsquo;, posts, { perPage: config.index_generator.per_page, layout: [\u0026lsquo;index\u0026rsquo;, \u0026lsquo;archive\u0026rsquo;], format: paginationDir + \u0026lsquo;/%d/\u0026rsquo;, data: { __index: true } }); };\n  文章底部打赏 开启文章底部打赏功能：在主题配置文件中，配置如下：\nReward reward_comment: 创作不易，感谢支持 wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg #bitcoin: /images/bitcoin.png\n  ","date":"2018-09-23T19:25:24Z","permalink":"https://neptoo.github.io/2018/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96/","title":"博客主题个性化"},{"content":"Hexo是使用较为广泛的一个快速简洁的博客框架，Github可以免费托管代码，本文以next主题为例，帮助新手从零开始搭建个人技术博客。\n安装和配置Hexo 首先安装Node.js 和Git,安装完以后，打开Git-bash或cmd 输入\n1  npm install -g hexo-cli   使用Hexo本地建站 选择本地文件夹，比如D:\\hexo安装,输入\n1 2 3  hexo init D:\\hexo cd D:\\hexo npm install   输入hexo s，如果显示如下\n1 2 3  hexo s INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.   则说明建站成功，访问本地地址 (http://localhost:4000/) 可以看到主题默认效果。\n下载next主题 1 2  cd D:\\Hexo git clone https://github.com/iissnan/hexo-theme-next themes/next   打开D:\\hexo下的_config.yml文件，找到theme字段，修改为theme: next，然后使用命令hexo g和hexo s，访问本地地址，查看确认主题是否切换为next。\n将博客托管到github上  注册github账号 注册成功并验证邮箱后，点击右上方+new repository。在Repository name中填写 你的Github账户名.github.io ，Description中填写对此repository的描述信息(可选，但建议填写，如Personal website)。  配置SSH (1) 生成SSH：打开git bash，输入命令\n1  ssh-keygen -t rsa -C \u0026#34;your email\u0026#34;   其中,your email是注册github的邮箱，接下来几步都直接按回车键，最后yes确认。\n(2)在本地文件夹中，找到~/.ssh/id_rsa.pub文件，复制里面的内容。\n打开Github官网，登陆后进入到个人设置，点击右侧的SSH Keys，点击Add SSH key；填写title之后，将之前复制的内容粘贴到Key框中，最后点击Add key即可。\n输入命令 ssh -T git@github.com ，显示以下则配置成功\nHi username! You've successfully authenticated, but GitHub does not provide shell access.\n打开D:\\hexo文件夹中的_config.yml文件，找到如下位置，填写\n1 2 3  deploy: type: git repo: git@github.com:MyGithub/MyGithub.github.io   注：其中MyGithub替换成你的Github账户，通过访问http://MyGithub.github.io 可以看到默认的Hexo首页面。\n如果出现错误ERROR Deployer not found: git，则使用如下命令安装git包\n1  npm install hexo-deployer-git -save   ","date":"2018-07-14T18:11:42Z","permalink":"https://neptoo.github.io/2018/%E6%90%AD%E5%BB%BAhexo-next%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"搭建Hexo-next个人博客"}]